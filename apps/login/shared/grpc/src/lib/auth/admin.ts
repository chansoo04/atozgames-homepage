// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'auth.admin';

export interface User {
  userId: string;
  email: string;
  /** 사원번호 */
  employeeNumber: string;
  /** 이름 */
  name: string;
  /** 부서 ID */
  departmentId: number;
  /** 직책 ID */
  positionId: number;
  /** 직무 ID */
  jobId: number;
  /** 전화번호 */
  phoneNumber: number;
  /** 사내번호 */
  extensionNumber: number;
  /** 계정 상태 */
  state: number;
  /** 생성일 */
  createdAt: string;
}

/** 요청 및 응답 메시지 */
export interface SignInRequest {
  email: string;
  password: string;
}

export interface SignInResponse {
  success: boolean;
  errorMessage: string;
  accessToken: string;
  refreshToken: string;
  user?: User | undefined;
  role: string[];
}

export interface TokenRequest {
  accessToken: string;
  refreshToken: string;
}

export interface VerifyTokenResponse {
  success: boolean;
  errorMessage: string;
}

export interface TokenWithContextRequest {
  accessToken: string;
  refreshToken: string;
  /** 접근 권한이 필요한 리소스 id */
  resource: string;
  /** 리소스에 대한 액션 id */
  action: string;
}

export interface VerifyTokenWithContextResponse {
  success: boolean;
  errorMessage: string;
}

export interface RenewTokenResponse {
  success: boolean;
  errorMessage: string;
  accessToken: string;
  refreshToken: string;
}

export interface DystroyTokenResponse {
  success: boolean;
  errorMessage: string;
}

function createBaseUser(): User {
  return {
    userId: '',
    email: '',
    employeeNumber: '',
    name: '',
    departmentId: 0,
    positionId: 0,
    jobId: 0,
    phoneNumber: 0,
    extensionNumber: 0,
    state: 0,
    createdAt: '',
  };
}

export const User = {
  encode(
    message: User,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== '') {
      writer.uint32(18).string(message.email);
    }
    if (message.employeeNumber !== '') {
      writer.uint32(26).string(message.employeeNumber);
    }
    if (message.name !== '') {
      writer.uint32(34).string(message.name);
    }
    if (message.departmentId !== 0) {
      writer.uint32(40).int32(message.departmentId);
    }
    if (message.positionId !== 0) {
      writer.uint32(48).int32(message.positionId);
    }
    if (message.jobId !== 0) {
      writer.uint32(56).int32(message.jobId);
    }
    if (message.phoneNumber !== 0) {
      writer.uint32(64).int64(message.phoneNumber);
    }
    if (message.extensionNumber !== 0) {
      writer.uint32(72).int32(message.extensionNumber);
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.createdAt !== '') {
      writer.uint32(90).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.employeeNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.departmentId = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.positionId = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.jobId = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.phoneNumber = longToNumber(reader.int64());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.extensionNumber = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      employeeNumber: isSet(object.employeeNumber)
        ? globalThis.String(object.employeeNumber)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      departmentId: isSet(object.departmentId)
        ? globalThis.Number(object.departmentId)
        : 0,
      positionId: isSet(object.positionId)
        ? globalThis.Number(object.positionId)
        : 0,
      jobId: isSet(object.jobId) ? globalThis.Number(object.jobId) : 0,
      phoneNumber: isSet(object.phoneNumber)
        ? globalThis.Number(object.phoneNumber)
        : 0,
      extensionNumber: isSet(object.extensionNumber)
        ? globalThis.Number(object.extensionNumber)
        : 0,
      state: isSet(object.state) ? globalThis.Number(object.state) : 0,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.employeeNumber !== '') {
      obj.employeeNumber = message.employeeNumber;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.departmentId !== 0) {
      obj.departmentId = Math.round(message.departmentId);
    }
    if (message.positionId !== 0) {
      obj.positionId = Math.round(message.positionId);
    }
    if (message.jobId !== 0) {
      obj.jobId = Math.round(message.jobId);
    }
    if (message.phoneNumber !== 0) {
      obj.phoneNumber = Math.round(message.phoneNumber);
    }
    if (message.extensionNumber !== 0) {
      obj.extensionNumber = Math.round(message.extensionNumber);
    }
    if (message.state !== 0) {
      obj.state = Math.round(message.state);
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.userId = object.userId ?? '';
    message.email = object.email ?? '';
    message.employeeNumber = object.employeeNumber ?? '';
    message.name = object.name ?? '';
    message.departmentId = object.departmentId ?? 0;
    message.positionId = object.positionId ?? 0;
    message.jobId = object.jobId ?? 0;
    message.phoneNumber = object.phoneNumber ?? 0;
    message.extensionNumber = object.extensionNumber ?? 0;
    message.state = object.state ?? 0;
    message.createdAt = object.createdAt ?? '';
    return message;
  },
};

function createBaseSignInRequest(): SignInRequest {
  return { email: '', password: '' };
}

export const SignInRequest = {
  encode(
    message: SignInRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.email !== '') {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== '') {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignInRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignInRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignInRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      password: isSet(object.password)
        ? globalThis.String(object.password)
        : '',
    };
  },

  toJSON(message: SignInRequest): unknown {
    const obj: any = {};
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.password !== '') {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignInRequest>, I>>(
    base?: I,
  ): SignInRequest {
    return SignInRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignInRequest>, I>>(
    object: I,
  ): SignInRequest {
    const message = createBaseSignInRequest();
    message.email = object.email ?? '';
    message.password = object.password ?? '';
    return message;
  },
};

function createBaseSignInResponse(): SignInResponse {
  return {
    success: false,
    errorMessage: '',
    accessToken: '',
    refreshToken: '',
    user: undefined,
    role: [],
  };
}

export const SignInResponse = {
  encode(
    message: SignInResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.accessToken !== '') {
      writer.uint32(26).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(34).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    for (const v of message.role) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignInResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignInResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.role.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignInResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : '',
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : '',
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      role: globalThis.Array.isArray(object?.role)
        ? object.role.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SignInResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.role?.length) {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignInResponse>, I>>(
    base?: I,
  ): SignInResponse {
    return SignInResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignInResponse>, I>>(
    object: I,
  ): SignInResponse {
    const message = createBaseSignInResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    message.user =
      object.user !== undefined && object.user !== null
        ? User.fromPartial(object.user)
        : undefined;
    message.role = object.role?.map(e => e) || [];
    return message;
  },
};

function createBaseTokenRequest(): TokenRequest {
  return { accessToken: '', refreshToken: '' };
}

export const TokenRequest = {
  encode(
    message: TokenRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRequest {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : '',
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : '',
    };
  },

  toJSON(message: TokenRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRequest>, I>>(
    base?: I,
  ): TokenRequest {
    return TokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRequest>, I>>(
    object: I,
  ): TokenRequest {
    const message = createBaseTokenRequest();
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    return message;
  },
};

function createBaseVerifyTokenResponse(): VerifyTokenResponse {
  return { success: false, errorMessage: '' };
}

export const VerifyTokenResponse = {
  encode(
    message: VerifyTokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): VerifyTokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyTokenResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: VerifyTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyTokenResponse>, I>>(
    base?: I,
  ): VerifyTokenResponse {
    return VerifyTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyTokenResponse>, I>>(
    object: I,
  ): VerifyTokenResponse {
    const message = createBaseVerifyTokenResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

function createBaseTokenWithContextRequest(): TokenWithContextRequest {
  return { accessToken: '', refreshToken: '', resource: '', action: '' };
}

export const TokenWithContextRequest = {
  encode(
    message: TokenWithContextRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.resource !== '') {
      writer.uint32(26).string(message.resource);
    }
    if (message.action !== '') {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TokenWithContextRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenWithContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenWithContextRequest {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : '',
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : '',
      resource: isSet(object.resource)
        ? globalThis.String(object.resource)
        : '',
      action: isSet(object.action) ? globalThis.String(object.action) : '',
    };
  },

  toJSON(message: TokenWithContextRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    if (message.resource !== '') {
      obj.resource = message.resource;
    }
    if (message.action !== '') {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenWithContextRequest>, I>>(
    base?: I,
  ): TokenWithContextRequest {
    return TokenWithContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenWithContextRequest>, I>>(
    object: I,
  ): TokenWithContextRequest {
    const message = createBaseTokenWithContextRequest();
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    message.resource = object.resource ?? '';
    message.action = object.action ?? '';
    return message;
  },
};

function createBaseVerifyTokenWithContextResponse(): VerifyTokenWithContextResponse {
  return { success: false, errorMessage: '' };
}

export const VerifyTokenWithContextResponse = {
  encode(
    message: VerifyTokenWithContextResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): VerifyTokenWithContextResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyTokenWithContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyTokenWithContextResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: VerifyTokenWithContextResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyTokenWithContextResponse>, I>>(
    base?: I,
  ): VerifyTokenWithContextResponse {
    return VerifyTokenWithContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyTokenWithContextResponse>, I>>(
    object: I,
  ): VerifyTokenWithContextResponse {
    const message = createBaseVerifyTokenWithContextResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

function createBaseRenewTokenResponse(): RenewTokenResponse {
  return {
    success: false,
    errorMessage: '',
    accessToken: '',
    refreshToken: '',
  };
}

export const RenewTokenResponse = {
  encode(
    message: RenewTokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.accessToken !== '') {
      writer.uint32(26).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(34).string(message.refreshToken);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RenewTokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewTokenResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : '',
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : '',
    };
  },

  toJSON(message: RenewTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenewTokenResponse>, I>>(
    base?: I,
  ): RenewTokenResponse {
    return RenewTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenewTokenResponse>, I>>(
    object: I,
  ): RenewTokenResponse {
    const message = createBaseRenewTokenResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    return message;
  },
};

function createBaseDystroyTokenResponse(): DystroyTokenResponse {
  return { success: false, errorMessage: '' };
}

export const DystroyTokenResponse = {
  encode(
    message: DystroyTokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DystroyTokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDystroyTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DystroyTokenResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: DystroyTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DystroyTokenResponse>, I>>(
    base?: I,
  ): DystroyTokenResponse {
    return DystroyTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DystroyTokenResponse>, I>>(
    object: I,
  ): DystroyTokenResponse {
    const message = createBaseDystroyTokenResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

/** 인증을 위한 gRPC 서비스 정의 */
export type AdminAuthServiceService = typeof AdminAuthServiceService;
export const AdminAuthServiceService = {
  signIn: {
    path: '/auth.admin.AdminAuthService/SignIn',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignInRequest) =>
      Buffer.from(SignInRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SignInRequest.decode(value),
    responseSerialize: (value: SignInResponse) =>
      Buffer.from(SignInResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SignInResponse.decode(value),
  },
  verifyToken: {
    path: '/auth.admin.AdminAuthService/VerifyToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: VerifyTokenResponse) =>
      Buffer.from(VerifyTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyTokenResponse.decode(value),
  },
  verifyTokenWithContext: {
    path: '/auth.admin.AdminAuthService/VerifyTokenWithContext',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenWithContextRequest) =>
      Buffer.from(TokenWithContextRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      TokenWithContextRequest.decode(value),
    responseSerialize: (value: VerifyTokenWithContextResponse) =>
      Buffer.from(VerifyTokenWithContextResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      VerifyTokenWithContextResponse.decode(value),
  },
  renewToken: {
    path: '/auth.admin.AdminAuthService/RenewToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: RenewTokenResponse) =>
      Buffer.from(RenewTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RenewTokenResponse.decode(value),
  },
  destroyToken: {
    path: '/auth.admin.AdminAuthService/DestroyToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: DystroyTokenResponse) =>
      Buffer.from(DystroyTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DystroyTokenResponse.decode(value),
  },
} as const;

export interface AdminAuthServiceServer extends UntypedServiceImplementation {
  signIn: handleUnaryCall<SignInRequest, SignInResponse>;
  verifyToken: handleUnaryCall<TokenRequest, VerifyTokenResponse>;
  verifyTokenWithContext: handleUnaryCall<
    TokenWithContextRequest,
    VerifyTokenWithContextResponse
  >;
  renewToken: handleUnaryCall<TokenRequest, RenewTokenResponse>;
  destroyToken: handleUnaryCall<TokenRequest, DystroyTokenResponse>;
}

export interface AdminAuthServiceClient extends Client {
  signIn(
    request: SignInRequest,
    callback: (error: ServiceError | null, response: SignInResponse) => void,
  ): ClientUnaryCall;
  signIn(
    request: SignInRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignInResponse) => void,
  ): ClientUnaryCall;
  signIn(
    request: SignInRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignInResponse) => void,
  ): ClientUnaryCall;
  verifyToken(
    request: TokenRequest,
    callback: (
      error: ServiceError | null,
      response: VerifyTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  verifyToken(
    request: TokenRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: VerifyTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  verifyToken(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: VerifyTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  verifyTokenWithContext(
    request: TokenWithContextRequest,
    callback: (
      error: ServiceError | null,
      response: VerifyTokenWithContextResponse,
    ) => void,
  ): ClientUnaryCall;
  verifyTokenWithContext(
    request: TokenWithContextRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: VerifyTokenWithContextResponse,
    ) => void,
  ): ClientUnaryCall;
  verifyTokenWithContext(
    request: TokenWithContextRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: VerifyTokenWithContextResponse,
    ) => void,
  ): ClientUnaryCall;
  renewToken(
    request: TokenRequest,
    callback: (
      error: ServiceError | null,
      response: RenewTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  renewToken(
    request: TokenRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: RenewTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  renewToken(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: RenewTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  destroyToken(
    request: TokenRequest,
    callback: (
      error: ServiceError | null,
      response: DystroyTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  destroyToken(
    request: TokenRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: DystroyTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  destroyToken(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: DystroyTokenResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const AdminAuthServiceClient = makeGenericClientConstructor(
  AdminAuthServiceService,
  'auth.admin.AdminAuthService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): AdminAuthServiceClient;
  service: typeof AdminAuthServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
