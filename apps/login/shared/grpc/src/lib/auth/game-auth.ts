// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: game-auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'game';

export enum CustomTokenIssueType {
  /** EXIST - 기존 유저 */
  EXIST = 0,
  /** NEW - 신규 유저 등록 */
  NEW = 1,
  UNRECOGNIZED = -1,
}

export function customTokenIssueTypeFromJSON(
  object: any,
): CustomTokenIssueType {
  switch (object) {
    case 0:
    case 'EXIST':
      return CustomTokenIssueType.EXIST;
    case 1:
    case 'NEW':
      return CustomTokenIssueType.NEW;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return CustomTokenIssueType.UNRECOGNIZED;
  }
}

export function customTokenIssueTypeToJSON(
  object: CustomTokenIssueType,
): string {
  switch (object) {
    case CustomTokenIssueType.EXIST:
      return 'EXIST';
    case CustomTokenIssueType.NEW:
      return 'NEW';
    case CustomTokenIssueType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface TokenRequest {
  uid: string;
  /** 본인인증 서비스에서 발급한 토큰 */
  token: string;
}

export interface IssueTokenByIdentityResponse {
  success: boolean;
  errorMessage: string;
  /** 서버에서 발급한 토큰 */
  token: string;
}

export interface CreateCustomTokenRequest {
  provider: string;
  token: string;
}

export interface CreateCustomTokenResponse {
  success: boolean;
  errorMessage: string;
  customToken: string;
  issueType: CustomTokenIssueType;
}

export interface AccountSignWithCredentialRequest {
  userId: string;
  credential: string;
  provider: string;
}

export interface AccountSignRequest {
  uid: string;
  /** firebase access token */
  idToken: string;
}

export interface AccountSignOutRequest {
  uid: string;
}

export interface AccountSignResponse {
  success: boolean;
  errorMessage: string;
  authCode: string;
  accountId: string;
  firebaseUid: string;
  idToken: string;
}

export interface ResetPasswordRequest {
  /** 본인인증 후 서버에서 발급한 커스텀 토큰 */
  token: string;
  userId: string;
  accountId: string;
  password: string;
}

export interface DefaultResponse {
  success: boolean;
  errorMessage: string;
}

function createBaseTokenRequest(): TokenRequest {
  return { uid: '', token: '' };
}

export const TokenRequest = {
  encode(
    message: TokenRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uid !== '') {
      writer.uint32(10).string(message.uid);
    }
    if (message.token !== '') {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRequest {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
    };
  },

  toJSON(message: TokenRequest): unknown {
    const obj: any = {};
    if (message.uid !== '') {
      obj.uid = message.uid;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRequest>, I>>(
    base?: I,
  ): TokenRequest {
    return TokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRequest>, I>>(
    object: I,
  ): TokenRequest {
    const message = createBaseTokenRequest();
    message.uid = object.uid ?? '';
    message.token = object.token ?? '';
    return message;
  },
};

function createBaseIssueTokenByIdentityResponse(): IssueTokenByIdentityResponse {
  return { success: false, errorMessage: '', token: '' };
}

export const IssueTokenByIdentityResponse = {
  encode(
    message: IssueTokenByIdentityResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.token !== '') {
      writer.uint32(26).string(message.token);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IssueTokenByIdentityResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueTokenByIdentityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueTokenByIdentityResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
    };
  },

  toJSON(message: IssueTokenByIdentityResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IssueTokenByIdentityResponse>, I>>(
    base?: I,
  ): IssueTokenByIdentityResponse {
    return IssueTokenByIdentityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IssueTokenByIdentityResponse>, I>>(
    object: I,
  ): IssueTokenByIdentityResponse {
    const message = createBaseIssueTokenByIdentityResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.token = object.token ?? '';
    return message;
  },
};

function createBaseCreateCustomTokenRequest(): CreateCustomTokenRequest {
  return { provider: '', token: '' };
}

export const CreateCustomTokenRequest = {
  encode(
    message: CreateCustomTokenRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.provider !== '') {
      writer.uint32(10).string(message.provider);
    }
    if (message.token !== '') {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateCustomTokenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomTokenRequest {
    return {
      provider: isSet(object.provider)
        ? globalThis.String(object.provider)
        : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
    };
  },

  toJSON(message: CreateCustomTokenRequest): unknown {
    const obj: any = {};
    if (message.provider !== '') {
      obj.provider = message.provider;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomTokenRequest>, I>>(
    base?: I,
  ): CreateCustomTokenRequest {
    return CreateCustomTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomTokenRequest>, I>>(
    object: I,
  ): CreateCustomTokenRequest {
    const message = createBaseCreateCustomTokenRequest();
    message.provider = object.provider ?? '';
    message.token = object.token ?? '';
    return message;
  },
};

function createBaseCreateCustomTokenResponse(): CreateCustomTokenResponse {
  return { success: false, errorMessage: '', customToken: '', issueType: 0 };
}

export const CreateCustomTokenResponse = {
  encode(
    message: CreateCustomTokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.customToken !== '') {
      writer.uint32(26).string(message.customToken);
    }
    if (message.issueType !== 0) {
      writer.uint32(32).int32(message.issueType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateCustomTokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.issueType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomTokenResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      customToken: isSet(object.customToken)
        ? globalThis.String(object.customToken)
        : '',
      issueType: isSet(object.issueType)
        ? customTokenIssueTypeFromJSON(object.issueType)
        : 0,
    };
  },

  toJSON(message: CreateCustomTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.customToken !== '') {
      obj.customToken = message.customToken;
    }
    if (message.issueType !== 0) {
      obj.issueType = customTokenIssueTypeToJSON(message.issueType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomTokenResponse>, I>>(
    base?: I,
  ): CreateCustomTokenResponse {
    return CreateCustomTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomTokenResponse>, I>>(
    object: I,
  ): CreateCustomTokenResponse {
    const message = createBaseCreateCustomTokenResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.customToken = object.customToken ?? '';
    message.issueType = object.issueType ?? 0;
    return message;
  },
};

function createBaseAccountSignWithCredentialRequest(): AccountSignWithCredentialRequest {
  return { userId: '', credential: '', provider: '' };
}

export const AccountSignWithCredentialRequest = {
  encode(
    message: AccountSignWithCredentialRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.credential !== '') {
      writer.uint32(18).string(message.credential);
    }
    if (message.provider !== '') {
      writer.uint32(26).string(message.provider);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountSignWithCredentialRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignWithCredentialRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.credential = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provider = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignWithCredentialRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      credential: isSet(object.credential)
        ? globalThis.String(object.credential)
        : '',
      provider: isSet(object.provider)
        ? globalThis.String(object.provider)
        : '',
    };
  },

  toJSON(message: AccountSignWithCredentialRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.credential !== '') {
      obj.credential = message.credential;
    }
    if (message.provider !== '') {
      obj.provider = message.provider;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignWithCredentialRequest>, I>>(
    base?: I,
  ): AccountSignWithCredentialRequest {
    return AccountSignWithCredentialRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<AccountSignWithCredentialRequest>, I>,
  >(object: I): AccountSignWithCredentialRequest {
    const message = createBaseAccountSignWithCredentialRequest();
    message.userId = object.userId ?? '';
    message.credential = object.credential ?? '';
    message.provider = object.provider ?? '';
    return message;
  },
};

function createBaseAccountSignRequest(): AccountSignRequest {
  return { uid: '', idToken: '' };
}

export const AccountSignRequest = {
  encode(
    message: AccountSignRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uid !== '') {
      writer.uint32(10).string(message.uid);
    }
    if (message.idToken !== '') {
      writer.uint32(18).string(message.idToken);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountSignRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.idToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignRequest {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : '',
      idToken: isSet(object.idToken) ? globalThis.String(object.idToken) : '',
    };
  },

  toJSON(message: AccountSignRequest): unknown {
    const obj: any = {};
    if (message.uid !== '') {
      obj.uid = message.uid;
    }
    if (message.idToken !== '') {
      obj.idToken = message.idToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignRequest>, I>>(
    base?: I,
  ): AccountSignRequest {
    return AccountSignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSignRequest>, I>>(
    object: I,
  ): AccountSignRequest {
    const message = createBaseAccountSignRequest();
    message.uid = object.uid ?? '';
    message.idToken = object.idToken ?? '';
    return message;
  },
};

function createBaseAccountSignOutRequest(): AccountSignOutRequest {
  return { uid: '' };
}

export const AccountSignOutRequest = {
  encode(
    message: AccountSignOutRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uid !== '') {
      writer.uint32(10).string(message.uid);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountSignOutRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignOutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignOutRequest {
    return { uid: isSet(object.uid) ? globalThis.String(object.uid) : '' };
  },

  toJSON(message: AccountSignOutRequest): unknown {
    const obj: any = {};
    if (message.uid !== '') {
      obj.uid = message.uid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignOutRequest>, I>>(
    base?: I,
  ): AccountSignOutRequest {
    return AccountSignOutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSignOutRequest>, I>>(
    object: I,
  ): AccountSignOutRequest {
    const message = createBaseAccountSignOutRequest();
    message.uid = object.uid ?? '';
    return message;
  },
};

function createBaseAccountSignResponse(): AccountSignResponse {
  return {
    success: false,
    errorMessage: '',
    authCode: '',
    accountId: '',
    firebaseUid: '',
    idToken: '',
  };
}

export const AccountSignResponse = {
  encode(
    message: AccountSignResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.authCode !== '') {
      writer.uint32(26).string(message.authCode);
    }
    if (message.accountId !== '') {
      writer.uint32(34).string(message.accountId);
    }
    if (message.firebaseUid !== '') {
      writer.uint32(42).string(message.firebaseUid);
    }
    if (message.idToken !== '') {
      writer.uint32(50).string(message.idToken);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountSignResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.firebaseUid = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.idToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      authCode: isSet(object.authCode)
        ? globalThis.String(object.authCode)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      firebaseUid: isSet(object.firebaseUid)
        ? globalThis.String(object.firebaseUid)
        : '',
      idToken: isSet(object.idToken) ? globalThis.String(object.idToken) : '',
    };
  },

  toJSON(message: AccountSignResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.authCode !== '') {
      obj.authCode = message.authCode;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.firebaseUid !== '') {
      obj.firebaseUid = message.firebaseUid;
    }
    if (message.idToken !== '') {
      obj.idToken = message.idToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignResponse>, I>>(
    base?: I,
  ): AccountSignResponse {
    return AccountSignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSignResponse>, I>>(
    object: I,
  ): AccountSignResponse {
    const message = createBaseAccountSignResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.authCode = object.authCode ?? '';
    message.accountId = object.accountId ?? '';
    message.firebaseUid = object.firebaseUid ?? '';
    message.idToken = object.idToken ?? '';
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { token: '', userId: '', accountId: '', password: '' };
}

export const ResetPasswordRequest = {
  encode(
    message: ResetPasswordRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.token !== '') {
      writer.uint32(10).string(message.token);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.accountId !== '') {
      writer.uint32(26).string(message.accountId);
    }
    if (message.password !== '') {
      writer.uint32(34).string(message.password);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ResetPasswordRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      password: isSet(object.password)
        ? globalThis.String(object.password)
        : '',
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.token !== '') {
      obj.token = message.token;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.password !== '') {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(
    base?: I,
  ): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(
    object: I,
  ): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.token = object.token ?? '';
    message.userId = object.userId ?? '';
    message.accountId = object.accountId ?? '';
    message.password = object.password ?? '';
    return message;
  },
};

function createBaseDefaultResponse(): DefaultResponse {
  return { success: false, errorMessage: '' };
}

export const DefaultResponse = {
  encode(
    message: DefaultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: DefaultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    base?: I,
  ): DefaultResponse {
    return DefaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    object: I,
  ): DefaultResponse {
    const message = createBaseDefaultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  /** User */
  issueTokenByIdentity: {
    path: '/game.AuthService/IssueTokenByIdentity',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: IssueTokenByIdentityResponse) =>
      Buffer.from(IssueTokenByIdentityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      IssueTokenByIdentityResponse.decode(value),
  },
  /** 본인인증을 기준으로 발급한 커스텀 토큰을 검증 */
  verifyIdentityToken: {
    path: '/game.AuthService/VerifyIdentityToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 탈퇴시 Firebase 아이디 삭제 및 레디스 삭제 */
  deleteAccount: {
    path: '/game.AuthService/DeleteAccount',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** Account */
  createCustomToken: {
    path: '/game.AuthService/CreateCustomToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCustomTokenRequest) =>
      Buffer.from(CreateCustomTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CreateCustomTokenRequest.decode(value),
    responseSerialize: (value: CreateCustomTokenResponse) =>
      Buffer.from(CreateCustomTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CreateCustomTokenResponse.decode(value),
  },
  /** Firebase Auth ID 토큰 검증 / accessToken */
  verifyIdToken: {
    path: '/game.AuthService/VerifyIdToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountSignRequest) =>
      Buffer.from(AccountSignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountSignRequest.decode(value),
    responseSerialize: (value: AccountSignResponse) =>
      Buffer.from(AccountSignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountSignResponse.decode(value),
  },
  accountSignUp: {
    path: '/game.AuthService/AccountSignUp',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountSignWithCredentialRequest) =>
      Buffer.from(AccountSignWithCredentialRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      AccountSignWithCredentialRequest.decode(value),
    responseSerialize: (value: AccountSignResponse) =>
      Buffer.from(AccountSignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountSignResponse.decode(value),
  },
  accountSignInWithCredential: {
    path: '/game.AuthService/AccountSignInWithCredential',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountSignWithCredentialRequest) =>
      Buffer.from(AccountSignWithCredentialRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      AccountSignWithCredentialRequest.decode(value),
    responseSerialize: (value: AccountSignResponse) =>
      Buffer.from(AccountSignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountSignResponse.decode(value),
  },
  accountSignIn: {
    path: '/game.AuthService/AccountSignIn',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountSignRequest) =>
      Buffer.from(AccountSignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountSignRequest.decode(value),
    responseSerialize: (value: AccountSignResponse) =>
      Buffer.from(AccountSignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountSignResponse.decode(value),
  },
  accountSignOut: {
    path: '/game.AuthService/AccountSignOut',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountSignOutRequest) =>
      Buffer.from(AccountSignOutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountSignOutRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  signOutAll: {
    path: '/game.AuthService/SignOutAll',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  resetPassword: {
    path: '/game.AuthService/ResetPassword',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest) =>
      Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResetPasswordRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  /** User */
  issueTokenByIdentity: handleUnaryCall<
    TokenRequest,
    IssueTokenByIdentityResponse
  >;
  /** 본인인증을 기준으로 발급한 커스텀 토큰을 검증 */
  verifyIdentityToken: handleUnaryCall<TokenRequest, DefaultResponse>;
  /** 탈퇴시 Firebase 아이디 삭제 및 레디스 삭제 */
  deleteAccount: handleUnaryCall<TokenRequest, DefaultResponse>;
  /** Account */
  createCustomToken: handleUnaryCall<
    CreateCustomTokenRequest,
    CreateCustomTokenResponse
  >;
  /** Firebase Auth ID 토큰 검증 / accessToken */
  verifyIdToken: handleUnaryCall<AccountSignRequest, AccountSignResponse>;
  accountSignUp: handleUnaryCall<
    AccountSignWithCredentialRequest,
    AccountSignResponse
  >;
  accountSignInWithCredential: handleUnaryCall<
    AccountSignWithCredentialRequest,
    AccountSignResponse
  >;
  accountSignIn: handleUnaryCall<AccountSignRequest, AccountSignResponse>;
  accountSignOut: handleUnaryCall<AccountSignOutRequest, DefaultResponse>;
  signOutAll: handleUnaryCall<TokenRequest, DefaultResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, DefaultResponse>;
}

export interface AuthServiceClient extends Client {
  /** User */
  issueTokenByIdentity(
    request: TokenRequest,
    callback: (
      error: ServiceError | null,
      response: IssueTokenByIdentityResponse,
    ) => void,
  ): ClientUnaryCall;
  issueTokenByIdentity(
    request: TokenRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: IssueTokenByIdentityResponse,
    ) => void,
  ): ClientUnaryCall;
  issueTokenByIdentity(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: IssueTokenByIdentityResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 본인인증을 기준으로 발급한 커스텀 토큰을 검증 */
  verifyIdentityToken(
    request: TokenRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  verifyIdentityToken(
    request: TokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  verifyIdentityToken(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 탈퇴시 Firebase 아이디 삭제 및 레디스 삭제 */
  deleteAccount(
    request: TokenRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deleteAccount(
    request: TokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deleteAccount(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** Account */
  createCustomToken(
    request: CreateCustomTokenRequest,
    callback: (
      error: ServiceError | null,
      response: CreateCustomTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomToken(
    request: CreateCustomTokenRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CreateCustomTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomToken(
    request: CreateCustomTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CreateCustomTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  /** Firebase Auth ID 토큰 검증 / accessToken */
  verifyIdToken(
    request: AccountSignRequest,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  verifyIdToken(
    request: AccountSignRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  verifyIdToken(
    request: AccountSignRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignUp(
    request: AccountSignWithCredentialRequest,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignUp(
    request: AccountSignWithCredentialRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignUp(
    request: AccountSignWithCredentialRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignInWithCredential(
    request: AccountSignWithCredentialRequest,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignInWithCredential(
    request: AccountSignWithCredentialRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignInWithCredential(
    request: AccountSignWithCredentialRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignIn(
    request: AccountSignRequest,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignIn(
    request: AccountSignRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignIn(
    request: AccountSignRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignOut(
    request: AccountSignOutRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  accountSignOut(
    request: AccountSignOutRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  accountSignOut(
    request: AccountSignOutRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  signOutAll(
    request: TokenRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  signOutAll(
    request: TokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  signOutAll(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
}

export const AuthServiceClient = makeGenericClientConstructor(
  AuthServiceService,
  'game.AuthService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): AuthServiceClient;
  service: typeof AuthServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
