// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: web.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'web';

export enum CustomTokenIssueType {
  /** EXIST - 기존 유저 */
  EXIST = 0,
  /** NEW - 신규 유저 등록 */
  NEW = 1,
  UNRECOGNIZED = -1,
}

export function customTokenIssueTypeFromJSON(
  object: any,
): CustomTokenIssueType {
  switch (object) {
    case 0:
    case 'EXIST':
      return CustomTokenIssueType.EXIST;
    case 1:
    case 'NEW':
      return CustomTokenIssueType.NEW;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return CustomTokenIssueType.UNRECOGNIZED;
  }
}

export function customTokenIssueTypeToJSON(
  object: CustomTokenIssueType,
): string {
  switch (object) {
    case CustomTokenIssueType.EXIST:
      return 'EXIST';
    case CustomTokenIssueType.NEW:
      return 'NEW';
    case CustomTokenIssueType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface WebUser {
  name: string;
  telCode: string;
  tel: string;
}

export interface WebAccount {
  /** Firebase Auth UID */
  uid: string;
  accountId: string;
  accountType: string;
  /** 계정명 */
  accountName: string;
  /** 닉네임 */
  nickname: string;
}

export interface CreateCustomTokenRequest {
  provider: string;
  token: string;
}

export interface CreateCustomTokenResponse {
  success: boolean;
  errorMessage: string;
  customToken: string;
  issueType: CustomTokenIssueType;
}

export interface TokenRequest {
  uid: string;
  /** 본인인증 서비스에서 발급한 토큰 */
  token: string;
}

export interface TokenResponse {
  success: boolean;
  errorMessage: string;
  authCode: string;
  /** 갱신된 토큰 */
  renewedToken: string;
}

export interface AccountSignRequest {
  userId: string;
  credential: string;
  provider: string;
  pushToken: string;
}

export interface AccountSignResponse {
  success: boolean;
  errorMessage: string;
  token: string;
  user?: WebUser | undefined;
  account?: WebAccount | undefined;
}

export interface AccountSignOutRequest {
  uid: string;
}

export interface DefaultResponse {
  success: boolean;
  errorMessage: string;
}

function createBaseWebUser(): WebUser {
  return { name: '', telCode: '', tel: '' };
}

export const WebUser = {
  encode(
    message: WebUser,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== '') {
      writer.uint32(10).string(message.name);
    }
    if (message.telCode !== '') {
      writer.uint32(18).string(message.telCode);
    }
    if (message.tel !== '') {
      writer.uint32(26).string(message.tel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebUser {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.telCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebUser {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      telCode: isSet(object.telCode) ? globalThis.String(object.telCode) : '',
      tel: isSet(object.tel) ? globalThis.String(object.tel) : '',
    };
  },

  toJSON(message: WebUser): unknown {
    const obj: any = {};
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.telCode !== '') {
      obj.telCode = message.telCode;
    }
    if (message.tel !== '') {
      obj.tel = message.tel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebUser>, I>>(base?: I): WebUser {
    return WebUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebUser>, I>>(object: I): WebUser {
    const message = createBaseWebUser();
    message.name = object.name ?? '';
    message.telCode = object.telCode ?? '';
    message.tel = object.tel ?? '';
    return message;
  },
};

function createBaseWebAccount(): WebAccount {
  return {
    uid: '',
    accountId: '',
    accountType: '',
    accountName: '',
    nickname: '',
  };
}

export const WebAccount = {
  encode(
    message: WebAccount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uid !== '') {
      writer.uint32(10).string(message.uid);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.accountType !== '') {
      writer.uint32(26).string(message.accountType);
    }
    if (message.accountName !== '') {
      writer.uint32(34).string(message.accountName);
    }
    if (message.nickname !== '') {
      writer.uint32(42).string(message.nickname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebAccount {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accountName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nickname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebAccount {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      accountType: isSet(object.accountType)
        ? globalThis.String(object.accountType)
        : '',
      accountName: isSet(object.accountName)
        ? globalThis.String(object.accountName)
        : '',
      nickname: isSet(object.nickname)
        ? globalThis.String(object.nickname)
        : '',
    };
  },

  toJSON(message: WebAccount): unknown {
    const obj: any = {};
    if (message.uid !== '') {
      obj.uid = message.uid;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.accountType !== '') {
      obj.accountType = message.accountType;
    }
    if (message.accountName !== '') {
      obj.accountName = message.accountName;
    }
    if (message.nickname !== '') {
      obj.nickname = message.nickname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebAccount>, I>>(base?: I): WebAccount {
    return WebAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebAccount>, I>>(
    object: I,
  ): WebAccount {
    const message = createBaseWebAccount();
    message.uid = object.uid ?? '';
    message.accountId = object.accountId ?? '';
    message.accountType = object.accountType ?? '';
    message.accountName = object.accountName ?? '';
    message.nickname = object.nickname ?? '';
    return message;
  },
};

function createBaseCreateCustomTokenRequest(): CreateCustomTokenRequest {
  return { provider: '', token: '' };
}

export const CreateCustomTokenRequest = {
  encode(
    message: CreateCustomTokenRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.provider !== '') {
      writer.uint32(10).string(message.provider);
    }
    if (message.token !== '') {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateCustomTokenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomTokenRequest {
    return {
      provider: isSet(object.provider)
        ? globalThis.String(object.provider)
        : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
    };
  },

  toJSON(message: CreateCustomTokenRequest): unknown {
    const obj: any = {};
    if (message.provider !== '') {
      obj.provider = message.provider;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomTokenRequest>, I>>(
    base?: I,
  ): CreateCustomTokenRequest {
    return CreateCustomTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomTokenRequest>, I>>(
    object: I,
  ): CreateCustomTokenRequest {
    const message = createBaseCreateCustomTokenRequest();
    message.provider = object.provider ?? '';
    message.token = object.token ?? '';
    return message;
  },
};

function createBaseCreateCustomTokenResponse(): CreateCustomTokenResponse {
  return { success: false, errorMessage: '', customToken: '', issueType: 0 };
}

export const CreateCustomTokenResponse = {
  encode(
    message: CreateCustomTokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.customToken !== '') {
      writer.uint32(26).string(message.customToken);
    }
    if (message.issueType !== 0) {
      writer.uint32(32).int32(message.issueType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateCustomTokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.issueType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomTokenResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      customToken: isSet(object.customToken)
        ? globalThis.String(object.customToken)
        : '',
      issueType: isSet(object.issueType)
        ? customTokenIssueTypeFromJSON(object.issueType)
        : 0,
    };
  },

  toJSON(message: CreateCustomTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.customToken !== '') {
      obj.customToken = message.customToken;
    }
    if (message.issueType !== 0) {
      obj.issueType = customTokenIssueTypeToJSON(message.issueType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomTokenResponse>, I>>(
    base?: I,
  ): CreateCustomTokenResponse {
    return CreateCustomTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomTokenResponse>, I>>(
    object: I,
  ): CreateCustomTokenResponse {
    const message = createBaseCreateCustomTokenResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.customToken = object.customToken ?? '';
    message.issueType = object.issueType ?? 0;
    return message;
  },
};

function createBaseTokenRequest(): TokenRequest {
  return { uid: '', token: '' };
}

export const TokenRequest = {
  encode(
    message: TokenRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uid !== '') {
      writer.uint32(10).string(message.uid);
    }
    if (message.token !== '') {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRequest {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
    };
  },

  toJSON(message: TokenRequest): unknown {
    const obj: any = {};
    if (message.uid !== '') {
      obj.uid = message.uid;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRequest>, I>>(
    base?: I,
  ): TokenRequest {
    return TokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRequest>, I>>(
    object: I,
  ): TokenRequest {
    const message = createBaseTokenRequest();
    message.uid = object.uid ?? '';
    message.token = object.token ?? '';
    return message;
  },
};

function createBaseTokenResponse(): TokenResponse {
  return { success: false, errorMessage: '', authCode: '', renewedToken: '' };
}

export const TokenResponse = {
  encode(
    message: TokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.authCode !== '') {
      writer.uint32(26).string(message.authCode);
    }
    if (message.renewedToken !== '') {
      writer.uint32(34).string(message.renewedToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.renewedToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      authCode: isSet(object.authCode)
        ? globalThis.String(object.authCode)
        : '',
      renewedToken: isSet(object.renewedToken)
        ? globalThis.String(object.renewedToken)
        : '',
    };
  },

  toJSON(message: TokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.authCode !== '') {
      obj.authCode = message.authCode;
    }
    if (message.renewedToken !== '') {
      obj.renewedToken = message.renewedToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenResponse>, I>>(
    base?: I,
  ): TokenResponse {
    return TokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenResponse>, I>>(
    object: I,
  ): TokenResponse {
    const message = createBaseTokenResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.authCode = object.authCode ?? '';
    message.renewedToken = object.renewedToken ?? '';
    return message;
  },
};

function createBaseAccountSignRequest(): AccountSignRequest {
  return { userId: '', credential: '', provider: '', pushToken: '' };
}

export const AccountSignRequest = {
  encode(
    message: AccountSignRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.credential !== '') {
      writer.uint32(18).string(message.credential);
    }
    if (message.provider !== '') {
      writer.uint32(26).string(message.provider);
    }
    if (message.pushToken !== '') {
      writer.uint32(34).string(message.pushToken);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountSignRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.credential = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pushToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      credential: isSet(object.credential)
        ? globalThis.String(object.credential)
        : '',
      provider: isSet(object.provider)
        ? globalThis.String(object.provider)
        : '',
      pushToken: isSet(object.pushToken)
        ? globalThis.String(object.pushToken)
        : '',
    };
  },

  toJSON(message: AccountSignRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.credential !== '') {
      obj.credential = message.credential;
    }
    if (message.provider !== '') {
      obj.provider = message.provider;
    }
    if (message.pushToken !== '') {
      obj.pushToken = message.pushToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignRequest>, I>>(
    base?: I,
  ): AccountSignRequest {
    return AccountSignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSignRequest>, I>>(
    object: I,
  ): AccountSignRequest {
    const message = createBaseAccountSignRequest();
    message.userId = object.userId ?? '';
    message.credential = object.credential ?? '';
    message.provider = object.provider ?? '';
    message.pushToken = object.pushToken ?? '';
    return message;
  },
};

function createBaseAccountSignResponse(): AccountSignResponse {
  return {
    success: false,
    errorMessage: '',
    token: '',
    user: undefined,
    account: undefined,
  };
}

export const AccountSignResponse = {
  encode(
    message: AccountSignResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.token !== '') {
      writer.uint32(26).string(message.token);
    }
    if (message.user !== undefined) {
      WebUser.encode(message.user, writer.uint32(34).fork()).join();
    }
    if (message.account !== undefined) {
      WebAccount.encode(message.account, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountSignResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user = WebUser.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.account = WebAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
      user: isSet(object.user) ? WebUser.fromJSON(object.user) : undefined,
      account: isSet(object.account)
        ? WebAccount.fromJSON(object.account)
        : undefined,
    };
  },

  toJSON(message: AccountSignResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    if (message.user !== undefined) {
      obj.user = WebUser.toJSON(message.user);
    }
    if (message.account !== undefined) {
      obj.account = WebAccount.toJSON(message.account);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignResponse>, I>>(
    base?: I,
  ): AccountSignResponse {
    return AccountSignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSignResponse>, I>>(
    object: I,
  ): AccountSignResponse {
    const message = createBaseAccountSignResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.token = object.token ?? '';
    message.user =
      object.user !== undefined && object.user !== null
        ? WebUser.fromPartial(object.user)
        : undefined;
    message.account =
      object.account !== undefined && object.account !== null
        ? WebAccount.fromPartial(object.account)
        : undefined;
    return message;
  },
};

function createBaseAccountSignOutRequest(): AccountSignOutRequest {
  return { uid: '' };
}

export const AccountSignOutRequest = {
  encode(
    message: AccountSignOutRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uid !== '') {
      writer.uint32(10).string(message.uid);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountSignOutRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignOutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignOutRequest {
    return { uid: isSet(object.uid) ? globalThis.String(object.uid) : '' };
  },

  toJSON(message: AccountSignOutRequest): unknown {
    const obj: any = {};
    if (message.uid !== '') {
      obj.uid = message.uid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignOutRequest>, I>>(
    base?: I,
  ): AccountSignOutRequest {
    return AccountSignOutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSignOutRequest>, I>>(
    object: I,
  ): AccountSignOutRequest {
    const message = createBaseAccountSignOutRequest();
    message.uid = object.uid ?? '';
    return message;
  },
};

function createBaseDefaultResponse(): DefaultResponse {
  return { success: false, errorMessage: '' };
}

export const DefaultResponse = {
  encode(
    message: DefaultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: DefaultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    base?: I,
  ): DefaultResponse {
    return DefaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    object: I,
  ): DefaultResponse {
    const message = createBaseDefaultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

export type WebAuthServiceService = typeof WebAuthServiceService;
export const WebAuthServiceService = {
  /** Firebase Auth 커스텀 토큰 발급 */
  createCustomToken: {
    path: '/web.WebAuthService/CreateCustomToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCustomTokenRequest) =>
      Buffer.from(CreateCustomTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CreateCustomTokenRequest.decode(value),
    responseSerialize: (value: CreateCustomTokenResponse) =>
      Buffer.from(CreateCustomTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CreateCustomTokenResponse.decode(value),
  },
  /** Firebase Auth ID 토큰 검증 / accessToken */
  verifyIdToken: {
    path: '/web.WebAuthService/VerifyIdToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: TokenResponse) =>
      Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TokenResponse.decode(value),
  },
  accountSignIn: {
    path: '/web.WebAuthService/AccountSignIn',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountSignRequest) =>
      Buffer.from(AccountSignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountSignRequest.decode(value),
    responseSerialize: (value: AccountSignResponse) =>
      Buffer.from(AccountSignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountSignResponse.decode(value),
  },
  accountSignOut: {
    path: '/web.WebAuthService/AccountSignOut',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountSignOutRequest) =>
      Buffer.from(AccountSignOutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountSignOutRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
} as const;

export interface WebAuthServiceServer extends UntypedServiceImplementation {
  /** Firebase Auth 커스텀 토큰 발급 */
  createCustomToken: handleUnaryCall<
    CreateCustomTokenRequest,
    CreateCustomTokenResponse
  >;
  /** Firebase Auth ID 토큰 검증 / accessToken */
  verifyIdToken: handleUnaryCall<TokenRequest, TokenResponse>;
  accountSignIn: handleUnaryCall<AccountSignRequest, AccountSignResponse>;
  accountSignOut: handleUnaryCall<AccountSignOutRequest, DefaultResponse>;
}

export interface WebAuthServiceClient extends Client {
  /** Firebase Auth 커스텀 토큰 발급 */
  createCustomToken(
    request: CreateCustomTokenRequest,
    callback: (
      error: ServiceError | null,
      response: CreateCustomTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomToken(
    request: CreateCustomTokenRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CreateCustomTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomToken(
    request: CreateCustomTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CreateCustomTokenResponse,
    ) => void,
  ): ClientUnaryCall;
  /** Firebase Auth ID 토큰 검증 / accessToken */
  verifyIdToken(
    request: TokenRequest,
    callback: (error: ServiceError | null, response: TokenResponse) => void,
  ): ClientUnaryCall;
  verifyIdToken(
    request: TokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TokenResponse) => void,
  ): ClientUnaryCall;
  verifyIdToken(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TokenResponse) => void,
  ): ClientUnaryCall;
  accountSignIn(
    request: AccountSignRequest,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignIn(
    request: AccountSignRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignIn(
    request: AccountSignRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: AccountSignResponse,
    ) => void,
  ): ClientUnaryCall;
  accountSignOut(
    request: AccountSignOutRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  accountSignOut(
    request: AccountSignOutRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  accountSignOut(
    request: AccountSignOutRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
}

export const WebAuthServiceClient = makeGenericClientConstructor(
  WebAuthServiceService,
  'web.WebAuthService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): WebAuthServiceClient;
  service: typeof WebAuthServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
