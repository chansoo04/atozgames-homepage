// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: cs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'cs';

export enum QuestionState {
  QUESTION_STATE_NONE = 0,
  /** QUESTION_STATE_OPEN - 이슈생성 */
  QUESTION_STATE_OPEN = 1,
  /** QUESTION_STATE_NEW_REPLY - 새로운 답변 */
  QUESTION_STATE_NEW_REPLY = 2,
  /** QUESTION_STATE_CLOSED - 이슈종료 */
  QUESTION_STATE_CLOSED = 3,
  UNRECOGNIZED = -1,
}

export function questionStateFromJSON(object: any): QuestionState {
  switch (object) {
    case 0:
    case 'QUESTION_STATE_NONE':
      return QuestionState.QUESTION_STATE_NONE;
    case 1:
    case 'QUESTION_STATE_OPEN':
      return QuestionState.QUESTION_STATE_OPEN;
    case 2:
    case 'QUESTION_STATE_NEW_REPLY':
      return QuestionState.QUESTION_STATE_NEW_REPLY;
    case 3:
    case 'QUESTION_STATE_CLOSED':
      return QuestionState.QUESTION_STATE_CLOSED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return QuestionState.UNRECOGNIZED;
  }
}

export function questionStateToJSON(object: QuestionState): string {
  switch (object) {
    case QuestionState.QUESTION_STATE_NONE:
      return 'QUESTION_STATE_NONE';
    case QuestionState.QUESTION_STATE_OPEN:
      return 'QUESTION_STATE_OPEN';
    case QuestionState.QUESTION_STATE_NEW_REPLY:
      return 'QUESTION_STATE_NEW_REPLY';
    case QuestionState.QUESTION_STATE_CLOSED:
      return 'QUESTION_STATE_CLOSED';
    case QuestionState.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface CustomerQuestion {
  id: number;
  accountId: string;
  title: string;
  content: string;
  append: string;
  state: QuestionState;
  answerAt: string;
  replyAt: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  customerQuestionReply: CustomerQuestionReply[];
  replyCount: number;
}

export interface CustomerQuestionReply {
  id: number;
  questionId: number;
  accountId: string;
  adminId: string;
  reply: string;
  append: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CustomerQuestionRequest {
  csId: number;
  accountId: string;
  title: string;
  content: string;
  append: string;
}

export interface CustomerQuestionResponse {
  success: boolean;
  errorMessage: string;
  customerQuestion?: CustomerQuestion | undefined;
}

export interface CustomerQuestionsRequest {
  accountId: string;
  page: number;
  countPerPage: number;
}

export interface CustomerQuestionsResponse {
  success: boolean;
  errorMessage: string;
  customerQuestions: CustomerQuestion[];
}

export interface CustomerQuestionReplyRequest {
  replyId: number;
  csId: number;
  accountId: string;
  adminId: string;
  reply: string;
  append: string;
}

export interface CustomerQuestionReplyResponse {
  success: boolean;
  errorMessage: string;
  customerQuestionReply?: CustomerQuestionReply | undefined;
}

export interface CustomerQuestionRepliesResponse {
  success: boolean;
  errorMessage: string;
  customerQuestionReplies: CustomerQuestionReply[];
}

export interface DefaultResponse {
  success: boolean;
  errorMessage: string;
}

function createBaseCustomerQuestion(): CustomerQuestion {
  return {
    id: 0,
    accountId: '',
    title: '',
    content: '',
    append: '',
    state: 0,
    answerAt: '',
    replyAt: '',
    isActive: false,
    createdAt: '',
    updatedAt: '',
    customerQuestionReply: [],
    replyCount: 0,
  };
}

export const CustomerQuestion = {
  encode(
    message: CustomerQuestion,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.title !== '') {
      writer.uint32(26).string(message.title);
    }
    if (message.content !== '') {
      writer.uint32(34).string(message.content);
    }
    if (message.append !== '') {
      writer.uint32(42).string(message.append);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.answerAt !== '') {
      writer.uint32(58).string(message.answerAt);
    }
    if (message.replyAt !== '') {
      writer.uint32(66).string(message.replyAt);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(90).string(message.updatedAt);
    }
    for (const v of message.customerQuestionReply) {
      CustomerQuestionReply.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.replyCount !== 0) {
      writer.uint32(104).int32(message.replyCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomerQuestion {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.append = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.answerAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.replyAt = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.customerQuestionReply.push(
            CustomerQuestionReply.decode(reader, reader.uint32()),
          );
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.replyCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestion {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      title: isSet(object.title) ? globalThis.String(object.title) : '',
      content: isSet(object.content) ? globalThis.String(object.content) : '',
      append: isSet(object.append) ? globalThis.String(object.append) : '',
      state: isSet(object.state) ? questionStateFromJSON(object.state) : 0,
      answerAt: isSet(object.answerAt)
        ? globalThis.String(object.answerAt)
        : '',
      replyAt: isSet(object.replyAt) ? globalThis.String(object.replyAt) : '',
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      customerQuestionReply: globalThis.Array.isArray(
        object?.customerQuestionReply,
      )
        ? object.customerQuestionReply.map((e: any) =>
            CustomerQuestionReply.fromJSON(e),
          )
        : [],
      replyCount: isSet(object.replyCount)
        ? globalThis.Number(object.replyCount)
        : 0,
    };
  },

  toJSON(message: CustomerQuestion): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.title !== '') {
      obj.title = message.title;
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    if (message.append !== '') {
      obj.append = message.append;
    }
    if (message.state !== 0) {
      obj.state = questionStateToJSON(message.state);
    }
    if (message.answerAt !== '') {
      obj.answerAt = message.answerAt;
    }
    if (message.replyAt !== '') {
      obj.replyAt = message.replyAt;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.customerQuestionReply?.length) {
      obj.customerQuestionReply = message.customerQuestionReply.map(e =>
        CustomerQuestionReply.toJSON(e),
      );
    }
    if (message.replyCount !== 0) {
      obj.replyCount = Math.round(message.replyCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestion>, I>>(
    base?: I,
  ): CustomerQuestion {
    return CustomerQuestion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestion>, I>>(
    object: I,
  ): CustomerQuestion {
    const message = createBaseCustomerQuestion();
    message.id = object.id ?? 0;
    message.accountId = object.accountId ?? '';
    message.title = object.title ?? '';
    message.content = object.content ?? '';
    message.append = object.append ?? '';
    message.state = object.state ?? 0;
    message.answerAt = object.answerAt ?? '';
    message.replyAt = object.replyAt ?? '';
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.customerQuestionReply =
      object.customerQuestionReply?.map(e =>
        CustomerQuestionReply.fromPartial(e),
      ) || [];
    message.replyCount = object.replyCount ?? 0;
    return message;
  },
};

function createBaseCustomerQuestionReply(): CustomerQuestionReply {
  return {
    id: 0,
    questionId: 0,
    accountId: '',
    adminId: '',
    reply: '',
    append: '',
    isActive: false,
    createdAt: '',
    updatedAt: '',
  };
}

export const CustomerQuestionReply = {
  encode(
    message: CustomerQuestionReply,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.questionId !== 0) {
      writer.uint32(16).int32(message.questionId);
    }
    if (message.accountId !== '') {
      writer.uint32(26).string(message.accountId);
    }
    if (message.adminId !== '') {
      writer.uint32(34).string(message.adminId);
    }
    if (message.reply !== '') {
      writer.uint32(42).string(message.reply);
    }
    if (message.append !== '') {
      writer.uint32(50).string(message.append);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionReply {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.questionId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.adminId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reply = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.append = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionReply {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      questionId: isSet(object.questionId)
        ? globalThis.Number(object.questionId)
        : 0,
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      adminId: isSet(object.adminId) ? globalThis.String(object.adminId) : '',
      reply: isSet(object.reply) ? globalThis.String(object.reply) : '',
      append: isSet(object.append) ? globalThis.String(object.append) : '',
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
    };
  },

  toJSON(message: CustomerQuestionReply): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.questionId !== 0) {
      obj.questionId = Math.round(message.questionId);
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.adminId !== '') {
      obj.adminId = message.adminId;
    }
    if (message.reply !== '') {
      obj.reply = message.reply;
    }
    if (message.append !== '') {
      obj.append = message.append;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionReply>, I>>(
    base?: I,
  ): CustomerQuestionReply {
    return CustomerQuestionReply.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionReply>, I>>(
    object: I,
  ): CustomerQuestionReply {
    const message = createBaseCustomerQuestionReply();
    message.id = object.id ?? 0;
    message.questionId = object.questionId ?? 0;
    message.accountId = object.accountId ?? '';
    message.adminId = object.adminId ?? '';
    message.reply = object.reply ?? '';
    message.append = object.append ?? '';
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    return message;
  },
};

function createBaseCustomerQuestionRequest(): CustomerQuestionRequest {
  return { csId: 0, accountId: '', title: '', content: '', append: '' };
}

export const CustomerQuestionRequest = {
  encode(
    message: CustomerQuestionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.csId !== 0) {
      writer.uint32(8).int32(message.csId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.title !== '') {
      writer.uint32(26).string(message.title);
    }
    if (message.content !== '') {
      writer.uint32(34).string(message.content);
    }
    if (message.append !== '') {
      writer.uint32(42).string(message.append);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.csId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.append = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionRequest {
    return {
      csId: isSet(object.csId) ? globalThis.Number(object.csId) : 0,
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      title: isSet(object.title) ? globalThis.String(object.title) : '',
      content: isSet(object.content) ? globalThis.String(object.content) : '',
      append: isSet(object.append) ? globalThis.String(object.append) : '',
    };
  },

  toJSON(message: CustomerQuestionRequest): unknown {
    const obj: any = {};
    if (message.csId !== 0) {
      obj.csId = Math.round(message.csId);
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.title !== '') {
      obj.title = message.title;
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    if (message.append !== '') {
      obj.append = message.append;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionRequest>, I>>(
    base?: I,
  ): CustomerQuestionRequest {
    return CustomerQuestionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionRequest>, I>>(
    object: I,
  ): CustomerQuestionRequest {
    const message = createBaseCustomerQuestionRequest();
    message.csId = object.csId ?? 0;
    message.accountId = object.accountId ?? '';
    message.title = object.title ?? '';
    message.content = object.content ?? '';
    message.append = object.append ?? '';
    return message;
  },
};

function createBaseCustomerQuestionResponse(): CustomerQuestionResponse {
  return { success: false, errorMessage: '', customerQuestion: undefined };
}

export const CustomerQuestionResponse = {
  encode(
    message: CustomerQuestionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.customerQuestion !== undefined) {
      CustomerQuestion.encode(
        message.customerQuestion,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerQuestion = CustomerQuestion.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      customerQuestion: isSet(object.customerQuestion)
        ? CustomerQuestion.fromJSON(object.customerQuestion)
        : undefined,
    };
  },

  toJSON(message: CustomerQuestionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.customerQuestion !== undefined) {
      obj.customerQuestion = CustomerQuestion.toJSON(message.customerQuestion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionResponse>, I>>(
    base?: I,
  ): CustomerQuestionResponse {
    return CustomerQuestionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionResponse>, I>>(
    object: I,
  ): CustomerQuestionResponse {
    const message = createBaseCustomerQuestionResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.customerQuestion =
      object.customerQuestion !== undefined && object.customerQuestion !== null
        ? CustomerQuestion.fromPartial(object.customerQuestion)
        : undefined;
    return message;
  },
};

function createBaseCustomerQuestionsRequest(): CustomerQuestionsRequest {
  return { accountId: '', page: 0, countPerPage: 0 };
}

export const CustomerQuestionsRequest = {
  encode(
    message: CustomerQuestionsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.countPerPage !== 0) {
      writer.uint32(24).int32(message.countPerPage);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.countPerPage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionsRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      countPerPage: isSet(object.countPerPage)
        ? globalThis.Number(object.countPerPage)
        : 0,
    };
  },

  toJSON(message: CustomerQuestionsRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.countPerPage !== 0) {
      obj.countPerPage = Math.round(message.countPerPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionsRequest>, I>>(
    base?: I,
  ): CustomerQuestionsRequest {
    return CustomerQuestionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionsRequest>, I>>(
    object: I,
  ): CustomerQuestionsRequest {
    const message = createBaseCustomerQuestionsRequest();
    message.accountId = object.accountId ?? '';
    message.page = object.page ?? 0;
    message.countPerPage = object.countPerPage ?? 0;
    return message;
  },
};

function createBaseCustomerQuestionsResponse(): CustomerQuestionsResponse {
  return { success: false, errorMessage: '', customerQuestions: [] };
}

export const CustomerQuestionsResponse = {
  encode(
    message: CustomerQuestionsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.customerQuestions) {
      CustomerQuestion.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerQuestions.push(
            CustomerQuestion.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      customerQuestions: globalThis.Array.isArray(object?.customerQuestions)
        ? object.customerQuestions.map((e: any) => CustomerQuestion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomerQuestionsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.customerQuestions?.length) {
      obj.customerQuestions = message.customerQuestions.map(e =>
        CustomerQuestion.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionsResponse>, I>>(
    base?: I,
  ): CustomerQuestionsResponse {
    return CustomerQuestionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionsResponse>, I>>(
    object: I,
  ): CustomerQuestionsResponse {
    const message = createBaseCustomerQuestionsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.customerQuestions =
      object.customerQuestions?.map(e => CustomerQuestion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCustomerQuestionReplyRequest(): CustomerQuestionReplyRequest {
  return {
    replyId: 0,
    csId: 0,
    accountId: '',
    adminId: '',
    reply: '',
    append: '',
  };
}

export const CustomerQuestionReplyRequest = {
  encode(
    message: CustomerQuestionReplyRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.replyId !== 0) {
      writer.uint32(8).int32(message.replyId);
    }
    if (message.csId !== 0) {
      writer.uint32(16).int32(message.csId);
    }
    if (message.accountId !== '') {
      writer.uint32(26).string(message.accountId);
    }
    if (message.adminId !== '') {
      writer.uint32(34).string(message.adminId);
    }
    if (message.reply !== '') {
      writer.uint32(42).string(message.reply);
    }
    if (message.append !== '') {
      writer.uint32(50).string(message.append);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionReplyRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionReplyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.replyId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.csId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.adminId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reply = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.append = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionReplyRequest {
    return {
      replyId: isSet(object.replyId) ? globalThis.Number(object.replyId) : 0,
      csId: isSet(object.csId) ? globalThis.Number(object.csId) : 0,
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      adminId: isSet(object.adminId) ? globalThis.String(object.adminId) : '',
      reply: isSet(object.reply) ? globalThis.String(object.reply) : '',
      append: isSet(object.append) ? globalThis.String(object.append) : '',
    };
  },

  toJSON(message: CustomerQuestionReplyRequest): unknown {
    const obj: any = {};
    if (message.replyId !== 0) {
      obj.replyId = Math.round(message.replyId);
    }
    if (message.csId !== 0) {
      obj.csId = Math.round(message.csId);
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.adminId !== '') {
      obj.adminId = message.adminId;
    }
    if (message.reply !== '') {
      obj.reply = message.reply;
    }
    if (message.append !== '') {
      obj.append = message.append;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionReplyRequest>, I>>(
    base?: I,
  ): CustomerQuestionReplyRequest {
    return CustomerQuestionReplyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionReplyRequest>, I>>(
    object: I,
  ): CustomerQuestionReplyRequest {
    const message = createBaseCustomerQuestionReplyRequest();
    message.replyId = object.replyId ?? 0;
    message.csId = object.csId ?? 0;
    message.accountId = object.accountId ?? '';
    message.adminId = object.adminId ?? '';
    message.reply = object.reply ?? '';
    message.append = object.append ?? '';
    return message;
  },
};

function createBaseCustomerQuestionReplyResponse(): CustomerQuestionReplyResponse {
  return { success: false, errorMessage: '', customerQuestionReply: undefined };
}

export const CustomerQuestionReplyResponse = {
  encode(
    message: CustomerQuestionReplyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.customerQuestionReply !== undefined) {
      CustomerQuestionReply.encode(
        message.customerQuestionReply,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionReplyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionReplyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerQuestionReply = CustomerQuestionReply.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionReplyResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      customerQuestionReply: isSet(object.customerQuestionReply)
        ? CustomerQuestionReply.fromJSON(object.customerQuestionReply)
        : undefined,
    };
  },

  toJSON(message: CustomerQuestionReplyResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.customerQuestionReply !== undefined) {
      obj.customerQuestionReply = CustomerQuestionReply.toJSON(
        message.customerQuestionReply,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionReplyResponse>, I>>(
    base?: I,
  ): CustomerQuestionReplyResponse {
    return CustomerQuestionReplyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionReplyResponse>, I>>(
    object: I,
  ): CustomerQuestionReplyResponse {
    const message = createBaseCustomerQuestionReplyResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.customerQuestionReply =
      object.customerQuestionReply !== undefined &&
      object.customerQuestionReply !== null
        ? CustomerQuestionReply.fromPartial(object.customerQuestionReply)
        : undefined;
    return message;
  },
};

function createBaseCustomerQuestionRepliesResponse(): CustomerQuestionRepliesResponse {
  return { success: false, errorMessage: '', customerQuestionReplies: [] };
}

export const CustomerQuestionRepliesResponse = {
  encode(
    message: CustomerQuestionRepliesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.customerQuestionReplies) {
      CustomerQuestionReply.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CustomerQuestionRepliesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerQuestionRepliesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerQuestionReplies.push(
            CustomerQuestionReply.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerQuestionRepliesResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      customerQuestionReplies: globalThis.Array.isArray(
        object?.customerQuestionReplies,
      )
        ? object.customerQuestionReplies.map((e: any) =>
            CustomerQuestionReply.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: CustomerQuestionRepliesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.customerQuestionReplies?.length) {
      obj.customerQuestionReplies = message.customerQuestionReplies.map(e =>
        CustomerQuestionReply.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerQuestionRepliesResponse>, I>>(
    base?: I,
  ): CustomerQuestionRepliesResponse {
    return CustomerQuestionRepliesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerQuestionRepliesResponse>, I>>(
    object: I,
  ): CustomerQuestionRepliesResponse {
    const message = createBaseCustomerQuestionRepliesResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.customerQuestionReplies =
      object.customerQuestionReplies?.map(e =>
        CustomerQuestionReply.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseDefaultResponse(): DefaultResponse {
  return { success: false, errorMessage: '' };
}

export const DefaultResponse = {
  encode(
    message: DefaultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: DefaultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    base?: I,
  ): DefaultResponse {
    return DefaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    object: I,
  ): DefaultResponse {
    const message = createBaseDefaultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

export type CustomerServiceService = typeof CustomerServiceService;
export const CustomerServiceService = {
  createCustomerQuestion: {
    path: '/cs.CustomerService/CreateCustomerQuestion',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionRequest) =>
      Buffer.from(CustomerQuestionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionRequest.decode(value),
    responseSerialize: (value: CustomerQuestionResponse) =>
      Buffer.from(CustomerQuestionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CustomerQuestionResponse.decode(value),
  },
  updateCustomerQuestion: {
    path: '/cs.CustomerService/UpdateCustomerQuestion',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionRequest) =>
      Buffer.from(CustomerQuestionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionRequest.decode(value),
    responseSerialize: (value: CustomerQuestionResponse) =>
      Buffer.from(CustomerQuestionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CustomerQuestionResponse.decode(value),
  },
  deactivateCustomerQuestion: {
    path: '/cs.CustomerService/DeactivateCustomerQuestion',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionRequest) =>
      Buffer.from(CustomerQuestionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  getCustomerQuestion: {
    path: '/cs.CustomerService/GetCustomerQuestion',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionRequest) =>
      Buffer.from(CustomerQuestionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionRequest.decode(value),
    responseSerialize: (value: CustomerQuestionResponse) =>
      Buffer.from(CustomerQuestionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CustomerQuestionResponse.decode(value),
  },
  getCustomerQuestions: {
    path: '/cs.CustomerService/GetCustomerQuestions',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionsRequest) =>
      Buffer.from(CustomerQuestionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionsRequest.decode(value),
    responseSerialize: (value: CustomerQuestionsResponse) =>
      Buffer.from(CustomerQuestionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CustomerQuestionsResponse.decode(value),
  },
  createCustomerQuestionReply: {
    path: '/cs.CustomerService/CreateCustomerQuestionReply',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionReplyRequest) =>
      Buffer.from(CustomerQuestionReplyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionReplyRequest.decode(value),
    responseSerialize: (value: CustomerQuestionReplyResponse) =>
      Buffer.from(CustomerQuestionReplyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CustomerQuestionReplyResponse.decode(value),
  },
  updateCustomerQuestionReply: {
    path: '/cs.CustomerService/UpdateCustomerQuestionReply',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionReplyRequest) =>
      Buffer.from(CustomerQuestionReplyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionReplyRequest.decode(value),
    responseSerialize: (value: CustomerQuestionReplyResponse) =>
      Buffer.from(CustomerQuestionReplyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CustomerQuestionReplyResponse.decode(value),
  },
  deactivateCustomerQuestionReply: {
    path: '/cs.CustomerService/DeactivateCustomerQuestionReply',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionReplyRequest) =>
      Buffer.from(CustomerQuestionReplyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionReplyRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  getCustomerQuestionReply: {
    path: '/cs.CustomerService/GetCustomerQuestionReply',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CustomerQuestionReplyRequest) =>
      Buffer.from(CustomerQuestionReplyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CustomerQuestionReplyRequest.decode(value),
    responseSerialize: (value: CustomerQuestionRepliesResponse) =>
      Buffer.from(CustomerQuestionRepliesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CustomerQuestionRepliesResponse.decode(value),
  },
} as const;

export interface CustomerServiceServer extends UntypedServiceImplementation {
  createCustomerQuestion: handleUnaryCall<
    CustomerQuestionRequest,
    CustomerQuestionResponse
  >;
  updateCustomerQuestion: handleUnaryCall<
    CustomerQuestionRequest,
    CustomerQuestionResponse
  >;
  deactivateCustomerQuestion: handleUnaryCall<
    CustomerQuestionRequest,
    DefaultResponse
  >;
  getCustomerQuestion: handleUnaryCall<
    CustomerQuestionRequest,
    CustomerQuestionResponse
  >;
  getCustomerQuestions: handleUnaryCall<
    CustomerQuestionsRequest,
    CustomerQuestionsResponse
  >;
  createCustomerQuestionReply: handleUnaryCall<
    CustomerQuestionReplyRequest,
    CustomerQuestionReplyResponse
  >;
  updateCustomerQuestionReply: handleUnaryCall<
    CustomerQuestionReplyRequest,
    CustomerQuestionReplyResponse
  >;
  deactivateCustomerQuestionReply: handleUnaryCall<
    CustomerQuestionReplyRequest,
    DefaultResponse
  >;
  getCustomerQuestionReply: handleUnaryCall<
    CustomerQuestionReplyRequest,
    CustomerQuestionRepliesResponse
  >;
}

export interface CustomerServiceClient extends Client {
  createCustomerQuestion(
    request: CustomerQuestionRequest,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  updateCustomerQuestion(
    request: CustomerQuestionRequest,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  updateCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  updateCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  deactivateCustomerQuestion(
    request: CustomerQuestionRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactivateCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactivateCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  getCustomerQuestion(
    request: CustomerQuestionRequest,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  getCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  getCustomerQuestion(
    request: CustomerQuestionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionResponse,
    ) => void,
  ): ClientUnaryCall;
  getCustomerQuestions(
    request: CustomerQuestionsRequest,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getCustomerQuestions(
    request: CustomerQuestionsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getCustomerQuestions(
    request: CustomerQuestionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionsResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionReplyResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionReplyResponse,
    ) => void,
  ): ClientUnaryCall;
  createCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionReplyResponse,
    ) => void,
  ): ClientUnaryCall;
  updateCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionReplyResponse,
    ) => void,
  ): ClientUnaryCall;
  updateCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionReplyResponse,
    ) => void,
  ): ClientUnaryCall;
  updateCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionReplyResponse,
    ) => void,
  ): ClientUnaryCall;
  deactivateCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactivateCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactivateCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  getCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionRepliesResponse,
    ) => void,
  ): ClientUnaryCall;
  getCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionRepliesResponse,
    ) => void,
  ): ClientUnaryCall;
  getCustomerQuestionReply(
    request: CustomerQuestionReplyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CustomerQuestionRepliesResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const CustomerServiceClient = makeGenericClientConstructor(
  CustomerServiceService,
  'cs.CustomerService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): CustomerServiceClient;
  service: typeof CustomerServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
