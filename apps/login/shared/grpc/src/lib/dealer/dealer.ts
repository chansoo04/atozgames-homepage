// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v6.32.0
// source: dealer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'dealer';

export enum PhaseType {
  /** PHASE_NONE - 0 대응 */
  PHASE_NONE = 0,
  /** PHASE_GAME_START - 게임시작: 플레이어가 칩을 올리는 단계 */
  PHASE_GAME_START = 1,
  /** PHASE_PRE_FLOP - holdem */
  PHASE_PRE_FLOP = 2,
  PHASE_PRE_FLOP_BET = 3,
  /** PHASE_FLOP - 플랍: 커뮤니티 카드 3장이 공개되는 단계 */
  PHASE_FLOP = 4,
  PHASE_FLOP_BET = 5,
  /** PHASE_TURN - 턴: 커뮤니티 카드 1장이 공개되는 단계 */
  PHASE_TURN = 6,
  PHASE_TURN_BET = 7,
  /** PHASE_RIVER - 리버: 커뮤니티 카드 1장이 공개되는 단계 */
  PHASE_RIVER = 8,
  PHASE_RIVER_BET = 9,
  /** PHASE_NEW_DAY - badugi */
  PHASE_NEW_DAY = 10,
  PHASE_NEW_DAY_BET = 11,
  /** PHASE_MORNING - 아침: 첫 교환 단계 */
  PHASE_MORNING = 12,
  PHASE_MORNING_BET = 13,
  /** PHASE_AFTERNOON - 점심: 두번째 교환 단계 */
  PHASE_AFTERNOON = 14,
  PHASE_AFTERNOON_BET = 15,
  /** PHASE_EVENING - 저녁: 세번째 교환 단계 */
  PHASE_EVENING = 16,
  PHASE_EVENING_BET = 17,
  /** PHASE_SHOWDOWN - 플레이어가 카드를 공개하는 단계 */
  PHASE_SHOWDOWN = 18,
  /** PHASE_GAME_END - 팟 정산 완료: 게임이 끝나고 팟 정산이 완료된 단계 */
  PHASE_GAME_END = 19,
  UNRECOGNIZED = -1,
}

export function phaseTypeFromJSON(object: any): PhaseType {
  switch (object) {
    case 0:
    case 'PHASE_NONE':
      return PhaseType.PHASE_NONE;
    case 1:
    case 'PHASE_GAME_START':
      return PhaseType.PHASE_GAME_START;
    case 2:
    case 'PHASE_PRE_FLOP':
      return PhaseType.PHASE_PRE_FLOP;
    case 3:
    case 'PHASE_PRE_FLOP_BET':
      return PhaseType.PHASE_PRE_FLOP_BET;
    case 4:
    case 'PHASE_FLOP':
      return PhaseType.PHASE_FLOP;
    case 5:
    case 'PHASE_FLOP_BET':
      return PhaseType.PHASE_FLOP_BET;
    case 6:
    case 'PHASE_TURN':
      return PhaseType.PHASE_TURN;
    case 7:
    case 'PHASE_TURN_BET':
      return PhaseType.PHASE_TURN_BET;
    case 8:
    case 'PHASE_RIVER':
      return PhaseType.PHASE_RIVER;
    case 9:
    case 'PHASE_RIVER_BET':
      return PhaseType.PHASE_RIVER_BET;
    case 10:
    case 'PHASE_NEW_DAY':
      return PhaseType.PHASE_NEW_DAY;
    case 11:
    case 'PHASE_NEW_DAY_BET':
      return PhaseType.PHASE_NEW_DAY_BET;
    case 12:
    case 'PHASE_MORNING':
      return PhaseType.PHASE_MORNING;
    case 13:
    case 'PHASE_MORNING_BET':
      return PhaseType.PHASE_MORNING_BET;
    case 14:
    case 'PHASE_AFTERNOON':
      return PhaseType.PHASE_AFTERNOON;
    case 15:
    case 'PHASE_AFTERNOON_BET':
      return PhaseType.PHASE_AFTERNOON_BET;
    case 16:
    case 'PHASE_EVENING':
      return PhaseType.PHASE_EVENING;
    case 17:
    case 'PHASE_EVENING_BET':
      return PhaseType.PHASE_EVENING_BET;
    case 18:
    case 'PHASE_SHOWDOWN':
      return PhaseType.PHASE_SHOWDOWN;
    case 19:
    case 'PHASE_GAME_END':
      return PhaseType.PHASE_GAME_END;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return PhaseType.UNRECOGNIZED;
  }
}

export function phaseTypeToJSON(object: PhaseType): string {
  switch (object) {
    case PhaseType.PHASE_NONE:
      return 'PHASE_NONE';
    case PhaseType.PHASE_GAME_START:
      return 'PHASE_GAME_START';
    case PhaseType.PHASE_PRE_FLOP:
      return 'PHASE_PRE_FLOP';
    case PhaseType.PHASE_PRE_FLOP_BET:
      return 'PHASE_PRE_FLOP_BET';
    case PhaseType.PHASE_FLOP:
      return 'PHASE_FLOP';
    case PhaseType.PHASE_FLOP_BET:
      return 'PHASE_FLOP_BET';
    case PhaseType.PHASE_TURN:
      return 'PHASE_TURN';
    case PhaseType.PHASE_TURN_BET:
      return 'PHASE_TURN_BET';
    case PhaseType.PHASE_RIVER:
      return 'PHASE_RIVER';
    case PhaseType.PHASE_RIVER_BET:
      return 'PHASE_RIVER_BET';
    case PhaseType.PHASE_NEW_DAY:
      return 'PHASE_NEW_DAY';
    case PhaseType.PHASE_NEW_DAY_BET:
      return 'PHASE_NEW_DAY_BET';
    case PhaseType.PHASE_MORNING:
      return 'PHASE_MORNING';
    case PhaseType.PHASE_MORNING_BET:
      return 'PHASE_MORNING_BET';
    case PhaseType.PHASE_AFTERNOON:
      return 'PHASE_AFTERNOON';
    case PhaseType.PHASE_AFTERNOON_BET:
      return 'PHASE_AFTERNOON_BET';
    case PhaseType.PHASE_EVENING:
      return 'PHASE_EVENING';
    case PhaseType.PHASE_EVENING_BET:
      return 'PHASE_EVENING_BET';
    case PhaseType.PHASE_SHOWDOWN:
      return 'PHASE_SHOWDOWN';
    case PhaseType.PHASE_GAME_END:
      return 'PHASE_GAME_END';
    case PhaseType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum BetType {
  /** BET_FOLD - 0 대응 | 폴드: 게임을 포기합니다 */
  BET_FOLD = 0,
  /** BET_MIN - 삥: ante, 게임방의 최소금액 */
  BET_MIN = 1,
  /** BET_DOUBLE - 따당: callBet * 2 */
  BET_DOUBLE = 2,
  /** BET_CALL - 콜: (이번 페이즈에서 상대방의 최고 배팅액 - 이번 페이즈에서 내가 낸 금액)만큼 내고 내 차례를 넘깁니다 */
  BET_CALL = 3,
  /** BET_CHECK - 체크: 금액없음 */
  BET_CHECK = 4,
  /** BET_QUARTER - 쿼터: {콜값 + (팟 + 콜값)/4}의 배팅액을 내고 내 차례를 넘깁니다 */
  BET_QUARTER = 5,
  /** BET_HALF - 하프: {콜값 + (팟 + 콜값)/2}의 배팅액을 내고 내 차례를 넘깁니다 */
  BET_HALF = 6,
  /** BET_ALL_IN - 올인: 플레이어의 가진 모든칩 */
  BET_ALL_IN = 7,
  /** BET_MAX - 맥스: 배팅 상한선 - 이번게임에 배팅한 금액 */
  BET_MAX = 8,
  /** BET_DEPOSIT - 참가비: 게임에 배팅합니다 */
  BET_DEPOSIT = 9,
  UNRECOGNIZED = -1,
}

export function betTypeFromJSON(object: any): BetType {
  switch (object) {
    case 0:
    case 'BET_FOLD':
      return BetType.BET_FOLD;
    case 1:
    case 'BET_MIN':
      return BetType.BET_MIN;
    case 2:
    case 'BET_DOUBLE':
      return BetType.BET_DOUBLE;
    case 3:
    case 'BET_CALL':
      return BetType.BET_CALL;
    case 4:
    case 'BET_CHECK':
      return BetType.BET_CHECK;
    case 5:
    case 'BET_QUARTER':
      return BetType.BET_QUARTER;
    case 6:
    case 'BET_HALF':
      return BetType.BET_HALF;
    case 7:
    case 'BET_ALL_IN':
      return BetType.BET_ALL_IN;
    case 8:
    case 'BET_MAX':
      return BetType.BET_MAX;
    case 9:
    case 'BET_DEPOSIT':
      return BetType.BET_DEPOSIT;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return BetType.UNRECOGNIZED;
  }
}

export function betTypeToJSON(object: BetType): string {
  switch (object) {
    case BetType.BET_FOLD:
      return 'BET_FOLD';
    case BetType.BET_MIN:
      return 'BET_MIN';
    case BetType.BET_DOUBLE:
      return 'BET_DOUBLE';
    case BetType.BET_CALL:
      return 'BET_CALL';
    case BetType.BET_CHECK:
      return 'BET_CHECK';
    case BetType.BET_QUARTER:
      return 'BET_QUARTER';
    case BetType.BET_HALF:
      return 'BET_HALF';
    case BetType.BET_ALL_IN:
      return 'BET_ALL_IN';
    case BetType.BET_MAX:
      return 'BET_MAX';
    case BetType.BET_DEPOSIT:
      return 'BET_DEPOSIT';
    case BetType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface StartGameRequest {
  gameId: string;
  channel: string;
  roomId: string;
  players: string[];
  ante: number;
}

export interface StartGameResponse {
  success: boolean;
  errorMessage: string;
  dealerId: string;
  players: string[];
}

export interface DrawRequest {
  dealerId: string;
  accountId: string;
  phase: PhaseType;
  count: number;
}

export interface DrawResponse {
  success: boolean;
  errorMessage: string;
  hand: string[];
  community: string[];
}

export interface BurnRequest {
  dealerId: string;
  accountId: string;
  phase: PhaseType;
  card: string[];
}

export interface BurnResponse {
  success: boolean;
  errorMessage: string;
  hand: string[];
}

export interface BetRequest {
  dealerId: string;
  accountId: string;
  /** bigint */
  amount: string;
  phase: PhaseType;
  betType: BetType;
}

export interface BetResponse {
  success: boolean;
  errorMessage: string;
  balance: string;
  potAmount: string;
}

export interface ShowdownResponse {
  success: boolean;
  errorMessage: string;
  community: string[];
}

export interface ResultRequest {
  dealerId: string;
  accountId: string;
}

export interface Distribute {
  accountId: string;
  /** WIN, DRAW, DISTRIBUTE */
  type: string;
  lake: number;
  /** bigint */
  lakeAmount: string;
  distributeAmount: string;
  balanceAmount: string;
  /** true: limit over, false: normal distribute */
  isLimitOver: boolean;
}

export interface Jackpot {
  accountId: string;
  type: string;
  /** bigint */
  amount: string;
}

export interface ResultResponse {
  success: boolean;
  errorMessage: string;
  result: Distribute[];
  jackpot: Jackpot[];
}

function createBaseStartGameRequest(): StartGameRequest {
  return { gameId: '', channel: '', roomId: '', players: [], ante: 0 };
}

export const StartGameRequest = {
  encode(
    message: StartGameRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.gameId !== '') {
      writer.uint32(10).string(message.gameId);
    }
    if (message.channel !== '') {
      writer.uint32(18).string(message.channel);
    }
    if (message.roomId !== '') {
      writer.uint32(26).string(message.roomId);
    }
    for (const v of message.players) {
      writer.uint32(34).string(v!);
    }
    if (message.ante !== 0) {
      writer.uint32(40).int32(message.ante);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartGameRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartGameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gameId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.roomId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.players.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ante = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartGameRequest {
    return {
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : '',
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : '',
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => globalThis.String(e))
        : [],
      ante: isSet(object.ante) ? globalThis.Number(object.ante) : 0,
    };
  },

  toJSON(message: StartGameRequest): unknown {
    const obj: any = {};
    if (message.gameId !== '') {
      obj.gameId = message.gameId;
    }
    if (message.channel !== '') {
      obj.channel = message.channel;
    }
    if (message.roomId !== '') {
      obj.roomId = message.roomId;
    }
    if (message.players?.length) {
      obj.players = message.players;
    }
    if (message.ante !== 0) {
      obj.ante = Math.round(message.ante);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartGameRequest>, I>>(
    base?: I,
  ): StartGameRequest {
    return StartGameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartGameRequest>, I>>(
    object: I,
  ): StartGameRequest {
    const message = createBaseStartGameRequest();
    message.gameId = object.gameId ?? '';
    message.channel = object.channel ?? '';
    message.roomId = object.roomId ?? '';
    message.players = object.players?.map(e => e) || [];
    message.ante = object.ante ?? 0;
    return message;
  },
};

function createBaseStartGameResponse(): StartGameResponse {
  return { success: false, errorMessage: '', dealerId: '', players: [] };
}

export const StartGameResponse = {
  encode(
    message: StartGameResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.dealerId !== '') {
      writer.uint32(26).string(message.dealerId);
    }
    for (const v of message.players) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartGameResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartGameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.players.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartGameResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StartGameResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.players?.length) {
      obj.players = message.players;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartGameResponse>, I>>(
    base?: I,
  ): StartGameResponse {
    return StartGameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartGameResponse>, I>>(
    object: I,
  ): StartGameResponse {
    const message = createBaseStartGameResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.dealerId = object.dealerId ?? '';
    message.players = object.players?.map(e => e) || [];
    return message;
  },
};

function createBaseDrawRequest(): DrawRequest {
  return { dealerId: '', accountId: '', phase: 0, count: 0 };
}

export const DrawRequest = {
  encode(
    message: DrawRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.phase !== 0) {
      writer.uint32(24).int32(message.phase);
    }
    if (message.count !== 0) {
      writer.uint32(32).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrawRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrawRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrawRequest {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      phase: isSet(object.phase) ? phaseTypeFromJSON(object.phase) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: DrawRequest): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.phase !== 0) {
      obj.phase = phaseTypeToJSON(message.phase);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrawRequest>, I>>(base?: I): DrawRequest {
    return DrawRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrawRequest>, I>>(
    object: I,
  ): DrawRequest {
    const message = createBaseDrawRequest();
    message.dealerId = object.dealerId ?? '';
    message.accountId = object.accountId ?? '';
    message.phase = object.phase ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseDrawResponse(): DrawResponse {
  return { success: false, errorMessage: '', hand: [], community: [] };
}

export const DrawResponse = {
  encode(
    message: DrawResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.hand) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.community) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrawResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hand.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.community.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrawResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      hand: globalThis.Array.isArray(object?.hand)
        ? object.hand.map((e: any) => globalThis.String(e))
        : [],
      community: globalThis.Array.isArray(object?.community)
        ? object.community.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DrawResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.hand?.length) {
      obj.hand = message.hand;
    }
    if (message.community?.length) {
      obj.community = message.community;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrawResponse>, I>>(
    base?: I,
  ): DrawResponse {
    return DrawResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrawResponse>, I>>(
    object: I,
  ): DrawResponse {
    const message = createBaseDrawResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.hand = object.hand?.map(e => e) || [];
    message.community = object.community?.map(e => e) || [];
    return message;
  },
};

function createBaseBurnRequest(): BurnRequest {
  return { dealerId: '', accountId: '', phase: 0, card: [] };
}

export const BurnRequest = {
  encode(
    message: BurnRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.phase !== 0) {
      writer.uint32(24).int32(message.phase);
    }
    for (const v of message.card) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BurnRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.card.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BurnRequest {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      phase: isSet(object.phase) ? phaseTypeFromJSON(object.phase) : 0,
      card: globalThis.Array.isArray(object?.card)
        ? object.card.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BurnRequest): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.phase !== 0) {
      obj.phase = phaseTypeToJSON(message.phase);
    }
    if (message.card?.length) {
      obj.card = message.card;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BurnRequest>, I>>(base?: I): BurnRequest {
    return BurnRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BurnRequest>, I>>(
    object: I,
  ): BurnRequest {
    const message = createBaseBurnRequest();
    message.dealerId = object.dealerId ?? '';
    message.accountId = object.accountId ?? '';
    message.phase = object.phase ?? 0;
    message.card = object.card?.map(e => e) || [];
    return message;
  },
};

function createBaseBurnResponse(): BurnResponse {
  return { success: false, errorMessage: '', hand: [] };
}

export const BurnResponse = {
  encode(
    message: BurnResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.hand) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BurnResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hand.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BurnResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      hand: globalThis.Array.isArray(object?.hand)
        ? object.hand.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BurnResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.hand?.length) {
      obj.hand = message.hand;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BurnResponse>, I>>(
    base?: I,
  ): BurnResponse {
    return BurnResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BurnResponse>, I>>(
    object: I,
  ): BurnResponse {
    const message = createBaseBurnResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.hand = object.hand?.map(e => e) || [];
    return message;
  },
};

function createBaseBetRequest(): BetRequest {
  return { dealerId: '', accountId: '', amount: '', phase: 0, betType: 0 };
}

export const BetRequest = {
  encode(
    message: BetRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.amount !== '') {
      writer.uint32(26).string(message.amount);
    }
    if (message.phase !== 0) {
      writer.uint32(32).int32(message.phase);
    }
    if (message.betType !== 0) {
      writer.uint32(40).int32(message.betType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BetRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.betType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BetRequest {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
      phase: isSet(object.phase) ? phaseTypeFromJSON(object.phase) : 0,
      betType: isSet(object.betType) ? betTypeFromJSON(object.betType) : 0,
    };
  },

  toJSON(message: BetRequest): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    if (message.phase !== 0) {
      obj.phase = phaseTypeToJSON(message.phase);
    }
    if (message.betType !== 0) {
      obj.betType = betTypeToJSON(message.betType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BetRequest>, I>>(base?: I): BetRequest {
    return BetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BetRequest>, I>>(
    object: I,
  ): BetRequest {
    const message = createBaseBetRequest();
    message.dealerId = object.dealerId ?? '';
    message.accountId = object.accountId ?? '';
    message.amount = object.amount ?? '';
    message.phase = object.phase ?? 0;
    message.betType = object.betType ?? 0;
    return message;
  },
};

function createBaseBetResponse(): BetResponse {
  return { success: false, errorMessage: '', balance: '', potAmount: '' };
}

export const BetResponse = {
  encode(
    message: BetResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.balance !== '') {
      writer.uint32(26).string(message.balance);
    }
    if (message.potAmount !== '') {
      writer.uint32(34).string(message.potAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BetResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.balance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.potAmount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BetResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      balance: isSet(object.balance) ? globalThis.String(object.balance) : '',
      potAmount: isSet(object.potAmount)
        ? globalThis.String(object.potAmount)
        : '',
    };
  },

  toJSON(message: BetResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.balance !== '') {
      obj.balance = message.balance;
    }
    if (message.potAmount !== '') {
      obj.potAmount = message.potAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BetResponse>, I>>(base?: I): BetResponse {
    return BetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BetResponse>, I>>(
    object: I,
  ): BetResponse {
    const message = createBaseBetResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.balance = object.balance ?? '';
    message.potAmount = object.potAmount ?? '';
    return message;
  },
};

function createBaseShowdownResponse(): ShowdownResponse {
  return { success: false, errorMessage: '', community: [] };
}

export const ShowdownResponse = {
  encode(
    message: ShowdownResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.community) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowdownResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowdownResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.community.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowdownResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      community: globalThis.Array.isArray(object?.community)
        ? object.community.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ShowdownResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.community?.length) {
      obj.community = message.community;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShowdownResponse>, I>>(
    base?: I,
  ): ShowdownResponse {
    return ShowdownResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShowdownResponse>, I>>(
    object: I,
  ): ShowdownResponse {
    const message = createBaseShowdownResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.community = object.community?.map(e => e) || [];
    return message;
  },
};

function createBaseResultRequest(): ResultRequest {
  return { dealerId: '', accountId: '' };
}

export const ResultRequest = {
  encode(
    message: ResultRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultRequest {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
    };
  },

  toJSON(message: ResultRequest): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultRequest>, I>>(
    base?: I,
  ): ResultRequest {
    return ResultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultRequest>, I>>(
    object: I,
  ): ResultRequest {
    const message = createBaseResultRequest();
    message.dealerId = object.dealerId ?? '';
    message.accountId = object.accountId ?? '';
    return message;
  },
};

function createBaseDistribute(): Distribute {
  return {
    accountId: '',
    type: '',
    lake: 0,
    lakeAmount: '',
    distributeAmount: '',
    balanceAmount: '',
    isLimitOver: false,
  };
}

export const Distribute = {
  encode(
    message: Distribute,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.type !== '') {
      writer.uint32(18).string(message.type);
    }
    if (message.lake !== 0) {
      writer.uint32(29).float(message.lake);
    }
    if (message.lakeAmount !== '') {
      writer.uint32(34).string(message.lakeAmount);
    }
    if (message.distributeAmount !== '') {
      writer.uint32(42).string(message.distributeAmount);
    }
    if (message.balanceAmount !== '') {
      writer.uint32(50).string(message.balanceAmount);
    }
    if (message.isLimitOver !== false) {
      writer.uint32(56).bool(message.isLimitOver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Distribute {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.lake = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lakeAmount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.distributeAmount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.balanceAmount = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isLimitOver = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Distribute {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      lake: isSet(object.lake) ? globalThis.Number(object.lake) : 0,
      lakeAmount: isSet(object.lakeAmount)
        ? globalThis.String(object.lakeAmount)
        : '',
      distributeAmount: isSet(object.distributeAmount)
        ? globalThis.String(object.distributeAmount)
        : '',
      balanceAmount: isSet(object.balanceAmount)
        ? globalThis.String(object.balanceAmount)
        : '',
      isLimitOver: isSet(object.isLimitOver)
        ? globalThis.Boolean(object.isLimitOver)
        : false,
    };
  },

  toJSON(message: Distribute): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.lake !== 0) {
      obj.lake = message.lake;
    }
    if (message.lakeAmount !== '') {
      obj.lakeAmount = message.lakeAmount;
    }
    if (message.distributeAmount !== '') {
      obj.distributeAmount = message.distributeAmount;
    }
    if (message.balanceAmount !== '') {
      obj.balanceAmount = message.balanceAmount;
    }
    if (message.isLimitOver !== false) {
      obj.isLimitOver = message.isLimitOver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Distribute>, I>>(base?: I): Distribute {
    return Distribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Distribute>, I>>(
    object: I,
  ): Distribute {
    const message = createBaseDistribute();
    message.accountId = object.accountId ?? '';
    message.type = object.type ?? '';
    message.lake = object.lake ?? 0;
    message.lakeAmount = object.lakeAmount ?? '';
    message.distributeAmount = object.distributeAmount ?? '';
    message.balanceAmount = object.balanceAmount ?? '';
    message.isLimitOver = object.isLimitOver ?? false;
    return message;
  },
};

function createBaseJackpot(): Jackpot {
  return { accountId: '', type: '', amount: '' };
}

export const Jackpot = {
  encode(
    message: Jackpot,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.type !== '') {
      writer.uint32(18).string(message.type);
    }
    if (message.amount !== '') {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Jackpot {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJackpot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Jackpot {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
    };
  },

  toJSON(message: Jackpot): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Jackpot>, I>>(base?: I): Jackpot {
    return Jackpot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Jackpot>, I>>(object: I): Jackpot {
    const message = createBaseJackpot();
    message.accountId = object.accountId ?? '';
    message.type = object.type ?? '';
    message.amount = object.amount ?? '';
    return message;
  },
};

function createBaseResultResponse(): ResultResponse {
  return { success: false, errorMessage: '', result: [], jackpot: [] };
}

export const ResultResponse = {
  encode(
    message: ResultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.result) {
      Distribute.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.jackpot) {
      Jackpot.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.result.push(Distribute.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jackpot.push(Jackpot.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => Distribute.fromJSON(e))
        : [],
      jackpot: globalThis.Array.isArray(object?.jackpot)
        ? object.jackpot.map((e: any) => Jackpot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.result?.length) {
      obj.result = message.result.map(e => Distribute.toJSON(e));
    }
    if (message.jackpot?.length) {
      obj.jackpot = message.jackpot.map(e => Jackpot.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultResponse>, I>>(
    base?: I,
  ): ResultResponse {
    return ResultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultResponse>, I>>(
    object: I,
  ): ResultResponse {
    const message = createBaseResultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.result = object.result?.map(e => Distribute.fromPartial(e)) || [];
    message.jackpot = object.jackpot?.map(e => Jackpot.fromPartial(e)) || [];
    return message;
  },
};

export type DealerServiceService = typeof DealerServiceService;
export const DealerServiceService = {
  startGame: {
    path: '/dealer.DealerService/StartGame',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StartGameRequest) =>
      Buffer.from(StartGameRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StartGameRequest.decode(value),
    responseSerialize: (value: StartGameResponse) =>
      Buffer.from(StartGameResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StartGameResponse.decode(value),
  },
  draw: {
    path: '/dealer.DealerService/Draw',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DrawRequest) =>
      Buffer.from(DrawRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DrawRequest.decode(value),
    responseSerialize: (value: DrawResponse) =>
      Buffer.from(DrawResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DrawResponse.decode(value),
  },
  burn: {
    path: '/dealer.DealerService/Burn',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BurnRequest) =>
      Buffer.from(BurnRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BurnRequest.decode(value),
    responseSerialize: (value: BurnResponse) =>
      Buffer.from(BurnResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BurnResponse.decode(value),
  },
  deposit: {
    path: '/dealer.DealerService/Deposit',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BetRequest) =>
      Buffer.from(BetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BetRequest.decode(value),
    responseSerialize: (value: BetResponse) =>
      Buffer.from(BetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BetResponse.decode(value),
  },
  bet: {
    path: '/dealer.DealerService/Bet',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BetRequest) =>
      Buffer.from(BetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BetRequest.decode(value),
    responseSerialize: (value: BetResponse) =>
      Buffer.from(BetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BetResponse.decode(value),
  },
  die: {
    path: '/dealer.DealerService/Die',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BetRequest) =>
      Buffer.from(BetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BetRequest.decode(value),
    responseSerialize: (value: BetResponse) =>
      Buffer.from(BetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BetResponse.decode(value),
  },
  showdown: {
    path: '/dealer.DealerService/Showdown',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BetRequest) =>
      Buffer.from(BetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BetRequest.decode(value),
    responseSerialize: (value: ShowdownResponse) =>
      Buffer.from(ShowdownResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ShowdownResponse.decode(value),
  },
  result: {
    path: '/dealer.DealerService/Result',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResultRequest) =>
      Buffer.from(ResultRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResultRequest.decode(value),
    responseSerialize: (value: ResultResponse) =>
      Buffer.from(ResultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResultResponse.decode(value),
  },
} as const;

export interface DealerServiceServer extends UntypedServiceImplementation {
  startGame: handleUnaryCall<StartGameRequest, StartGameResponse>;
  draw: handleUnaryCall<DrawRequest, DrawResponse>;
  burn: handleUnaryCall<BurnRequest, BurnResponse>;
  deposit: handleUnaryCall<BetRequest, BetResponse>;
  bet: handleUnaryCall<BetRequest, BetResponse>;
  die: handleUnaryCall<BetRequest, BetResponse>;
  showdown: handleUnaryCall<BetRequest, ShowdownResponse>;
  result: handleUnaryCall<ResultRequest, ResultResponse>;
}

export interface DealerServiceClient extends Client {
  startGame(
    request: StartGameRequest,
    callback: (error: ServiceError | null, response: StartGameResponse) => void,
  ): ClientUnaryCall;
  startGame(
    request: StartGameRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StartGameResponse) => void,
  ): ClientUnaryCall;
  startGame(
    request: StartGameRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StartGameResponse) => void,
  ): ClientUnaryCall;
  draw(
    request: DrawRequest,
    callback: (error: ServiceError | null, response: DrawResponse) => void,
  ): ClientUnaryCall;
  draw(
    request: DrawRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DrawResponse) => void,
  ): ClientUnaryCall;
  draw(
    request: DrawRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DrawResponse) => void,
  ): ClientUnaryCall;
  burn(
    request: BurnRequest,
    callback: (error: ServiceError | null, response: BurnResponse) => void,
  ): ClientUnaryCall;
  burn(
    request: BurnRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BurnResponse) => void,
  ): ClientUnaryCall;
  burn(
    request: BurnRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BurnResponse) => void,
  ): ClientUnaryCall;
  deposit(
    request: BetRequest,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  deposit(
    request: BetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  deposit(
    request: BetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  bet(
    request: BetRequest,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  bet(
    request: BetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  bet(
    request: BetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  die(
    request: BetRequest,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  die(
    request: BetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  die(
    request: BetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  showdown(
    request: BetRequest,
    callback: (error: ServiceError | null, response: ShowdownResponse) => void,
  ): ClientUnaryCall;
  showdown(
    request: BetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShowdownResponse) => void,
  ): ClientUnaryCall;
  showdown(
    request: BetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShowdownResponse) => void,
  ): ClientUnaryCall;
  result(
    request: ResultRequest,
    callback: (error: ServiceError | null, response: ResultResponse) => void,
  ): ClientUnaryCall;
  result(
    request: ResultRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResultResponse) => void,
  ): ClientUnaryCall;
  result(
    request: ResultRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResultResponse) => void,
  ): ClientUnaryCall;
}

export const DealerServiceClient = makeGenericClientConstructor(
  DealerServiceService,
  'dealer.DealerService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): DealerServiceClient;
  service: typeof DealerServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
