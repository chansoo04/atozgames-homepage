// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: record.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'dealer';

export interface MatchRecord {
  gameType: string;
  year: number;
  month: number;
  accountId: string;
  playCount: number;
  win: number;
  draw: number;
  lose: number;
}

export interface MatchRecordToday {
  accountId: string;
  win: number;
  lose: number;
}

export interface Play {
  dealerId: string;
  gameType: string;
  order: number;
  /** enum GameResultType */
  result: string;
  /** Json */
  handCard: string;
  /** bigint */
  betAmount: string;
  /** bigint */
  distributeAmount: string;
}

export interface Dealer {
  dealerId: string;
  gameType: string;
  channel: string;
  roomId: string;
  /** Json */
  dealedCard: string;
  /** Json */
  communityCard: string;
  /** Json */
  burnedCard: string;
}

export interface Hand {
  accountId: string;
  phaseType: string;
  /** Json */
  inCard: string;
  /** Json */
  outCard: string;
  /** Json */
  handCard: string;
}

export interface Bet {
  accountId: string;
  phaseType: string;
  betType: string;
  /** bigint */
  betAmount: string;
  txId: string;
}

export interface MatchRecordTodayRequest {
  accountId: string;
  gameType: string;
}

export interface MatchRecordTodayResponse {
  success: boolean;
  errorMessage: string;
  matchRecord?: MatchRecordToday | undefined;
}

export interface MatchRecordRequest {
  accountId: string;
  gameType: string;
  year: number;
  month: number;
}

export interface MatchRecordResponse {
  success: boolean;
  errorMessage: string;
  matchRecord: MatchRecord[];
}

export interface PlayListRequest {
  accountId: string;
  gameType: string;
  startTime: string;
  endTime: string;
  page: number;
  countPerPage: number;
}

export interface PlayListResponse {
  success: boolean;
  errorMessage: string;
  playList: Play[];
}

export interface PlayDetailRequest {
  dealerId: string;
}

export interface PlayDetailResponse {
  success: boolean;
  errorMessage: string;
  dealer?: Dealer | undefined;
  play: Play[];
  bet: Bet[];
  hand: Hand[];
}

function createBaseMatchRecord(): MatchRecord {
  return {
    gameType: '',
    year: 0,
    month: 0,
    accountId: '',
    playCount: 0,
    win: 0,
    draw: 0,
    lose: 0,
  };
}

export const MatchRecord = {
  encode(
    message: MatchRecord,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.gameType !== '') {
      writer.uint32(10).string(message.gameType);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(24).int32(message.month);
    }
    if (message.accountId !== '') {
      writer.uint32(34).string(message.accountId);
    }
    if (message.playCount !== 0) {
      writer.uint32(40).int32(message.playCount);
    }
    if (message.win !== 0) {
      writer.uint32(48).int32(message.win);
    }
    if (message.draw !== 0) {
      writer.uint32(56).int32(message.draw);
    }
    if (message.lose !== 0) {
      writer.uint32(64).int32(message.lose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchRecord {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gameType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.month = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.playCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.win = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.draw = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.lose = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchRecord {
    return {
      gameType: isSet(object.gameType)
        ? globalThis.String(object.gameType)
        : '',
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      playCount: isSet(object.playCount)
        ? globalThis.Number(object.playCount)
        : 0,
      win: isSet(object.win) ? globalThis.Number(object.win) : 0,
      draw: isSet(object.draw) ? globalThis.Number(object.draw) : 0,
      lose: isSet(object.lose) ? globalThis.Number(object.lose) : 0,
    };
  },

  toJSON(message: MatchRecord): unknown {
    const obj: any = {};
    if (message.gameType !== '') {
      obj.gameType = message.gameType;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.playCount !== 0) {
      obj.playCount = Math.round(message.playCount);
    }
    if (message.win !== 0) {
      obj.win = Math.round(message.win);
    }
    if (message.draw !== 0) {
      obj.draw = Math.round(message.draw);
    }
    if (message.lose !== 0) {
      obj.lose = Math.round(message.lose);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchRecord>, I>>(base?: I): MatchRecord {
    return MatchRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchRecord>, I>>(
    object: I,
  ): MatchRecord {
    const message = createBaseMatchRecord();
    message.gameType = object.gameType ?? '';
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.accountId = object.accountId ?? '';
    message.playCount = object.playCount ?? 0;
    message.win = object.win ?? 0;
    message.draw = object.draw ?? 0;
    message.lose = object.lose ?? 0;
    return message;
  },
};

function createBaseMatchRecordToday(): MatchRecordToday {
  return { accountId: '', win: 0, lose: 0 };
}

export const MatchRecordToday = {
  encode(
    message: MatchRecordToday,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.win !== 0) {
      writer.uint32(16).int32(message.win);
    }
    if (message.lose !== 0) {
      writer.uint32(24).int32(message.lose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchRecordToday {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchRecordToday();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.win = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lose = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchRecordToday {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      win: isSet(object.win) ? globalThis.Number(object.win) : 0,
      lose: isSet(object.lose) ? globalThis.Number(object.lose) : 0,
    };
  },

  toJSON(message: MatchRecordToday): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.win !== 0) {
      obj.win = Math.round(message.win);
    }
    if (message.lose !== 0) {
      obj.lose = Math.round(message.lose);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchRecordToday>, I>>(
    base?: I,
  ): MatchRecordToday {
    return MatchRecordToday.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchRecordToday>, I>>(
    object: I,
  ): MatchRecordToday {
    const message = createBaseMatchRecordToday();
    message.accountId = object.accountId ?? '';
    message.win = object.win ?? 0;
    message.lose = object.lose ?? 0;
    return message;
  },
};

function createBasePlay(): Play {
  return {
    dealerId: '',
    gameType: '',
    order: 0,
    result: '',
    handCard: '',
    betAmount: '',
    distributeAmount: '',
  };
}

export const Play = {
  encode(
    message: Play,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    if (message.gameType !== '') {
      writer.uint32(18).string(message.gameType);
    }
    if (message.order !== 0) {
      writer.uint32(24).int32(message.order);
    }
    if (message.result !== '') {
      writer.uint32(34).string(message.result);
    }
    if (message.handCard !== '') {
      writer.uint32(42).string(message.handCard);
    }
    if (message.betAmount !== '') {
      writer.uint32(50).string(message.betAmount);
    }
    if (message.distributeAmount !== '') {
      writer.uint32(58).string(message.distributeAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Play {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.order = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.result = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.handCard = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.betAmount = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.distributeAmount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Play {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      gameType: isSet(object.gameType)
        ? globalThis.String(object.gameType)
        : '',
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      result: isSet(object.result) ? globalThis.String(object.result) : '',
      handCard: isSet(object.handCard)
        ? globalThis.String(object.handCard)
        : '',
      betAmount: isSet(object.betAmount)
        ? globalThis.String(object.betAmount)
        : '',
      distributeAmount: isSet(object.distributeAmount)
        ? globalThis.String(object.distributeAmount)
        : '',
    };
  },

  toJSON(message: Play): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.gameType !== '') {
      obj.gameType = message.gameType;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.result !== '') {
      obj.result = message.result;
    }
    if (message.handCard !== '') {
      obj.handCard = message.handCard;
    }
    if (message.betAmount !== '') {
      obj.betAmount = message.betAmount;
    }
    if (message.distributeAmount !== '') {
      obj.distributeAmount = message.distributeAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Play>, I>>(base?: I): Play {
    return Play.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Play>, I>>(object: I): Play {
    const message = createBasePlay();
    message.dealerId = object.dealerId ?? '';
    message.gameType = object.gameType ?? '';
    message.order = object.order ?? 0;
    message.result = object.result ?? '';
    message.handCard = object.handCard ?? '';
    message.betAmount = object.betAmount ?? '';
    message.distributeAmount = object.distributeAmount ?? '';
    return message;
  },
};

function createBaseDealer(): Dealer {
  return {
    dealerId: '',
    gameType: '',
    channel: '',
    roomId: '',
    dealedCard: '',
    communityCard: '',
    burnedCard: '',
  };
}

export const Dealer = {
  encode(
    message: Dealer,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    if (message.gameType !== '') {
      writer.uint32(18).string(message.gameType);
    }
    if (message.channel !== '') {
      writer.uint32(26).string(message.channel);
    }
    if (message.roomId !== '') {
      writer.uint32(34).string(message.roomId);
    }
    if (message.dealedCard !== '') {
      writer.uint32(42).string(message.dealedCard);
    }
    if (message.communityCard !== '') {
      writer.uint32(50).string(message.communityCard);
    }
    if (message.burnedCard !== '') {
      writer.uint32(58).string(message.burnedCard);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dealer {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.roomId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dealedCard = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.communityCard = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.burnedCard = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dealer {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      gameType: isSet(object.gameType)
        ? globalThis.String(object.gameType)
        : '',
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : '',
      dealedCard: isSet(object.dealedCard)
        ? globalThis.String(object.dealedCard)
        : '',
      communityCard: isSet(object.communityCard)
        ? globalThis.String(object.communityCard)
        : '',
      burnedCard: isSet(object.burnedCard)
        ? globalThis.String(object.burnedCard)
        : '',
    };
  },

  toJSON(message: Dealer): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.gameType !== '') {
      obj.gameType = message.gameType;
    }
    if (message.channel !== '') {
      obj.channel = message.channel;
    }
    if (message.roomId !== '') {
      obj.roomId = message.roomId;
    }
    if (message.dealedCard !== '') {
      obj.dealedCard = message.dealedCard;
    }
    if (message.communityCard !== '') {
      obj.communityCard = message.communityCard;
    }
    if (message.burnedCard !== '') {
      obj.burnedCard = message.burnedCard;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dealer>, I>>(base?: I): Dealer {
    return Dealer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dealer>, I>>(object: I): Dealer {
    const message = createBaseDealer();
    message.dealerId = object.dealerId ?? '';
    message.gameType = object.gameType ?? '';
    message.channel = object.channel ?? '';
    message.roomId = object.roomId ?? '';
    message.dealedCard = object.dealedCard ?? '';
    message.communityCard = object.communityCard ?? '';
    message.burnedCard = object.burnedCard ?? '';
    return message;
  },
};

function createBaseHand(): Hand {
  return {
    accountId: '',
    phaseType: '',
    inCard: '',
    outCard: '',
    handCard: '',
  };
}

export const Hand = {
  encode(
    message: Hand,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.phaseType !== '') {
      writer.uint32(18).string(message.phaseType);
    }
    if (message.inCard !== '') {
      writer.uint32(26).string(message.inCard);
    }
    if (message.outCard !== '') {
      writer.uint32(34).string(message.outCard);
    }
    if (message.handCard !== '') {
      writer.uint32(42).string(message.handCard);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hand {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phaseType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inCard = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.outCard = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.handCard = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hand {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      phaseType: isSet(object.phaseType)
        ? globalThis.String(object.phaseType)
        : '',
      inCard: isSet(object.inCard) ? globalThis.String(object.inCard) : '',
      outCard: isSet(object.outCard) ? globalThis.String(object.outCard) : '',
      handCard: isSet(object.handCard)
        ? globalThis.String(object.handCard)
        : '',
    };
  },

  toJSON(message: Hand): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.phaseType !== '') {
      obj.phaseType = message.phaseType;
    }
    if (message.inCard !== '') {
      obj.inCard = message.inCard;
    }
    if (message.outCard !== '') {
      obj.outCard = message.outCard;
    }
    if (message.handCard !== '') {
      obj.handCard = message.handCard;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hand>, I>>(base?: I): Hand {
    return Hand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hand>, I>>(object: I): Hand {
    const message = createBaseHand();
    message.accountId = object.accountId ?? '';
    message.phaseType = object.phaseType ?? '';
    message.inCard = object.inCard ?? '';
    message.outCard = object.outCard ?? '';
    message.handCard = object.handCard ?? '';
    return message;
  },
};

function createBaseBet(): Bet {
  return { accountId: '', phaseType: '', betType: '', betAmount: '', txId: '' };
}

export const Bet = {
  encode(
    message: Bet,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.phaseType !== '') {
      writer.uint32(18).string(message.phaseType);
    }
    if (message.betType !== '') {
      writer.uint32(26).string(message.betType);
    }
    if (message.betAmount !== '') {
      writer.uint32(34).string(message.betAmount);
    }
    if (message.txId !== '') {
      writer.uint32(42).string(message.txId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bet {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phaseType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.betType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.betAmount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.txId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bet {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      phaseType: isSet(object.phaseType)
        ? globalThis.String(object.phaseType)
        : '',
      betType: isSet(object.betType) ? globalThis.String(object.betType) : '',
      betAmount: isSet(object.betAmount)
        ? globalThis.String(object.betAmount)
        : '',
      txId: isSet(object.txId) ? globalThis.String(object.txId) : '',
    };
  },

  toJSON(message: Bet): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.phaseType !== '') {
      obj.phaseType = message.phaseType;
    }
    if (message.betType !== '') {
      obj.betType = message.betType;
    }
    if (message.betAmount !== '') {
      obj.betAmount = message.betAmount;
    }
    if (message.txId !== '') {
      obj.txId = message.txId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bet>, I>>(base?: I): Bet {
    return Bet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bet>, I>>(object: I): Bet {
    const message = createBaseBet();
    message.accountId = object.accountId ?? '';
    message.phaseType = object.phaseType ?? '';
    message.betType = object.betType ?? '';
    message.betAmount = object.betAmount ?? '';
    message.txId = object.txId ?? '';
    return message;
  },
};

function createBaseMatchRecordTodayRequest(): MatchRecordTodayRequest {
  return { accountId: '', gameType: '' };
}

export const MatchRecordTodayRequest = {
  encode(
    message: MatchRecordTodayRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.gameType !== '') {
      writer.uint32(18).string(message.gameType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MatchRecordTodayRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchRecordTodayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchRecordTodayRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      gameType: isSet(object.gameType)
        ? globalThis.String(object.gameType)
        : '',
    };
  },

  toJSON(message: MatchRecordTodayRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.gameType !== '') {
      obj.gameType = message.gameType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchRecordTodayRequest>, I>>(
    base?: I,
  ): MatchRecordTodayRequest {
    return MatchRecordTodayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchRecordTodayRequest>, I>>(
    object: I,
  ): MatchRecordTodayRequest {
    const message = createBaseMatchRecordTodayRequest();
    message.accountId = object.accountId ?? '';
    message.gameType = object.gameType ?? '';
    return message;
  },
};

function createBaseMatchRecordTodayResponse(): MatchRecordTodayResponse {
  return { success: false, errorMessage: '', matchRecord: undefined };
}

export const MatchRecordTodayResponse = {
  encode(
    message: MatchRecordTodayResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.matchRecord !== undefined) {
      MatchRecordToday.encode(
        message.matchRecord,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MatchRecordTodayResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchRecordTodayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.matchRecord = MatchRecordToday.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchRecordTodayResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      matchRecord: isSet(object.matchRecord)
        ? MatchRecordToday.fromJSON(object.matchRecord)
        : undefined,
    };
  },

  toJSON(message: MatchRecordTodayResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.matchRecord !== undefined) {
      obj.matchRecord = MatchRecordToday.toJSON(message.matchRecord);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchRecordTodayResponse>, I>>(
    base?: I,
  ): MatchRecordTodayResponse {
    return MatchRecordTodayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchRecordTodayResponse>, I>>(
    object: I,
  ): MatchRecordTodayResponse {
    const message = createBaseMatchRecordTodayResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.matchRecord =
      object.matchRecord !== undefined && object.matchRecord !== null
        ? MatchRecordToday.fromPartial(object.matchRecord)
        : undefined;
    return message;
  },
};

function createBaseMatchRecordRequest(): MatchRecordRequest {
  return { accountId: '', gameType: '', year: 0, month: 0 };
}

export const MatchRecordRequest = {
  encode(
    message: MatchRecordRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.gameType !== '') {
      writer.uint32(34).string(message.gameType);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(24).int32(message.month);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MatchRecordRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gameType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.month = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchRecordRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      gameType: isSet(object.gameType)
        ? globalThis.String(object.gameType)
        : '',
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
    };
  },

  toJSON(message: MatchRecordRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.gameType !== '') {
      obj.gameType = message.gameType;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchRecordRequest>, I>>(
    base?: I,
  ): MatchRecordRequest {
    return MatchRecordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchRecordRequest>, I>>(
    object: I,
  ): MatchRecordRequest {
    const message = createBaseMatchRecordRequest();
    message.accountId = object.accountId ?? '';
    message.gameType = object.gameType ?? '';
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    return message;
  },
};

function createBaseMatchRecordResponse(): MatchRecordResponse {
  return { success: false, errorMessage: '', matchRecord: [] };
}

export const MatchRecordResponse = {
  encode(
    message: MatchRecordResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.matchRecord) {
      MatchRecord.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MatchRecordResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.matchRecord.push(MatchRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchRecordResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      matchRecord: globalThis.Array.isArray(object?.matchRecord)
        ? object.matchRecord.map((e: any) => MatchRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MatchRecordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.matchRecord?.length) {
      obj.matchRecord = message.matchRecord.map(e => MatchRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchRecordResponse>, I>>(
    base?: I,
  ): MatchRecordResponse {
    return MatchRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchRecordResponse>, I>>(
    object: I,
  ): MatchRecordResponse {
    const message = createBaseMatchRecordResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.matchRecord =
      object.matchRecord?.map(e => MatchRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayListRequest(): PlayListRequest {
  return {
    accountId: '',
    gameType: '',
    startTime: '',
    endTime: '',
    page: 0,
    countPerPage: 0,
  };
}

export const PlayListRequest = {
  encode(
    message: PlayListRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.gameType !== '') {
      writer.uint32(18).string(message.gameType);
    }
    if (message.startTime !== '') {
      writer.uint32(26).string(message.startTime);
    }
    if (message.endTime !== '') {
      writer.uint32(34).string(message.endTime);
    }
    if (message.page !== 0) {
      writer.uint32(40).int32(message.page);
    }
    if (message.countPerPage !== 0) {
      writer.uint32(48).int32(message.countPerPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayListRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.countPerPage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayListRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      gameType: isSet(object.gameType)
        ? globalThis.String(object.gameType)
        : '',
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : '',
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : '',
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      countPerPage: isSet(object.countPerPage)
        ? globalThis.Number(object.countPerPage)
        : 0,
    };
  },

  toJSON(message: PlayListRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.gameType !== '') {
      obj.gameType = message.gameType;
    }
    if (message.startTime !== '') {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== '') {
      obj.endTime = message.endTime;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.countPerPage !== 0) {
      obj.countPerPage = Math.round(message.countPerPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayListRequest>, I>>(
    base?: I,
  ): PlayListRequest {
    return PlayListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayListRequest>, I>>(
    object: I,
  ): PlayListRequest {
    const message = createBasePlayListRequest();
    message.accountId = object.accountId ?? '';
    message.gameType = object.gameType ?? '';
    message.startTime = object.startTime ?? '';
    message.endTime = object.endTime ?? '';
    message.page = object.page ?? 0;
    message.countPerPage = object.countPerPage ?? 0;
    return message;
  },
};

function createBasePlayListResponse(): PlayListResponse {
  return { success: false, errorMessage: '', playList: [] };
}

export const PlayListResponse = {
  encode(
    message: PlayListResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.playList) {
      Play.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayListResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.playList.push(Play.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayListResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      playList: globalThis.Array.isArray(object?.playList)
        ? object.playList.map((e: any) => Play.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlayListResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.playList?.length) {
      obj.playList = message.playList.map(e => Play.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayListResponse>, I>>(
    base?: I,
  ): PlayListResponse {
    return PlayListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayListResponse>, I>>(
    object: I,
  ): PlayListResponse {
    const message = createBasePlayListResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.playList = object.playList?.map(e => Play.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayDetailRequest(): PlayDetailRequest {
  return { dealerId: '' };
}

export const PlayDetailRequest = {
  encode(
    message: PlayDetailRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayDetailRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayDetailRequest {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
    };
  },

  toJSON(message: PlayDetailRequest): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayDetailRequest>, I>>(
    base?: I,
  ): PlayDetailRequest {
    return PlayDetailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayDetailRequest>, I>>(
    object: I,
  ): PlayDetailRequest {
    const message = createBasePlayDetailRequest();
    message.dealerId = object.dealerId ?? '';
    return message;
  },
};

function createBasePlayDetailResponse(): PlayDetailResponse {
  return {
    success: false,
    errorMessage: '',
    dealer: undefined,
    play: [],
    bet: [],
    hand: [],
  };
}

export const PlayDetailResponse = {
  encode(
    message: PlayDetailResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.dealer !== undefined) {
      Dealer.encode(message.dealer, writer.uint32(26).fork()).join();
    }
    for (const v of message.play) {
      Play.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.bet) {
      Bet.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.hand) {
      Hand.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PlayDetailResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dealer = Dealer.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.play.push(Play.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bet.push(Bet.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hand.push(Hand.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayDetailResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      dealer: isSet(object.dealer) ? Dealer.fromJSON(object.dealer) : undefined,
      play: globalThis.Array.isArray(object?.play)
        ? object.play.map((e: any) => Play.fromJSON(e))
        : [],
      bet: globalThis.Array.isArray(object?.bet)
        ? object.bet.map((e: any) => Bet.fromJSON(e))
        : [],
      hand: globalThis.Array.isArray(object?.hand)
        ? object.hand.map((e: any) => Hand.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlayDetailResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.dealer !== undefined) {
      obj.dealer = Dealer.toJSON(message.dealer);
    }
    if (message.play?.length) {
      obj.play = message.play.map(e => Play.toJSON(e));
    }
    if (message.bet?.length) {
      obj.bet = message.bet.map(e => Bet.toJSON(e));
    }
    if (message.hand?.length) {
      obj.hand = message.hand.map(e => Hand.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayDetailResponse>, I>>(
    base?: I,
  ): PlayDetailResponse {
    return PlayDetailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayDetailResponse>, I>>(
    object: I,
  ): PlayDetailResponse {
    const message = createBasePlayDetailResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.dealer =
      object.dealer !== undefined && object.dealer !== null
        ? Dealer.fromPartial(object.dealer)
        : undefined;
    message.play = object.play?.map(e => Play.fromPartial(e)) || [];
    message.bet = object.bet?.map(e => Bet.fromPartial(e)) || [];
    message.hand = object.hand?.map(e => Hand.fromPartial(e)) || [];
    return message;
  },
};

export type RecordServiceService = typeof RecordServiceService;
export const RecordServiceService = {
  /** 월간 전적 */
  matchRecord: {
    path: '/dealer.RecordService/MatchRecord',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MatchRecordRequest) =>
      Buffer.from(MatchRecordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MatchRecordRequest.decode(value),
    responseSerialize: (value: MatchRecordResponse) =>
      Buffer.from(MatchRecordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MatchRecordResponse.decode(value),
  },
  /** 매 게임 승패 기록 */
  playList: {
    path: '/dealer.RecordService/PlayList',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PlayListRequest) =>
      Buffer.from(PlayListRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PlayListRequest.decode(value),
    responseSerialize: (value: PlayListResponse) =>
      Buffer.from(PlayListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PlayListResponse.decode(value),
  },
  /** 딜러 기준 게임 상세 기록 */
  playDetail: {
    path: '/dealer.RecordService/PlayDetail',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PlayDetailRequest) =>
      Buffer.from(PlayDetailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PlayDetailRequest.decode(value),
    responseSerialize: (value: PlayDetailResponse) =>
      Buffer.from(PlayDetailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PlayDetailResponse.decode(value),
  },
  /** 월간 전적 */
  matchRecordToday: {
    path: '/dealer.RecordService/MatchRecordToday',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MatchRecordTodayRequest) =>
      Buffer.from(MatchRecordTodayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      MatchRecordTodayRequest.decode(value),
    responseSerialize: (value: MatchRecordTodayResponse) =>
      Buffer.from(MatchRecordTodayResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      MatchRecordTodayResponse.decode(value),
  },
} as const;

export interface RecordServiceServer extends UntypedServiceImplementation {
  /** 월간 전적 */
  matchRecord: handleUnaryCall<MatchRecordRequest, MatchRecordResponse>;
  /** 매 게임 승패 기록 */
  playList: handleUnaryCall<PlayListRequest, PlayListResponse>;
  /** 딜러 기준 게임 상세 기록 */
  playDetail: handleUnaryCall<PlayDetailRequest, PlayDetailResponse>;
  /** 월간 전적 */
  matchRecordToday: handleUnaryCall<
    MatchRecordTodayRequest,
    MatchRecordTodayResponse
  >;
}

export interface RecordServiceClient extends Client {
  /** 월간 전적 */
  matchRecord(
    request: MatchRecordRequest,
    callback: (
      error: ServiceError | null,
      response: MatchRecordResponse,
    ) => void,
  ): ClientUnaryCall;
  matchRecord(
    request: MatchRecordRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: MatchRecordResponse,
    ) => void,
  ): ClientUnaryCall;
  matchRecord(
    request: MatchRecordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: MatchRecordResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 매 게임 승패 기록 */
  playList(
    request: PlayListRequest,
    callback: (error: ServiceError | null, response: PlayListResponse) => void,
  ): ClientUnaryCall;
  playList(
    request: PlayListRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PlayListResponse) => void,
  ): ClientUnaryCall;
  playList(
    request: PlayListRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PlayListResponse) => void,
  ): ClientUnaryCall;
  /** 딜러 기준 게임 상세 기록 */
  playDetail(
    request: PlayDetailRequest,
    callback: (
      error: ServiceError | null,
      response: PlayDetailResponse,
    ) => void,
  ): ClientUnaryCall;
  playDetail(
    request: PlayDetailRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: PlayDetailResponse,
    ) => void,
  ): ClientUnaryCall;
  playDetail(
    request: PlayDetailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: PlayDetailResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 월간 전적 */
  matchRecordToday(
    request: MatchRecordTodayRequest,
    callback: (
      error: ServiceError | null,
      response: MatchRecordTodayResponse,
    ) => void,
  ): ClientUnaryCall;
  matchRecordToday(
    request: MatchRecordTodayRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: MatchRecordTodayResponse,
    ) => void,
  ): ClientUnaryCall;
  matchRecordToday(
    request: MatchRecordTodayRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: MatchRecordTodayResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const RecordServiceClient = makeGenericClientConstructor(
  RecordServiceService,
  'dealer.RecordService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): RecordServiceClient;
  service: typeof RecordServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
