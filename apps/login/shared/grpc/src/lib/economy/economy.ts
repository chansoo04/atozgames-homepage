// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: economy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'economy';

export interface Amount {
  game: string;
  cash: string;
}

export interface AmountWithAccountId {
  accountId: string;
  balance?: Amount | undefined;
  moneyBox?: Amount | undefined;
}

/** 공용, account_id 파라미터 */
export interface AccountIdParam {
  accountId: string;
}

export interface CreateBalanceResponse {
  success: boolean;
  errorMessage: string;
  balanceId: number;
}

export interface CreateMoneyBoxResponse {
  success: boolean;
  errorMessage: string;
  moneyBoxId: number;
}

export interface BalanceAndMoneyBoxResponse {
  success: boolean;
  errorMessage: string;
  balance?: Amount | undefined;
  moneyBox?: Amount | undefined;
  /** pause at time */
  pauseAt: string;
}

/** 금고 입출금 요청 */
export interface UpdateMoneyBoxRequest {
  accountId: string;
  amount: string;
}

/** 금고 업데이트 값, 유저 보유 자산 반환 */
export interface UpdateMoneyBoxResponse {
  success: boolean;
  errorMessage: string;
  balance?: Amount | undefined;
  moneyBox?: Amount | undefined;
}

export interface SetBalanceAndMoneyBoxRequest {
  accountId: string;
  /** 손 */
  balance?: Amount | undefined;
  /** 금고 */
  moneyBox?: Amount | undefined;
}

export interface CreatePotRequest {
  dealerId: string;
  accountId: string[];
}

export interface CreatePotResponse {
  success: boolean;
  errorMessage: string;
  potId: string;
}

export interface BetRequest {
  potId: string;
  accountId: string;
  amount: string;
  /** true: deposit, false: normal bet */
  isDeposit: boolean;
}

export interface BetResponse {
  success: boolean;
  errorMessage: string;
  /** account balance */
  balance?: Amount | undefined;
  potAmount: string;
  /** tx id */
  txId: string;
}

export interface TransferInRequest {
  txGroupId: string;
  accountId: string;
  amount?: Amount | undefined;
  /** REWARD, POST_BOX */
  from: string;
  allowOverflow: boolean;
}

export interface TransferInResponse {
  success: boolean;
  errorMessage: string;
  balance?: Amount | undefined;
  overflow?: Amount | undefined;
  /** tx group id */
  txGroupId: string;
  /** tx id */
  txId: string;
  /** postbox id */
  postboxId: number;
}

export interface GetAmountByAccountIdsRequest {
  accountIds: string[];
}

export interface GetAmountByAccountIdsResponse {
  success: boolean;
  errorMessage: string;
  amounts: AmountWithAccountId[];
}

export interface DistributePlayer {
  accountId: string;
  rank: number;
}

export interface DistributeRequest {
  potId: string;
  gameId: string;
  channel: string;
  players: DistributePlayer[];
}

export interface DistributeResult {
  accountId: string;
  /** WIN, DRAW, DISTRIBUTE */
  type: string;
  lake: number;
  /** bigint */
  lakeAmount: string;
  distributeAmount?: Amount | undefined;
  balanceAmount?: Amount | undefined;
  /** true: limit over, false: normal distribute */
  isLimitOver: boolean;
}

export interface DistributeResponse {
  success: boolean;
  errorMessage: string;
  result: DistributeResult[];
}

export interface DistributeResultRequest {
  potId: string;
  accountId: string;
}

export interface DistributeResultResponse {
  success: boolean;
  errorMessage: string;
  result?: DistributeResult | undefined;
}

export interface ExceptRefundRequest {
  potId: string;
}

export interface ExceptRefundResponse {
  success: boolean;
  errorMessage: string;
  txGroupId: string;
}

export interface CreateDefaultDailyBalanceRequest {
  userId: string;
  /** loss limit amount */
  lossLimit: string;
}

export interface GetDailyFlowRequest {
  userId: string;
}

export interface GetDailyFlowResponse {
  success: boolean;
  errorMessage: string;
  /** total in amount */
  in: string;
  /** total out amount */
  out: string;
  /** total amount */
  total: string;
  /** total limit amount */
  limit: string;
  /** remain amount */
  remain: string;
}

export interface DailyFlowFromPostBoxRequest {
  accountId: string;
  /** cash amount */
  cash: string;
  /** game amount */
  game: string;
}

export interface DefaultResponse {
  success: boolean;
  errorMessage: string;
}

function createBaseAmount(): Amount {
  return { game: '', cash: '' };
}

export const Amount = {
  encode(
    message: Amount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.game !== '') {
      writer.uint32(10).string(message.game);
    }
    if (message.cash !== '') {
      writer.uint32(18).string(message.cash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Amount {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.game = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Amount {
    return {
      game: isSet(object.game) ? globalThis.String(object.game) : '',
      cash: isSet(object.cash) ? globalThis.String(object.cash) : '',
    };
  },

  toJSON(message: Amount): unknown {
    const obj: any = {};
    if (message.game !== '') {
      obj.game = message.game;
    }
    if (message.cash !== '') {
      obj.cash = message.cash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Amount>, I>>(base?: I): Amount {
    return Amount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Amount>, I>>(object: I): Amount {
    const message = createBaseAmount();
    message.game = object.game ?? '';
    message.cash = object.cash ?? '';
    return message;
  },
};

function createBaseAmountWithAccountId(): AmountWithAccountId {
  return { accountId: '', balance: undefined, moneyBox: undefined };
}

export const AmountWithAccountId = {
  encode(
    message: AmountWithAccountId,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.balance !== undefined) {
      Amount.encode(message.balance, writer.uint32(18).fork()).join();
    }
    if (message.moneyBox !== undefined) {
      Amount.encode(message.moneyBox, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AmountWithAccountId {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmountWithAccountId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Amount.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.moneyBox = Amount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AmountWithAccountId {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      balance: isSet(object.balance)
        ? Amount.fromJSON(object.balance)
        : undefined,
      moneyBox: isSet(object.moneyBox)
        ? Amount.fromJSON(object.moneyBox)
        : undefined,
    };
  },

  toJSON(message: AmountWithAccountId): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.balance !== undefined) {
      obj.balance = Amount.toJSON(message.balance);
    }
    if (message.moneyBox !== undefined) {
      obj.moneyBox = Amount.toJSON(message.moneyBox);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AmountWithAccountId>, I>>(
    base?: I,
  ): AmountWithAccountId {
    return AmountWithAccountId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AmountWithAccountId>, I>>(
    object: I,
  ): AmountWithAccountId {
    const message = createBaseAmountWithAccountId();
    message.accountId = object.accountId ?? '';
    message.balance =
      object.balance !== undefined && object.balance !== null
        ? Amount.fromPartial(object.balance)
        : undefined;
    message.moneyBox =
      object.moneyBox !== undefined && object.moneyBox !== null
        ? Amount.fromPartial(object.moneyBox)
        : undefined;
    return message;
  },
};

function createBaseAccountIdParam(): AccountIdParam {
  return { accountId: '' };
}

export const AccountIdParam = {
  encode(
    message: AccountIdParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountIdParam {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountIdParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountIdParam {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
    };
  },

  toJSON(message: AccountIdParam): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountIdParam>, I>>(
    base?: I,
  ): AccountIdParam {
    return AccountIdParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountIdParam>, I>>(
    object: I,
  ): AccountIdParam {
    const message = createBaseAccountIdParam();
    message.accountId = object.accountId ?? '';
    return message;
  },
};

function createBaseCreateBalanceResponse(): CreateBalanceResponse {
  return { success: false, errorMessage: '', balanceId: 0 };
}

export const CreateBalanceResponse = {
  encode(
    message: CreateBalanceResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.balanceId !== 0) {
      writer.uint32(24).int32(message.balanceId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateBalanceResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.balanceId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBalanceResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      balanceId: isSet(object.balanceId)
        ? globalThis.Number(object.balanceId)
        : 0,
    };
  },

  toJSON(message: CreateBalanceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.balanceId !== 0) {
      obj.balanceId = Math.round(message.balanceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBalanceResponse>, I>>(
    base?: I,
  ): CreateBalanceResponse {
    return CreateBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBalanceResponse>, I>>(
    object: I,
  ): CreateBalanceResponse {
    const message = createBaseCreateBalanceResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.balanceId = object.balanceId ?? 0;
    return message;
  },
};

function createBaseCreateMoneyBoxResponse(): CreateMoneyBoxResponse {
  return { success: false, errorMessage: '', moneyBoxId: 0 };
}

export const CreateMoneyBoxResponse = {
  encode(
    message: CreateMoneyBoxResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.moneyBoxId !== 0) {
      writer.uint32(24).int32(message.moneyBoxId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateMoneyBoxResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMoneyBoxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.moneyBoxId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMoneyBoxResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      moneyBoxId: isSet(object.moneyBoxId)
        ? globalThis.Number(object.moneyBoxId)
        : 0,
    };
  },

  toJSON(message: CreateMoneyBoxResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.moneyBoxId !== 0) {
      obj.moneyBoxId = Math.round(message.moneyBoxId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMoneyBoxResponse>, I>>(
    base?: I,
  ): CreateMoneyBoxResponse {
    return CreateMoneyBoxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMoneyBoxResponse>, I>>(
    object: I,
  ): CreateMoneyBoxResponse {
    const message = createBaseCreateMoneyBoxResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.moneyBoxId = object.moneyBoxId ?? 0;
    return message;
  },
};

function createBaseBalanceAndMoneyBoxResponse(): BalanceAndMoneyBoxResponse {
  return {
    success: false,
    errorMessage: '',
    balance: undefined,
    moneyBox: undefined,
    pauseAt: '',
  };
}

export const BalanceAndMoneyBoxResponse = {
  encode(
    message: BalanceAndMoneyBoxResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.balance !== undefined) {
      Amount.encode(message.balance, writer.uint32(26).fork()).join();
    }
    if (message.moneyBox !== undefined) {
      Amount.encode(message.moneyBox, writer.uint32(34).fork()).join();
    }
    if (message.pauseAt !== '') {
      writer.uint32(42).string(message.pauseAt);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BalanceAndMoneyBoxResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceAndMoneyBoxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.balance = Amount.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.moneyBox = Amount.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pauseAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceAndMoneyBoxResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      balance: isSet(object.balance)
        ? Amount.fromJSON(object.balance)
        : undefined,
      moneyBox: isSet(object.moneyBox)
        ? Amount.fromJSON(object.moneyBox)
        : undefined,
      pauseAt: isSet(object.pauseAt) ? globalThis.String(object.pauseAt) : '',
    };
  },

  toJSON(message: BalanceAndMoneyBoxResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.balance !== undefined) {
      obj.balance = Amount.toJSON(message.balance);
    }
    if (message.moneyBox !== undefined) {
      obj.moneyBox = Amount.toJSON(message.moneyBox);
    }
    if (message.pauseAt !== '') {
      obj.pauseAt = message.pauseAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceAndMoneyBoxResponse>, I>>(
    base?: I,
  ): BalanceAndMoneyBoxResponse {
    return BalanceAndMoneyBoxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceAndMoneyBoxResponse>, I>>(
    object: I,
  ): BalanceAndMoneyBoxResponse {
    const message = createBaseBalanceAndMoneyBoxResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.balance =
      object.balance !== undefined && object.balance !== null
        ? Amount.fromPartial(object.balance)
        : undefined;
    message.moneyBox =
      object.moneyBox !== undefined && object.moneyBox !== null
        ? Amount.fromPartial(object.moneyBox)
        : undefined;
    message.pauseAt = object.pauseAt ?? '';
    return message;
  },
};

function createBaseUpdateMoneyBoxRequest(): UpdateMoneyBoxRequest {
  return { accountId: '', amount: '' };
}

export const UpdateMoneyBoxRequest = {
  encode(
    message: UpdateMoneyBoxRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.amount !== '') {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateMoneyBoxRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMoneyBoxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMoneyBoxRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
    };
  },

  toJSON(message: UpdateMoneyBoxRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateMoneyBoxRequest>, I>>(
    base?: I,
  ): UpdateMoneyBoxRequest {
    return UpdateMoneyBoxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateMoneyBoxRequest>, I>>(
    object: I,
  ): UpdateMoneyBoxRequest {
    const message = createBaseUpdateMoneyBoxRequest();
    message.accountId = object.accountId ?? '';
    message.amount = object.amount ?? '';
    return message;
  },
};

function createBaseUpdateMoneyBoxResponse(): UpdateMoneyBoxResponse {
  return {
    success: false,
    errorMessage: '',
    balance: undefined,
    moneyBox: undefined,
  };
}

export const UpdateMoneyBoxResponse = {
  encode(
    message: UpdateMoneyBoxResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.balance !== undefined) {
      Amount.encode(message.balance, writer.uint32(26).fork()).join();
    }
    if (message.moneyBox !== undefined) {
      Amount.encode(message.moneyBox, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateMoneyBoxResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMoneyBoxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.balance = Amount.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.moneyBox = Amount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMoneyBoxResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      balance: isSet(object.balance)
        ? Amount.fromJSON(object.balance)
        : undefined,
      moneyBox: isSet(object.moneyBox)
        ? Amount.fromJSON(object.moneyBox)
        : undefined,
    };
  },

  toJSON(message: UpdateMoneyBoxResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.balance !== undefined) {
      obj.balance = Amount.toJSON(message.balance);
    }
    if (message.moneyBox !== undefined) {
      obj.moneyBox = Amount.toJSON(message.moneyBox);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateMoneyBoxResponse>, I>>(
    base?: I,
  ): UpdateMoneyBoxResponse {
    return UpdateMoneyBoxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateMoneyBoxResponse>, I>>(
    object: I,
  ): UpdateMoneyBoxResponse {
    const message = createBaseUpdateMoneyBoxResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.balance =
      object.balance !== undefined && object.balance !== null
        ? Amount.fromPartial(object.balance)
        : undefined;
    message.moneyBox =
      object.moneyBox !== undefined && object.moneyBox !== null
        ? Amount.fromPartial(object.moneyBox)
        : undefined;
    return message;
  },
};

function createBaseSetBalanceAndMoneyBoxRequest(): SetBalanceAndMoneyBoxRequest {
  return { accountId: '', balance: undefined, moneyBox: undefined };
}

export const SetBalanceAndMoneyBoxRequest = {
  encode(
    message: SetBalanceAndMoneyBoxRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.balance !== undefined) {
      Amount.encode(message.balance, writer.uint32(18).fork()).join();
    }
    if (message.moneyBox !== undefined) {
      Amount.encode(message.moneyBox, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SetBalanceAndMoneyBoxRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetBalanceAndMoneyBoxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Amount.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.moneyBox = Amount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetBalanceAndMoneyBoxRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      balance: isSet(object.balance)
        ? Amount.fromJSON(object.balance)
        : undefined,
      moneyBox: isSet(object.moneyBox)
        ? Amount.fromJSON(object.moneyBox)
        : undefined,
    };
  },

  toJSON(message: SetBalanceAndMoneyBoxRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.balance !== undefined) {
      obj.balance = Amount.toJSON(message.balance);
    }
    if (message.moneyBox !== undefined) {
      obj.moneyBox = Amount.toJSON(message.moneyBox);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetBalanceAndMoneyBoxRequest>, I>>(
    base?: I,
  ): SetBalanceAndMoneyBoxRequest {
    return SetBalanceAndMoneyBoxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetBalanceAndMoneyBoxRequest>, I>>(
    object: I,
  ): SetBalanceAndMoneyBoxRequest {
    const message = createBaseSetBalanceAndMoneyBoxRequest();
    message.accountId = object.accountId ?? '';
    message.balance =
      object.balance !== undefined && object.balance !== null
        ? Amount.fromPartial(object.balance)
        : undefined;
    message.moneyBox =
      object.moneyBox !== undefined && object.moneyBox !== null
        ? Amount.fromPartial(object.moneyBox)
        : undefined;
    return message;
  },
};

function createBaseCreatePotRequest(): CreatePotRequest {
  return { dealerId: '', accountId: [] };
}

export const CreatePotRequest = {
  encode(
    message: CreatePotRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dealerId !== '') {
      writer.uint32(10).string(message.dealerId);
    }
    for (const v of message.accountId) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePotRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dealerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePotRequest {
    return {
      dealerId: isSet(object.dealerId)
        ? globalThis.String(object.dealerId)
        : '',
      accountId: globalThis.Array.isArray(object?.accountId)
        ? object.accountId.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreatePotRequest): unknown {
    const obj: any = {};
    if (message.dealerId !== '') {
      obj.dealerId = message.dealerId;
    }
    if (message.accountId?.length) {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePotRequest>, I>>(
    base?: I,
  ): CreatePotRequest {
    return CreatePotRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePotRequest>, I>>(
    object: I,
  ): CreatePotRequest {
    const message = createBaseCreatePotRequest();
    message.dealerId = object.dealerId ?? '';
    message.accountId = object.accountId?.map(e => e) || [];
    return message;
  },
};

function createBaseCreatePotResponse(): CreatePotResponse {
  return { success: false, errorMessage: '', potId: '' };
}

export const CreatePotResponse = {
  encode(
    message: CreatePotResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.potId !== '') {
      writer.uint32(26).string(message.potId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePotResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.potId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePotResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      potId: isSet(object.potId) ? globalThis.String(object.potId) : '',
    };
  },

  toJSON(message: CreatePotResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.potId !== '') {
      obj.potId = message.potId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePotResponse>, I>>(
    base?: I,
  ): CreatePotResponse {
    return CreatePotResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePotResponse>, I>>(
    object: I,
  ): CreatePotResponse {
    const message = createBaseCreatePotResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.potId = object.potId ?? '';
    return message;
  },
};

function createBaseBetRequest(): BetRequest {
  return { potId: '', accountId: '', amount: '', isDeposit: false };
}

export const BetRequest = {
  encode(
    message: BetRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.potId !== '') {
      writer.uint32(10).string(message.potId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.amount !== '') {
      writer.uint32(26).string(message.amount);
    }
    if (message.isDeposit !== false) {
      writer.uint32(32).bool(message.isDeposit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BetRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.potId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isDeposit = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BetRequest {
    return {
      potId: isSet(object.potId) ? globalThis.String(object.potId) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
      isDeposit: isSet(object.isDeposit)
        ? globalThis.Boolean(object.isDeposit)
        : false,
    };
  },

  toJSON(message: BetRequest): unknown {
    const obj: any = {};
    if (message.potId !== '') {
      obj.potId = message.potId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    if (message.isDeposit !== false) {
      obj.isDeposit = message.isDeposit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BetRequest>, I>>(base?: I): BetRequest {
    return BetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BetRequest>, I>>(
    object: I,
  ): BetRequest {
    const message = createBaseBetRequest();
    message.potId = object.potId ?? '';
    message.accountId = object.accountId ?? '';
    message.amount = object.amount ?? '';
    message.isDeposit = object.isDeposit ?? false;
    return message;
  },
};

function createBaseBetResponse(): BetResponse {
  return {
    success: false,
    errorMessage: '',
    balance: undefined,
    potAmount: '',
    txId: '',
  };
}

export const BetResponse = {
  encode(
    message: BetResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.balance !== undefined) {
      Amount.encode(message.balance, writer.uint32(26).fork()).join();
    }
    if (message.potAmount !== '') {
      writer.uint32(34).string(message.potAmount);
    }
    if (message.txId !== '') {
      writer.uint32(42).string(message.txId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BetResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.balance = Amount.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.potAmount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.txId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BetResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      balance: isSet(object.balance)
        ? Amount.fromJSON(object.balance)
        : undefined,
      potAmount: isSet(object.potAmount)
        ? globalThis.String(object.potAmount)
        : '',
      txId: isSet(object.txId) ? globalThis.String(object.txId) : '',
    };
  },

  toJSON(message: BetResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.balance !== undefined) {
      obj.balance = Amount.toJSON(message.balance);
    }
    if (message.potAmount !== '') {
      obj.potAmount = message.potAmount;
    }
    if (message.txId !== '') {
      obj.txId = message.txId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BetResponse>, I>>(base?: I): BetResponse {
    return BetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BetResponse>, I>>(
    object: I,
  ): BetResponse {
    const message = createBaseBetResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.balance =
      object.balance !== undefined && object.balance !== null
        ? Amount.fromPartial(object.balance)
        : undefined;
    message.potAmount = object.potAmount ?? '';
    message.txId = object.txId ?? '';
    return message;
  },
};

function createBaseTransferInRequest(): TransferInRequest {
  return {
    txGroupId: '',
    accountId: '',
    amount: undefined,
    from: '',
    allowOverflow: false,
  };
}

export const TransferInRequest = {
  encode(
    message: TransferInRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txGroupId !== '') {
      writer.uint32(10).string(message.txGroupId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.amount !== undefined) {
      Amount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.from !== '') {
      writer.uint32(34).string(message.from);
    }
    if (message.allowOverflow !== false) {
      writer.uint32(40).bool(message.allowOverflow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferInRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferInRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txGroupId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = Amount.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.from = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.allowOverflow = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferInRequest {
    return {
      txGroupId: isSet(object.txGroupId)
        ? globalThis.String(object.txGroupId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      amount: isSet(object.amount) ? Amount.fromJSON(object.amount) : undefined,
      from: isSet(object.from) ? globalThis.String(object.from) : '',
      allowOverflow: isSet(object.allowOverflow)
        ? globalThis.Boolean(object.allowOverflow)
        : false,
    };
  },

  toJSON(message: TransferInRequest): unknown {
    const obj: any = {};
    if (message.txGroupId !== '') {
      obj.txGroupId = message.txGroupId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.amount !== undefined) {
      obj.amount = Amount.toJSON(message.amount);
    }
    if (message.from !== '') {
      obj.from = message.from;
    }
    if (message.allowOverflow !== false) {
      obj.allowOverflow = message.allowOverflow;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferInRequest>, I>>(
    base?: I,
  ): TransferInRequest {
    return TransferInRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferInRequest>, I>>(
    object: I,
  ): TransferInRequest {
    const message = createBaseTransferInRequest();
    message.txGroupId = object.txGroupId ?? '';
    message.accountId = object.accountId ?? '';
    message.amount =
      object.amount !== undefined && object.amount !== null
        ? Amount.fromPartial(object.amount)
        : undefined;
    message.from = object.from ?? '';
    message.allowOverflow = object.allowOverflow ?? false;
    return message;
  },
};

function createBaseTransferInResponse(): TransferInResponse {
  return {
    success: false,
    errorMessage: '',
    balance: undefined,
    overflow: undefined,
    txGroupId: '',
    txId: '',
    postboxId: 0,
  };
}

export const TransferInResponse = {
  encode(
    message: TransferInResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.balance !== undefined) {
      Amount.encode(message.balance, writer.uint32(26).fork()).join();
    }
    if (message.overflow !== undefined) {
      Amount.encode(message.overflow, writer.uint32(34).fork()).join();
    }
    if (message.txGroupId !== '') {
      writer.uint32(42).string(message.txGroupId);
    }
    if (message.txId !== '') {
      writer.uint32(50).string(message.txId);
    }
    if (message.postboxId !== 0) {
      writer.uint32(56).int32(message.postboxId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TransferInResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferInResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.balance = Amount.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.overflow = Amount.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.txGroupId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.postboxId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferInResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      balance: isSet(object.balance)
        ? Amount.fromJSON(object.balance)
        : undefined,
      overflow: isSet(object.overflow)
        ? Amount.fromJSON(object.overflow)
        : undefined,
      txGroupId: isSet(object.txGroupId)
        ? globalThis.String(object.txGroupId)
        : '',
      txId: isSet(object.txId) ? globalThis.String(object.txId) : '',
      postboxId: isSet(object.postboxId)
        ? globalThis.Number(object.postboxId)
        : 0,
    };
  },

  toJSON(message: TransferInResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.balance !== undefined) {
      obj.balance = Amount.toJSON(message.balance);
    }
    if (message.overflow !== undefined) {
      obj.overflow = Amount.toJSON(message.overflow);
    }
    if (message.txGroupId !== '') {
      obj.txGroupId = message.txGroupId;
    }
    if (message.txId !== '') {
      obj.txId = message.txId;
    }
    if (message.postboxId !== 0) {
      obj.postboxId = Math.round(message.postboxId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferInResponse>, I>>(
    base?: I,
  ): TransferInResponse {
    return TransferInResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferInResponse>, I>>(
    object: I,
  ): TransferInResponse {
    const message = createBaseTransferInResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.balance =
      object.balance !== undefined && object.balance !== null
        ? Amount.fromPartial(object.balance)
        : undefined;
    message.overflow =
      object.overflow !== undefined && object.overflow !== null
        ? Amount.fromPartial(object.overflow)
        : undefined;
    message.txGroupId = object.txGroupId ?? '';
    message.txId = object.txId ?? '';
    message.postboxId = object.postboxId ?? 0;
    return message;
  },
};

function createBaseGetAmountByAccountIdsRequest(): GetAmountByAccountIdsRequest {
  return { accountIds: [] };
}

export const GetAmountByAccountIdsRequest = {
  encode(
    message: GetAmountByAccountIdsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.accountIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAmountByAccountIdsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAmountByAccountIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAmountByAccountIdsRequest {
    return {
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetAmountByAccountIdsRequest): unknown {
    const obj: any = {};
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAmountByAccountIdsRequest>, I>>(
    base?: I,
  ): GetAmountByAccountIdsRequest {
    return GetAmountByAccountIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAmountByAccountIdsRequest>, I>>(
    object: I,
  ): GetAmountByAccountIdsRequest {
    const message = createBaseGetAmountByAccountIdsRequest();
    message.accountIds = object.accountIds?.map(e => e) || [];
    return message;
  },
};

function createBaseGetAmountByAccountIdsResponse(): GetAmountByAccountIdsResponse {
  return { success: false, errorMessage: '', amounts: [] };
}

export const GetAmountByAccountIdsResponse = {
  encode(
    message: GetAmountByAccountIdsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.amounts) {
      AmountWithAccountId.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAmountByAccountIdsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAmountByAccountIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amounts.push(
            AmountWithAccountId.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAmountByAccountIdsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      amounts: globalThis.Array.isArray(object?.amounts)
        ? object.amounts.map((e: any) => AmountWithAccountId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAmountByAccountIdsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.amounts?.length) {
      obj.amounts = message.amounts.map(e => AmountWithAccountId.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAmountByAccountIdsResponse>, I>>(
    base?: I,
  ): GetAmountByAccountIdsResponse {
    return GetAmountByAccountIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAmountByAccountIdsResponse>, I>>(
    object: I,
  ): GetAmountByAccountIdsResponse {
    const message = createBaseGetAmountByAccountIdsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.amounts =
      object.amounts?.map(e => AmountWithAccountId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDistributePlayer(): DistributePlayer {
  return { accountId: '', rank: 0 };
}

export const DistributePlayer = {
  encode(
    message: DistributePlayer,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.rank !== 0) {
      writer.uint32(16).int32(message.rank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistributePlayer {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistributePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rank = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistributePlayer {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
    };
  },

  toJSON(message: DistributePlayer): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistributePlayer>, I>>(
    base?: I,
  ): DistributePlayer {
    return DistributePlayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistributePlayer>, I>>(
    object: I,
  ): DistributePlayer {
    const message = createBaseDistributePlayer();
    message.accountId = object.accountId ?? '';
    message.rank = object.rank ?? 0;
    return message;
  },
};

function createBaseDistributeRequest(): DistributeRequest {
  return { potId: '', gameId: '', channel: '', players: [] };
}

export const DistributeRequest = {
  encode(
    message: DistributeRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.potId !== '') {
      writer.uint32(10).string(message.potId);
    }
    if (message.gameId !== '') {
      writer.uint32(18).string(message.gameId);
    }
    if (message.channel !== '') {
      writer.uint32(26).string(message.channel);
    }
    for (const v of message.players) {
      DistributePlayer.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistributeRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.potId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.players.push(
            DistributePlayer.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistributeRequest {
    return {
      potId: isSet(object.potId) ? globalThis.String(object.potId) : '',
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : '',
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => DistributePlayer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DistributeRequest): unknown {
    const obj: any = {};
    if (message.potId !== '') {
      obj.potId = message.potId;
    }
    if (message.gameId !== '') {
      obj.gameId = message.gameId;
    }
    if (message.channel !== '') {
      obj.channel = message.channel;
    }
    if (message.players?.length) {
      obj.players = message.players.map(e => DistributePlayer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistributeRequest>, I>>(
    base?: I,
  ): DistributeRequest {
    return DistributeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistributeRequest>, I>>(
    object: I,
  ): DistributeRequest {
    const message = createBaseDistributeRequest();
    message.potId = object.potId ?? '';
    message.gameId = object.gameId ?? '';
    message.channel = object.channel ?? '';
    message.players =
      object.players?.map(e => DistributePlayer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDistributeResult(): DistributeResult {
  return {
    accountId: '',
    type: '',
    lake: 0,
    lakeAmount: '',
    distributeAmount: undefined,
    balanceAmount: undefined,
    isLimitOver: false,
  };
}

export const DistributeResult = {
  encode(
    message: DistributeResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.type !== '') {
      writer.uint32(18).string(message.type);
    }
    if (message.lake !== 0) {
      writer.uint32(29).float(message.lake);
    }
    if (message.lakeAmount !== '') {
      writer.uint32(34).string(message.lakeAmount);
    }
    if (message.distributeAmount !== undefined) {
      Amount.encode(message.distributeAmount, writer.uint32(42).fork()).join();
    }
    if (message.balanceAmount !== undefined) {
      Amount.encode(message.balanceAmount, writer.uint32(50).fork()).join();
    }
    if (message.isLimitOver !== false) {
      writer.uint32(56).bool(message.isLimitOver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistributeResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistributeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.lake = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lakeAmount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.distributeAmount = Amount.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.balanceAmount = Amount.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isLimitOver = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistributeResult {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      lake: isSet(object.lake) ? globalThis.Number(object.lake) : 0,
      lakeAmount: isSet(object.lakeAmount)
        ? globalThis.String(object.lakeAmount)
        : '',
      distributeAmount: isSet(object.distributeAmount)
        ? Amount.fromJSON(object.distributeAmount)
        : undefined,
      balanceAmount: isSet(object.balanceAmount)
        ? Amount.fromJSON(object.balanceAmount)
        : undefined,
      isLimitOver: isSet(object.isLimitOver)
        ? globalThis.Boolean(object.isLimitOver)
        : false,
    };
  },

  toJSON(message: DistributeResult): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.lake !== 0) {
      obj.lake = message.lake;
    }
    if (message.lakeAmount !== '') {
      obj.lakeAmount = message.lakeAmount;
    }
    if (message.distributeAmount !== undefined) {
      obj.distributeAmount = Amount.toJSON(message.distributeAmount);
    }
    if (message.balanceAmount !== undefined) {
      obj.balanceAmount = Amount.toJSON(message.balanceAmount);
    }
    if (message.isLimitOver !== false) {
      obj.isLimitOver = message.isLimitOver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistributeResult>, I>>(
    base?: I,
  ): DistributeResult {
    return DistributeResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistributeResult>, I>>(
    object: I,
  ): DistributeResult {
    const message = createBaseDistributeResult();
    message.accountId = object.accountId ?? '';
    message.type = object.type ?? '';
    message.lake = object.lake ?? 0;
    message.lakeAmount = object.lakeAmount ?? '';
    message.distributeAmount =
      object.distributeAmount !== undefined && object.distributeAmount !== null
        ? Amount.fromPartial(object.distributeAmount)
        : undefined;
    message.balanceAmount =
      object.balanceAmount !== undefined && object.balanceAmount !== null
        ? Amount.fromPartial(object.balanceAmount)
        : undefined;
    message.isLimitOver = object.isLimitOver ?? false;
    return message;
  },
};

function createBaseDistributeResponse(): DistributeResponse {
  return { success: false, errorMessage: '', result: [] };
}

export const DistributeResponse = {
  encode(
    message: DistributeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.result) {
      DistributeResult.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DistributeResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.result.push(DistributeResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistributeResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => DistributeResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DistributeResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.result?.length) {
      obj.result = message.result.map(e => DistributeResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistributeResponse>, I>>(
    base?: I,
  ): DistributeResponse {
    return DistributeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistributeResponse>, I>>(
    object: I,
  ): DistributeResponse {
    const message = createBaseDistributeResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.result =
      object.result?.map(e => DistributeResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDistributeResultRequest(): DistributeResultRequest {
  return { potId: '', accountId: '' };
}

export const DistributeResultRequest = {
  encode(
    message: DistributeResultRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.potId !== '') {
      writer.uint32(10).string(message.potId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DistributeResultRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistributeResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.potId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistributeResultRequest {
    return {
      potId: isSet(object.potId) ? globalThis.String(object.potId) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
    };
  },

  toJSON(message: DistributeResultRequest): unknown {
    const obj: any = {};
    if (message.potId !== '') {
      obj.potId = message.potId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistributeResultRequest>, I>>(
    base?: I,
  ): DistributeResultRequest {
    return DistributeResultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistributeResultRequest>, I>>(
    object: I,
  ): DistributeResultRequest {
    const message = createBaseDistributeResultRequest();
    message.potId = object.potId ?? '';
    message.accountId = object.accountId ?? '';
    return message;
  },
};

function createBaseDistributeResultResponse(): DistributeResultResponse {
  return { success: false, errorMessage: '', result: undefined };
}

export const DistributeResultResponse = {
  encode(
    message: DistributeResultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.result !== undefined) {
      DistributeResult.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DistributeResultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistributeResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.result = DistributeResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistributeResultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      result: isSet(object.result)
        ? DistributeResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: DistributeResultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.result !== undefined) {
      obj.result = DistributeResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistributeResultResponse>, I>>(
    base?: I,
  ): DistributeResultResponse {
    return DistributeResultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistributeResultResponse>, I>>(
    object: I,
  ): DistributeResultResponse {
    const message = createBaseDistributeResultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.result =
      object.result !== undefined && object.result !== null
        ? DistributeResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseExceptRefundRequest(): ExceptRefundRequest {
  return { potId: '' };
}

export const ExceptRefundRequest = {
  encode(
    message: ExceptRefundRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.potId !== '') {
      writer.uint32(10).string(message.potId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ExceptRefundRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExceptRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.potId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExceptRefundRequest {
    return {
      potId: isSet(object.potId) ? globalThis.String(object.potId) : '',
    };
  },

  toJSON(message: ExceptRefundRequest): unknown {
    const obj: any = {};
    if (message.potId !== '') {
      obj.potId = message.potId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExceptRefundRequest>, I>>(
    base?: I,
  ): ExceptRefundRequest {
    return ExceptRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExceptRefundRequest>, I>>(
    object: I,
  ): ExceptRefundRequest {
    const message = createBaseExceptRefundRequest();
    message.potId = object.potId ?? '';
    return message;
  },
};

function createBaseExceptRefundResponse(): ExceptRefundResponse {
  return { success: false, errorMessage: '', txGroupId: '' };
}

export const ExceptRefundResponse = {
  encode(
    message: ExceptRefundResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.txGroupId !== '') {
      writer.uint32(26).string(message.txGroupId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ExceptRefundResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExceptRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txGroupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExceptRefundResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      txGroupId: isSet(object.txGroupId)
        ? globalThis.String(object.txGroupId)
        : '',
    };
  },

  toJSON(message: ExceptRefundResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.txGroupId !== '') {
      obj.txGroupId = message.txGroupId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExceptRefundResponse>, I>>(
    base?: I,
  ): ExceptRefundResponse {
    return ExceptRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExceptRefundResponse>, I>>(
    object: I,
  ): ExceptRefundResponse {
    const message = createBaseExceptRefundResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.txGroupId = object.txGroupId ?? '';
    return message;
  },
};

function createBaseCreateDefaultDailyBalanceRequest(): CreateDefaultDailyBalanceRequest {
  return { userId: '', lossLimit: '' };
}

export const CreateDefaultDailyBalanceRequest = {
  encode(
    message: CreateDefaultDailyBalanceRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.lossLimit !== '') {
      writer.uint32(18).string(message.lossLimit);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateDefaultDailyBalanceRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDefaultDailyBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lossLimit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDefaultDailyBalanceRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      lossLimit: isSet(object.lossLimit)
        ? globalThis.String(object.lossLimit)
        : '',
    };
  },

  toJSON(message: CreateDefaultDailyBalanceRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.lossLimit !== '') {
      obj.lossLimit = message.lossLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDefaultDailyBalanceRequest>, I>>(
    base?: I,
  ): CreateDefaultDailyBalanceRequest {
    return CreateDefaultDailyBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<CreateDefaultDailyBalanceRequest>, I>,
  >(object: I): CreateDefaultDailyBalanceRequest {
    const message = createBaseCreateDefaultDailyBalanceRequest();
    message.userId = object.userId ?? '';
    message.lossLimit = object.lossLimit ?? '';
    return message;
  },
};

function createBaseGetDailyFlowRequest(): GetDailyFlowRequest {
  return { userId: '' };
}

export const GetDailyFlowRequest = {
  encode(
    message: GetDailyFlowRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetDailyFlowRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDailyFlowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDailyFlowRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: GetDailyFlowRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDailyFlowRequest>, I>>(
    base?: I,
  ): GetDailyFlowRequest {
    return GetDailyFlowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDailyFlowRequest>, I>>(
    object: I,
  ): GetDailyFlowRequest {
    const message = createBaseGetDailyFlowRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseGetDailyFlowResponse(): GetDailyFlowResponse {
  return {
    success: false,
    errorMessage: '',
    in: '',
    out: '',
    total: '',
    limit: '',
    remain: '',
  };
}

export const GetDailyFlowResponse = {
  encode(
    message: GetDailyFlowResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.in !== '') {
      writer.uint32(26).string(message.in);
    }
    if (message.out !== '') {
      writer.uint32(34).string(message.out);
    }
    if (message.total !== '') {
      writer.uint32(42).string(message.total);
    }
    if (message.limit !== '') {
      writer.uint32(50).string(message.limit);
    }
    if (message.remain !== '') {
      writer.uint32(58).string(message.remain);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetDailyFlowResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDailyFlowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.in = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.out = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.total = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.limit = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.remain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDailyFlowResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      in: isSet(object.in) ? globalThis.String(object.in) : '',
      out: isSet(object.out) ? globalThis.String(object.out) : '',
      total: isSet(object.total) ? globalThis.String(object.total) : '',
      limit: isSet(object.limit) ? globalThis.String(object.limit) : '',
      remain: isSet(object.remain) ? globalThis.String(object.remain) : '',
    };
  },

  toJSON(message: GetDailyFlowResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.in !== '') {
      obj.in = message.in;
    }
    if (message.out !== '') {
      obj.out = message.out;
    }
    if (message.total !== '') {
      obj.total = message.total;
    }
    if (message.limit !== '') {
      obj.limit = message.limit;
    }
    if (message.remain !== '') {
      obj.remain = message.remain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDailyFlowResponse>, I>>(
    base?: I,
  ): GetDailyFlowResponse {
    return GetDailyFlowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDailyFlowResponse>, I>>(
    object: I,
  ): GetDailyFlowResponse {
    const message = createBaseGetDailyFlowResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.in = object.in ?? '';
    message.out = object.out ?? '';
    message.total = object.total ?? '';
    message.limit = object.limit ?? '';
    message.remain = object.remain ?? '';
    return message;
  },
};

function createBaseDailyFlowFromPostBoxRequest(): DailyFlowFromPostBoxRequest {
  return { accountId: '', cash: '', game: '' };
}

export const DailyFlowFromPostBoxRequest = {
  encode(
    message: DailyFlowFromPostBoxRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.cash !== '') {
      writer.uint32(18).string(message.cash);
    }
    if (message.game !== '') {
      writer.uint32(26).string(message.game);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DailyFlowFromPostBoxRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyFlowFromPostBoxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.game = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyFlowFromPostBoxRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      cash: isSet(object.cash) ? globalThis.String(object.cash) : '',
      game: isSet(object.game) ? globalThis.String(object.game) : '',
    };
  },

  toJSON(message: DailyFlowFromPostBoxRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.cash !== '') {
      obj.cash = message.cash;
    }
    if (message.game !== '') {
      obj.game = message.game;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DailyFlowFromPostBoxRequest>, I>>(
    base?: I,
  ): DailyFlowFromPostBoxRequest {
    return DailyFlowFromPostBoxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DailyFlowFromPostBoxRequest>, I>>(
    object: I,
  ): DailyFlowFromPostBoxRequest {
    const message = createBaseDailyFlowFromPostBoxRequest();
    message.accountId = object.accountId ?? '';
    message.cash = object.cash ?? '';
    message.game = object.game ?? '';
    return message;
  },
};

function createBaseDefaultResponse(): DefaultResponse {
  return { success: false, errorMessage: '' };
}

export const DefaultResponse = {
  encode(
    message: DefaultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: DefaultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    base?: I,
  ): DefaultResponse {
    return DefaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    object: I,
  ): DefaultResponse {
    const message = createBaseDefaultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

export type EconomyServiceService = typeof EconomyServiceService;
export const EconomyServiceService = {
  createBalance: {
    path: '/economy.EconomyService/CreateBalance',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountIdParam) =>
      Buffer.from(AccountIdParam.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountIdParam.decode(value),
    responseSerialize: (value: CreateBalanceResponse) =>
      Buffer.from(CreateBalanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateBalanceResponse.decode(value),
  },
  createMoneyBox: {
    path: '/economy.EconomyService/CreateMoneyBox',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountIdParam) =>
      Buffer.from(AccountIdParam.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountIdParam.decode(value),
    responseSerialize: (value: CreateMoneyBoxResponse) =>
      Buffer.from(CreateMoneyBoxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CreateMoneyBoxResponse.decode(value),
  },
  /** hand, box transport */
  getBalanceWithMoneyBox: {
    path: '/economy.EconomyService/GetBalanceWithMoneyBox',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountIdParam) =>
      Buffer.from(AccountIdParam.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountIdParam.decode(value),
    responseSerialize: (value: BalanceAndMoneyBoxResponse) =>
      Buffer.from(BalanceAndMoneyBoxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      BalanceAndMoneyBoxResponse.decode(value),
  },
  getBalance: {
    path: '/economy.EconomyService/GetBalance',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountIdParam) =>
      Buffer.from(AccountIdParam.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountIdParam.decode(value),
    responseSerialize: (value: BalanceAndMoneyBoxResponse) =>
      Buffer.from(BalanceAndMoneyBoxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      BalanceAndMoneyBoxResponse.decode(value),
  },
  getMoneyBox: {
    path: '/economy.EconomyService/GetMoneyBox',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountIdParam) =>
      Buffer.from(AccountIdParam.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountIdParam.decode(value),
    responseSerialize: (value: BalanceAndMoneyBoxResponse) =>
      Buffer.from(BalanceAndMoneyBoxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      BalanceAndMoneyBoxResponse.decode(value),
  },
  moneySafe: {
    path: '/economy.EconomyService/MoneySafe',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateMoneyBoxRequest) =>
      Buffer.from(UpdateMoneyBoxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateMoneyBoxRequest.decode(value),
    responseSerialize: (value: UpdateMoneyBoxResponse) =>
      Buffer.from(UpdateMoneyBoxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      UpdateMoneyBoxResponse.decode(value),
  },
  moneyUnSafe: {
    path: '/economy.EconomyService/MoneyUnSafe',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateMoneyBoxRequest) =>
      Buffer.from(UpdateMoneyBoxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateMoneyBoxRequest.decode(value),
    responseSerialize: (value: UpdateMoneyBoxResponse) =>
      Buffer.from(UpdateMoneyBoxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      UpdateMoneyBoxResponse.decode(value),
  },
  setBalanceAndMoneyBox: {
    path: '/economy.EconomyService/SetBalanceAndMoneyBox',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetBalanceAndMoneyBoxRequest) =>
      Buffer.from(SetBalanceAndMoneyBoxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      SetBalanceAndMoneyBoxRequest.decode(value),
    responseSerialize: (value: BalanceAndMoneyBoxResponse) =>
      Buffer.from(BalanceAndMoneyBoxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      BalanceAndMoneyBoxResponse.decode(value),
  },
  /** game */
  createPot: {
    path: '/economy.EconomyService/CreatePot',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePotRequest) =>
      Buffer.from(CreatePotRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePotRequest.decode(value),
    responseSerialize: (value: CreatePotResponse) =>
      Buffer.from(CreatePotResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreatePotResponse.decode(value),
  },
  bet: {
    path: '/economy.EconomyService/Bet',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BetRequest) =>
      Buffer.from(BetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BetRequest.decode(value),
    responseSerialize: (value: BetResponse) =>
      Buffer.from(BetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BetResponse.decode(value),
  },
  distribute: {
    path: '/economy.EconomyService/Distribute',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DistributeRequest) =>
      Buffer.from(DistributeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DistributeRequest.decode(value),
    responseSerialize: (value: DistributeResponse) =>
      Buffer.from(DistributeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DistributeResponse.decode(value),
  },
  distributeSpeedMode: {
    path: '/economy.EconomyService/DistributeSpeedMode',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DistributeRequest) =>
      Buffer.from(DistributeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DistributeRequest.decode(value),
    responseSerialize: (value: DistributeResponse) =>
      Buffer.from(DistributeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DistributeResponse.decode(value),
  },
  /** rpc DistributeResult(DistributeResultRequest) returns (DistributeResultResponse) {} // 팟 분배 결과 */
  distributeResult: {
    path: '/economy.EconomyService/DistributeResult',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DistributeResultRequest) =>
      Buffer.from(DistributeResultRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      DistributeResultRequest.decode(value),
    responseSerialize: (value: DistributeResponse) =>
      Buffer.from(DistributeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DistributeResponse.decode(value),
  },
  exceptRefund: {
    path: '/economy.EconomyService/ExceptRefund',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExceptRefundRequest) =>
      Buffer.from(ExceptRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExceptRefundRequest.decode(value),
    responseSerialize: (value: ExceptRefundResponse) =>
      Buffer.from(ExceptRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExceptRefundResponse.decode(value),
  },
  /** daily balance & loss limit */
  createDefaultDailyBalance: {
    path: '/economy.EconomyService/CreateDefaultDailyBalance',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateDefaultDailyBalanceRequest) =>
      Buffer.from(CreateDefaultDailyBalanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CreateDefaultDailyBalanceRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  getDailyFlow: {
    path: '/economy.EconomyService/GetDailyFlow',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDailyFlowRequest) =>
      Buffer.from(GetDailyFlowRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDailyFlowRequest.decode(value),
    responseSerialize: (value: GetDailyFlowResponse) =>
      Buffer.from(GetDailyFlowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDailyFlowResponse.decode(value),
  },
  dailyFlowFromPostBox: {
    path: '/economy.EconomyService/DailyFlowFromPostBox',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DailyFlowFromPostBoxRequest) =>
      Buffer.from(DailyFlowFromPostBoxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      DailyFlowFromPostBoxRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** util */
  transferIn: {
    path: '/economy.EconomyService/TransferIn',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferInRequest) =>
      Buffer.from(TransferInRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferInRequest.decode(value),
    responseSerialize: (value: TransferInResponse) =>
      Buffer.from(TransferInResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransferInResponse.decode(value),
  },
  /** admin */
  getAmountByAccountIds: {
    path: '/economy.EconomyService/GetAmountByAccountIds',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAmountByAccountIdsRequest) =>
      Buffer.from(GetAmountByAccountIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GetAmountByAccountIdsRequest.decode(value),
    responseSerialize: (value: GetAmountByAccountIdsResponse) =>
      Buffer.from(GetAmountByAccountIdsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetAmountByAccountIdsResponse.decode(value),
  },
} as const;

export interface EconomyServiceServer extends UntypedServiceImplementation {
  createBalance: handleUnaryCall<AccountIdParam, CreateBalanceResponse>;
  createMoneyBox: handleUnaryCall<AccountIdParam, CreateMoneyBoxResponse>;
  /** hand, box transport */
  getBalanceWithMoneyBox: handleUnaryCall<
    AccountIdParam,
    BalanceAndMoneyBoxResponse
  >;
  getBalance: handleUnaryCall<AccountIdParam, BalanceAndMoneyBoxResponse>;
  getMoneyBox: handleUnaryCall<AccountIdParam, BalanceAndMoneyBoxResponse>;
  moneySafe: handleUnaryCall<UpdateMoneyBoxRequest, UpdateMoneyBoxResponse>;
  moneyUnSafe: handleUnaryCall<UpdateMoneyBoxRequest, UpdateMoneyBoxResponse>;
  setBalanceAndMoneyBox: handleUnaryCall<
    SetBalanceAndMoneyBoxRequest,
    BalanceAndMoneyBoxResponse
  >;
  /** game */
  createPot: handleUnaryCall<CreatePotRequest, CreatePotResponse>;
  bet: handleUnaryCall<BetRequest, BetResponse>;
  distribute: handleUnaryCall<DistributeRequest, DistributeResponse>;
  distributeSpeedMode: handleUnaryCall<DistributeRequest, DistributeResponse>;
  /** rpc DistributeResult(DistributeResultRequest) returns (DistributeResultResponse) {} // 팟 분배 결과 */
  distributeResult: handleUnaryCall<
    DistributeResultRequest,
    DistributeResponse
  >;
  exceptRefund: handleUnaryCall<ExceptRefundRequest, ExceptRefundResponse>;
  /** daily balance & loss limit */
  createDefaultDailyBalance: handleUnaryCall<
    CreateDefaultDailyBalanceRequest,
    DefaultResponse
  >;
  getDailyFlow: handleUnaryCall<GetDailyFlowRequest, GetDailyFlowResponse>;
  dailyFlowFromPostBox: handleUnaryCall<
    DailyFlowFromPostBoxRequest,
    DefaultResponse
  >;
  /** util */
  transferIn: handleUnaryCall<TransferInRequest, TransferInResponse>;
  /** admin */
  getAmountByAccountIds: handleUnaryCall<
    GetAmountByAccountIdsRequest,
    GetAmountByAccountIdsResponse
  >;
}

export interface EconomyServiceClient extends Client {
  createBalance(
    request: AccountIdParam,
    callback: (
      error: ServiceError | null,
      response: CreateBalanceResponse,
    ) => void,
  ): ClientUnaryCall;
  createBalance(
    request: AccountIdParam,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CreateBalanceResponse,
    ) => void,
  ): ClientUnaryCall;
  createBalance(
    request: AccountIdParam,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CreateBalanceResponse,
    ) => void,
  ): ClientUnaryCall;
  createMoneyBox(
    request: AccountIdParam,
    callback: (
      error: ServiceError | null,
      response: CreateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  createMoneyBox(
    request: AccountIdParam,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CreateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  createMoneyBox(
    request: AccountIdParam,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CreateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  /** hand, box transport */
  getBalanceWithMoneyBox(
    request: AccountIdParam,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getBalanceWithMoneyBox(
    request: AccountIdParam,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getBalanceWithMoneyBox(
    request: AccountIdParam,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getBalance(
    request: AccountIdParam,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getBalance(
    request: AccountIdParam,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getBalance(
    request: AccountIdParam,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getMoneyBox(
    request: AccountIdParam,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getMoneyBox(
    request: AccountIdParam,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  getMoneyBox(
    request: AccountIdParam,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  moneySafe(
    request: UpdateMoneyBoxRequest,
    callback: (
      error: ServiceError | null,
      response: UpdateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  moneySafe(
    request: UpdateMoneyBoxRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: UpdateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  moneySafe(
    request: UpdateMoneyBoxRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: UpdateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  moneyUnSafe(
    request: UpdateMoneyBoxRequest,
    callback: (
      error: ServiceError | null,
      response: UpdateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  moneyUnSafe(
    request: UpdateMoneyBoxRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: UpdateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  moneyUnSafe(
    request: UpdateMoneyBoxRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: UpdateMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  setBalanceAndMoneyBox(
    request: SetBalanceAndMoneyBoxRequest,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  setBalanceAndMoneyBox(
    request: SetBalanceAndMoneyBoxRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  setBalanceAndMoneyBox(
    request: SetBalanceAndMoneyBoxRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: BalanceAndMoneyBoxResponse,
    ) => void,
  ): ClientUnaryCall;
  /** game */
  createPot(
    request: CreatePotRequest,
    callback: (error: ServiceError | null, response: CreatePotResponse) => void,
  ): ClientUnaryCall;
  createPot(
    request: CreatePotRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreatePotResponse) => void,
  ): ClientUnaryCall;
  createPot(
    request: CreatePotRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreatePotResponse) => void,
  ): ClientUnaryCall;
  bet(
    request: BetRequest,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  bet(
    request: BetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  bet(
    request: BetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BetResponse) => void,
  ): ClientUnaryCall;
  distribute(
    request: DistributeRequest,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  distribute(
    request: DistributeRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  distribute(
    request: DistributeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  distributeSpeedMode(
    request: DistributeRequest,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  distributeSpeedMode(
    request: DistributeRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  distributeSpeedMode(
    request: DistributeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  /** rpc DistributeResult(DistributeResultRequest) returns (DistributeResultResponse) {} // 팟 분배 결과 */
  distributeResult(
    request: DistributeResultRequest,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  distributeResult(
    request: DistributeResultRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  distributeResult(
    request: DistributeResultRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: DistributeResponse,
    ) => void,
  ): ClientUnaryCall;
  exceptRefund(
    request: ExceptRefundRequest,
    callback: (
      error: ServiceError | null,
      response: ExceptRefundResponse,
    ) => void,
  ): ClientUnaryCall;
  exceptRefund(
    request: ExceptRefundRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ExceptRefundResponse,
    ) => void,
  ): ClientUnaryCall;
  exceptRefund(
    request: ExceptRefundRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ExceptRefundResponse,
    ) => void,
  ): ClientUnaryCall;
  /** daily balance & loss limit */
  createDefaultDailyBalance(
    request: CreateDefaultDailyBalanceRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  createDefaultDailyBalance(
    request: CreateDefaultDailyBalanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  createDefaultDailyBalance(
    request: CreateDefaultDailyBalanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  getDailyFlow(
    request: GetDailyFlowRequest,
    callback: (
      error: ServiceError | null,
      response: GetDailyFlowResponse,
    ) => void,
  ): ClientUnaryCall;
  getDailyFlow(
    request: GetDailyFlowRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetDailyFlowResponse,
    ) => void,
  ): ClientUnaryCall;
  getDailyFlow(
    request: GetDailyFlowRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetDailyFlowResponse,
    ) => void,
  ): ClientUnaryCall;
  dailyFlowFromPostBox(
    request: DailyFlowFromPostBoxRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  dailyFlowFromPostBox(
    request: DailyFlowFromPostBoxRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  dailyFlowFromPostBox(
    request: DailyFlowFromPostBoxRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** util */
  transferIn(
    request: TransferInRequest,
    callback: (
      error: ServiceError | null,
      response: TransferInResponse,
    ) => void,
  ): ClientUnaryCall;
  transferIn(
    request: TransferInRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: TransferInResponse,
    ) => void,
  ): ClientUnaryCall;
  transferIn(
    request: TransferInRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: TransferInResponse,
    ) => void,
  ): ClientUnaryCall;
  /** admin */
  getAmountByAccountIds(
    request: GetAmountByAccountIdsRequest,
    callback: (
      error: ServiceError | null,
      response: GetAmountByAccountIdsResponse,
    ) => void,
  ): ClientUnaryCall;
  getAmountByAccountIds(
    request: GetAmountByAccountIdsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetAmountByAccountIdsResponse,
    ) => void,
  ): ClientUnaryCall;
  getAmountByAccountIds(
    request: GetAmountByAccountIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetAmountByAccountIdsResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const EconomyServiceClient = makeGenericClientConstructor(
  EconomyServiceService,
  'economy.EconomyService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): EconomyServiceClient;
  service: typeof EconomyServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
