// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v6.31.1
// source: item-common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';

export const protobufPackage = 'item';

export enum EffectApplyType {
  EFFECT_NONE = 0,
  /** EFFECT_NOT_EFFECTABLE - 효과 없음 */
  EFFECT_NOT_EFFECTABLE = 1,
  /** EFFECT_ON_ACQUIRE - 취득 시 즉시 적용 */
  EFFECT_ON_ACQUIRE = 2,
  /** EFFECT_ON_USE - 사용 시 적용 */
  EFFECT_ON_USE = 3,
  UNRECOGNIZED = -1,
}

export function effectApplyTypeFromJSON(object: any): EffectApplyType {
  switch (object) {
    case 0:
    case 'EFFECT_NONE':
      return EffectApplyType.EFFECT_NONE;
    case 1:
    case 'EFFECT_NOT_EFFECTABLE':
      return EffectApplyType.EFFECT_NOT_EFFECTABLE;
    case 2:
    case 'EFFECT_ON_ACQUIRE':
      return EffectApplyType.EFFECT_ON_ACQUIRE;
    case 3:
    case 'EFFECT_ON_USE':
      return EffectApplyType.EFFECT_ON_USE;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return EffectApplyType.UNRECOGNIZED;
  }
}

export function effectApplyTypeToJSON(object: EffectApplyType): string {
  switch (object) {
    case EffectApplyType.EFFECT_NONE:
      return 'EFFECT_NONE';
    case EffectApplyType.EFFECT_NOT_EFFECTABLE:
      return 'EFFECT_NOT_EFFECTABLE';
    case EffectApplyType.EFFECT_ON_ACQUIRE:
      return 'EFFECT_ON_ACQUIRE';
    case EffectApplyType.EFFECT_ON_USE:
      return 'EFFECT_ON_USE';
    case EffectApplyType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum SellingState {
  SELL_NONE = 0,
  /** SELL_ON_SALE - 판매중 */
  SELL_ON_SALE = 1,
  /** SELL_COMING_SOON - 판매 예정 */
  SELL_COMING_SOON = 2,
  /** SELL_PAUSED - 판매 일시 중지 */
  SELL_PAUSED = 3,
  /** SELL_END - 판매 종료 */
  SELL_END = 4,
  UNRECOGNIZED = -1,
}

export function sellingStateFromJSON(object: any): SellingState {
  switch (object) {
    case 0:
    case 'SELL_NONE':
      return SellingState.SELL_NONE;
    case 1:
    case 'SELL_ON_SALE':
      return SellingState.SELL_ON_SALE;
    case 2:
    case 'SELL_COMING_SOON':
      return SellingState.SELL_COMING_SOON;
    case 3:
    case 'SELL_PAUSED':
      return SellingState.SELL_PAUSED;
    case 4:
    case 'SELL_END':
      return SellingState.SELL_END;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return SellingState.UNRECOGNIZED;
  }
}

export function sellingStateToJSON(object: SellingState): string {
  switch (object) {
    case SellingState.SELL_NONE:
      return 'SELL_NONE';
    case SellingState.SELL_ON_SALE:
      return 'SELL_ON_SALE';
    case SellingState.SELL_COMING_SOON:
      return 'SELL_COMING_SOON';
    case SellingState.SELL_PAUSED:
      return 'SELL_PAUSED';
    case SellingState.SELL_END:
      return 'SELL_END';
    case SellingState.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum PostType {
  POST_NONE = 0,
  /** POST_SYSTEM - 시스템 메시지 */
  POST_SYSTEM = 1,
  /** POST_REWARD - 보상 */
  POST_REWARD = 2,
  /** POST_REFUND - 환불 */
  POST_REFUND = 3,
  /** POST_OVERFLOW - 소지금 넘침 */
  POST_OVERFLOW = 4,
  /** POST_GAME_OVERFLOW - 게임 취득 금액 넘침 */
  POST_GAME_OVERFLOW = 5,
  /** POST_INAPP_RECEIPT - 인앱 영수증 */
  POST_INAPP_RECEIPT = 6,
  /** POST_PURCHASE_RECEIPT - 구매 영수증 */
  POST_PURCHASE_RECEIPT = 7,
  /** POST_MESSAGE - 메시지 */
  POST_MESSAGE = 8,
  /** POST_TRANSFER - 이동 */
  POST_TRANSFER = 9,
  /** POST_OTHER - 기타 */
  POST_OTHER = 10,
  UNRECOGNIZED = -1,
}

export function postTypeFromJSON(object: any): PostType {
  switch (object) {
    case 0:
    case 'POST_NONE':
      return PostType.POST_NONE;
    case 1:
    case 'POST_SYSTEM':
      return PostType.POST_SYSTEM;
    case 2:
    case 'POST_REWARD':
      return PostType.POST_REWARD;
    case 3:
    case 'POST_REFUND':
      return PostType.POST_REFUND;
    case 4:
    case 'POST_OVERFLOW':
      return PostType.POST_OVERFLOW;
    case 5:
    case 'POST_GAME_OVERFLOW':
      return PostType.POST_GAME_OVERFLOW;
    case 6:
    case 'POST_INAPP_RECEIPT':
      return PostType.POST_INAPP_RECEIPT;
    case 7:
    case 'POST_PURCHASE_RECEIPT':
      return PostType.POST_PURCHASE_RECEIPT;
    case 8:
    case 'POST_MESSAGE':
      return PostType.POST_MESSAGE;
    case 9:
    case 'POST_TRANSFER':
      return PostType.POST_TRANSFER;
    case 10:
    case 'POST_OTHER':
      return PostType.POST_OTHER;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return PostType.UNRECOGNIZED;
  }
}

export function postTypeToJSON(object: PostType): string {
  switch (object) {
    case PostType.POST_NONE:
      return 'POST_NONE';
    case PostType.POST_SYSTEM:
      return 'POST_SYSTEM';
    case PostType.POST_REWARD:
      return 'POST_REWARD';
    case PostType.POST_REFUND:
      return 'POST_REFUND';
    case PostType.POST_OVERFLOW:
      return 'POST_OVERFLOW';
    case PostType.POST_GAME_OVERFLOW:
      return 'POST_GAME_OVERFLOW';
    case PostType.POST_INAPP_RECEIPT:
      return 'POST_INAPP_RECEIPT';
    case PostType.POST_PURCHASE_RECEIPT:
      return 'POST_PURCHASE_RECEIPT';
    case PostType.POST_MESSAGE:
      return 'POST_MESSAGE';
    case PostType.POST_TRANSFER:
      return 'POST_TRANSFER';
    case PostType.POST_OTHER:
      return 'POST_OTHER';
    case PostType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum PostBoxState {
  POST_BOX_NONE = 0,
  /** POST_BOX_NOT_OPEN - 미열람 */
  POST_BOX_NOT_OPEN = 1,
  /** POST_BOX_NOT_RECEIVED - 미수령 */
  POST_BOX_NOT_RECEIVED = 2,
  /** POST_BOX_SOME_RECEIVED - 일부 수령 */
  POST_BOX_SOME_RECEIVED = 3,
  /** POST_BOX_RECEIVED - 수령 */
  POST_BOX_RECEIVED = 4,
  /** POST_BOX_EXPIRED - 만료 */
  POST_BOX_EXPIRED = 5,
  UNRECOGNIZED = -1,
}

export function postBoxStateFromJSON(object: any): PostBoxState {
  switch (object) {
    case 0:
    case 'POST_BOX_NONE':
      return PostBoxState.POST_BOX_NONE;
    case 1:
    case 'POST_BOX_NOT_OPEN':
      return PostBoxState.POST_BOX_NOT_OPEN;
    case 2:
    case 'POST_BOX_NOT_RECEIVED':
      return PostBoxState.POST_BOX_NOT_RECEIVED;
    case 3:
    case 'POST_BOX_SOME_RECEIVED':
      return PostBoxState.POST_BOX_SOME_RECEIVED;
    case 4:
    case 'POST_BOX_RECEIVED':
      return PostBoxState.POST_BOX_RECEIVED;
    case 5:
    case 'POST_BOX_EXPIRED':
      return PostBoxState.POST_BOX_EXPIRED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return PostBoxState.UNRECOGNIZED;
  }
}

export function postBoxStateToJSON(object: PostBoxState): string {
  switch (object) {
    case PostBoxState.POST_BOX_NONE:
      return 'POST_BOX_NONE';
    case PostBoxState.POST_BOX_NOT_OPEN:
      return 'POST_BOX_NOT_OPEN';
    case PostBoxState.POST_BOX_NOT_RECEIVED:
      return 'POST_BOX_NOT_RECEIVED';
    case PostBoxState.POST_BOX_SOME_RECEIVED:
      return 'POST_BOX_SOME_RECEIVED';
    case PostBoxState.POST_BOX_RECEIVED:
      return 'POST_BOX_RECEIVED';
    case PostBoxState.POST_BOX_EXPIRED:
      return 'POST_BOX_EXPIRED';
    case PostBoxState.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum TransactionType {
  TX_NONE = 0,
  /** TX_USE - 사용 */
  TX_USE = 1,
  /** TX_INAPP_PURCHASE - inApp 구매 */
  TX_INAPP_PURCHASE = 2,
  /** TX_STORE_PURCHASE - 상점구매 */
  TX_STORE_PURCHASE = 3,
  /** TX_REWARD - 보상 */
  TX_REWARD = 4,
  /** TX_TRANSFER - 이동 */
  TX_TRANSFER = 5,
  /** TX_DESTROY - 파괴 */
  TX_DESTROY = 6,
  /** TX_DISCARD - 폐기, 만료 */
  TX_DISCARD = 7,
  /** TX_OTHER - 기타 */
  TX_OTHER = 8,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case 'TX_NONE':
      return TransactionType.TX_NONE;
    case 1:
    case 'TX_USE':
      return TransactionType.TX_USE;
    case 2:
    case 'TX_INAPP_PURCHASE':
      return TransactionType.TX_INAPP_PURCHASE;
    case 3:
    case 'TX_STORE_PURCHASE':
      return TransactionType.TX_STORE_PURCHASE;
    case 4:
    case 'TX_REWARD':
      return TransactionType.TX_REWARD;
    case 5:
    case 'TX_TRANSFER':
      return TransactionType.TX_TRANSFER;
    case 6:
    case 'TX_DESTROY':
      return TransactionType.TX_DESTROY;
    case 7:
    case 'TX_DISCARD':
      return TransactionType.TX_DISCARD;
    case 8:
    case 'TX_OTHER':
      return TransactionType.TX_OTHER;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.TX_NONE:
      return 'TX_NONE';
    case TransactionType.TX_USE:
      return 'TX_USE';
    case TransactionType.TX_INAPP_PURCHASE:
      return 'TX_INAPP_PURCHASE';
    case TransactionType.TX_STORE_PURCHASE:
      return 'TX_STORE_PURCHASE';
    case TransactionType.TX_REWARD:
      return 'TX_REWARD';
    case TransactionType.TX_TRANSFER:
      return 'TX_TRANSFER';
    case TransactionType.TX_DESTROY:
      return 'TX_DESTROY';
    case TransactionType.TX_DISCARD:
      return 'TX_DISCARD';
    case TransactionType.TX_OTHER:
      return 'TX_OTHER';
    case TransactionType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface Amount {
  game: string;
  cash: string;
}

export interface ItemType {
  itemTypeId: string;
  name: string;
  description: string;
  image: string;
  metadata: string;
  createdAt: string;
  updatedAt: string;
}

export interface Item {
  itemId: string;
  itemTypeId: string;
  name: string;
  description: string;
  imageUrl: string;
  metadata: string;
  /** bigint */
  price: string;
  currency: string;
  /** 효과 지속 시간 (초) | null 이면 영구 적용 */
  effectDuration: number;
  /** 효과 적용 방식 */
  effectApplyType: EffectApplyType;
  /** 일일 취득 제한 횟수 | 0 이면 무제한 */
  acquireLimitByDay: number;
  /** 주간 취득 제한 횟수 | 0 이면 무제한 */
  acquireLimitByWeek: number;
  /** 월간 취득 제한 횟수 | 0 이면 무제한 */
  acquireLimitByMonth: number;
  /** 일일 사용 제한 횟수 | 0 이면 무제한 */
  useLimitByDay: number;
  /** 주간 사용 제한 횟수 | 0 이면 무제한 */
  useLimitByWeek: number;
  /** 월간 사용 제한 횟수 | 0 이면 무제한 */
  useLimitByMonth: number;
  /** 소모성 여부 */
  isConsumable: boolean;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  paymentType?: string | undefined;
}

export interface ItemPack {
  itemPackId: string;
  name: string;
  description: string;
  imageUrl: string;
  metadata: string;
  /** 구매 시 사용할 인앱 상품 ID */
  inAppItemId: string;
  currency: string;
  /** bigint */
  price: string;
  /** bigint */
  totalPrice: string;
  /** 할인율 */
  discount: number;
  /** 증가율 : 패키지 구매 시 얼마나 이득인지 표시 */
  gainPercent: number;
  /** 판매 형태 | 판매중, 판매 예정, 판매 일시 중지, 판매 종료 */
  sellingState: SellingState;
  /** 판매 시작 시간 | null 이면 즉시 판매 가능 */
  sellingStartAt: string;
  /** 판매 기간 (초) | null 이면 무제한 판매 */
  sellingDuration: number;
  /** 판매 종료 시간 | null 이면 무제한 판매 */
  sellingEndAt: string;
  /** 일일 구매 제한 횟수 | 0 이면 무제한 */
  buyLimitByDay: number;
  /** 주간 구매 제한 횟수 | 0 이면 무제한 */
  buyLimitByWeek: number;
  /** 월간 구매 제한 횟수 | 0 이면 무제한 */
  buyLimitByMonth: number;
  /** 환불 가능 여부 */
  isRefundable: boolean;
  isActive: boolean;
  createdAt: string;
  elements: ItemPackElement[];
}

export interface ItemPackElement {
  itemPackElementId: number;
  itemPackId: string;
  childPackId: string;
  itemId: string;
  /** bigint */
  amount: string;
  order: number;
  createdAt: string;
  updatedAt: string;
  item?: Item | undefined;
  childPack?: ItemPack | undefined;
}

export interface InAppItem {
  inAppItemId: number;
  /** android, ios, web */
  platform: string;
  name: string;
  description: string;
  /** KRW, USD */
  currency: string;
  price: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface PostBox {
  postboxId: number;
  accountId: string;
  senderId: string;
  message: string;
  itemPackId: string;
  itemId: string;
  amount: string;
  cash: string;
  game: string;
  type: PostType;
  state: PostBoxState;
  /** 노출 여부 | 삭제처리 */
  isVisible: boolean;
  /** 삭제 시간 */
  limitedAt: string;
  /** 열람 시간 */
  openedAt: string;
  /** 수령 시간 */
  receivedAt: string;
  createdAt: string;
  updatedAt: string;
}

export interface Inventory {
  inventoryId: number;
  accountId: string;
  itemId: string;
  itemTypeId: string;
  amount: number;
  /** 효과 적용 여부 */
  isEffective: boolean;
  /** 효과 적용 시작 시간 */
  effectStartAt: string;
  /** 효과 적용 갱신 시간 */
  effectUpdatedAt: string;
  /** 효과 적용 종료 시간 */
  effectEndAt: string;
  /** 총 효과 적용 시간 (초) */
  effectTotalTime: number;
  /** 일일 취득 수 */
  acquireByDay: number;
  /** 주간 취득 수 */
  acquireByWeek: number;
  /** 월간 취득 수 */
  acquireByMonth: number;
  /** 총 취득 수 */
  acquireTotal: number;
  /** 마지막 취득 시간 */
  lastAcquiredAt: string;
  /** 일일 사용 수 */
  useByDay: number;
  /** 주간 사용 수 */
  useByWeek: number;
  /** 월간 사용 수 */
  useByMonth: number;
  /** 총 사용 수 */
  useTotal: number;
  /** 마지막 사용 시간 */
  lastUsedAt: string;
  createdAt: string;
  updatedAt: string;
  item?: Item | undefined;
}

export interface Reward {
  rewardId: string;
  rewardType: string;
  name: string;
  description: string;
  value: string;
  condition: string;
  createdAt: string;
  updatedAt: string;
}

export interface PaidReward {
  txGroupId: string;
  transactionId: string;
  rewardId: string;
  rewardType: string;
  paidAt: string;
}

export interface DefaultStringIdRequest {
  id: string;
}

export interface DefaultIntIdRequest {
  id: number;
}

export interface DefaultResponse {
  success: boolean;
  errorMessage: string;
}

export interface EmptyRequest {}

export interface EmptyResponse {}

function createBaseAmount(): Amount {
  return { game: '', cash: '' };
}

export const Amount = {
  encode(
    message: Amount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.game !== '') {
      writer.uint32(10).string(message.game);
    }
    if (message.cash !== '') {
      writer.uint32(18).string(message.cash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Amount {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.game = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Amount {
    return {
      game: isSet(object.game) ? globalThis.String(object.game) : '',
      cash: isSet(object.cash) ? globalThis.String(object.cash) : '',
    };
  },

  toJSON(message: Amount): unknown {
    const obj: any = {};
    if (message.game !== '') {
      obj.game = message.game;
    }
    if (message.cash !== '') {
      obj.cash = message.cash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Amount>, I>>(base?: I): Amount {
    return Amount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Amount>, I>>(object: I): Amount {
    const message = createBaseAmount();
    message.game = object.game ?? '';
    message.cash = object.cash ?? '';
    return message;
  },
};

function createBaseItemType(): ItemType {
  return {
    itemTypeId: '',
    name: '',
    description: '',
    image: '',
    metadata: '',
    createdAt: '',
    updatedAt: '',
  };
}

export const ItemType = {
  encode(
    message: ItemType,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemTypeId !== '') {
      writer.uint32(10).string(message.itemTypeId);
    }
    if (message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(26).string(message.description);
    }
    if (message.image !== '') {
      writer.uint32(34).string(message.image);
    }
    if (message.metadata !== '') {
      writer.uint32(42).string(message.metadata);
    }
    if (message.createdAt !== '') {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemType {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemTypeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemType {
    return {
      itemTypeId: isSet(object.itemTypeId)
        ? globalThis.String(object.itemTypeId)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      image: isSet(object.image) ? globalThis.String(object.image) : '',
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
    };
  },

  toJSON(message: ItemType): unknown {
    const obj: any = {};
    if (message.itemTypeId !== '') {
      obj.itemTypeId = message.itemTypeId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.image !== '') {
      obj.image = message.image;
    }
    if (message.metadata !== '') {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemType>, I>>(base?: I): ItemType {
    return ItemType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemType>, I>>(object: I): ItemType {
    const message = createBaseItemType();
    message.itemTypeId = object.itemTypeId ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.image = object.image ?? '';
    message.metadata = object.metadata ?? '';
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    return message;
  },
};

function createBaseItem(): Item {
  return {
    itemId: '',
    itemTypeId: '',
    name: '',
    description: '',
    imageUrl: '',
    metadata: '',
    price: '',
    currency: '',
    effectDuration: 0,
    effectApplyType: 0,
    acquireLimitByDay: 0,
    acquireLimitByWeek: 0,
    acquireLimitByMonth: 0,
    useLimitByDay: 0,
    useLimitByWeek: 0,
    useLimitByMonth: 0,
    isConsumable: false,
    isActive: false,
    createdAt: '',
    updatedAt: '',
    paymentType: undefined,
  };
}

export const Item = {
  encode(
    message: Item,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemId !== '') {
      writer.uint32(10).string(message.itemId);
    }
    if (message.itemTypeId !== '') {
      writer.uint32(18).string(message.itemTypeId);
    }
    if (message.name !== '') {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(34).string(message.description);
    }
    if (message.imageUrl !== '') {
      writer.uint32(42).string(message.imageUrl);
    }
    if (message.metadata !== '') {
      writer.uint32(50).string(message.metadata);
    }
    if (message.price !== '') {
      writer.uint32(58).string(message.price);
    }
    if (message.currency !== '') {
      writer.uint32(66).string(message.currency);
    }
    if (message.effectDuration !== 0) {
      writer.uint32(72).int32(message.effectDuration);
    }
    if (message.effectApplyType !== 0) {
      writer.uint32(80).int32(message.effectApplyType);
    }
    if (message.acquireLimitByDay !== 0) {
      writer.uint32(88).int32(message.acquireLimitByDay);
    }
    if (message.acquireLimitByWeek !== 0) {
      writer.uint32(96).int32(message.acquireLimitByWeek);
    }
    if (message.acquireLimitByMonth !== 0) {
      writer.uint32(104).int32(message.acquireLimitByMonth);
    }
    if (message.useLimitByDay !== 0) {
      writer.uint32(112).int32(message.useLimitByDay);
    }
    if (message.useLimitByWeek !== 0) {
      writer.uint32(120).int32(message.useLimitByWeek);
    }
    if (message.useLimitByMonth !== 0) {
      writer.uint32(128).int32(message.useLimitByMonth);
    }
    if (message.isConsumable !== false) {
      writer.uint32(136).bool(message.isConsumable);
    }
    if (message.isActive !== false) {
      writer.uint32(144).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(154).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(162).string(message.updatedAt);
    }
    if (message.paymentType !== undefined) {
      writer.uint32(170).string(message.paymentType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Item {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.price = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.effectDuration = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.effectApplyType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.acquireLimitByDay = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.acquireLimitByWeek = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.acquireLimitByMonth = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.useLimitByDay = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.useLimitByWeek = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.useLimitByMonth = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.isConsumable = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.paymentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Item {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      itemTypeId: isSet(object.itemTypeId)
        ? globalThis.String(object.itemTypeId)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      imageUrl: isSet(object.imageUrl)
        ? globalThis.String(object.imageUrl)
        : '',
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : '',
      price: isSet(object.price) ? globalThis.String(object.price) : '',
      currency: isSet(object.currency)
        ? globalThis.String(object.currency)
        : '',
      effectDuration: isSet(object.effectDuration)
        ? globalThis.Number(object.effectDuration)
        : 0,
      effectApplyType: isSet(object.effectApplyType)
        ? effectApplyTypeFromJSON(object.effectApplyType)
        : 0,
      acquireLimitByDay: isSet(object.acquireLimitByDay)
        ? globalThis.Number(object.acquireLimitByDay)
        : 0,
      acquireLimitByWeek: isSet(object.acquireLimitByWeek)
        ? globalThis.Number(object.acquireLimitByWeek)
        : 0,
      acquireLimitByMonth: isSet(object.acquireLimitByMonth)
        ? globalThis.Number(object.acquireLimitByMonth)
        : 0,
      useLimitByDay: isSet(object.useLimitByDay)
        ? globalThis.Number(object.useLimitByDay)
        : 0,
      useLimitByWeek: isSet(object.useLimitByWeek)
        ? globalThis.Number(object.useLimitByWeek)
        : 0,
      useLimitByMonth: isSet(object.useLimitByMonth)
        ? globalThis.Number(object.useLimitByMonth)
        : 0,
      isConsumable: isSet(object.isConsumable)
        ? globalThis.Boolean(object.isConsumable)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      paymentType: isSet(object.paymentType)
        ? globalThis.String(object.paymentType)
        : undefined,
    };
  },

  toJSON(message: Item): unknown {
    const obj: any = {};
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.itemTypeId !== '') {
      obj.itemTypeId = message.itemTypeId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.imageUrl !== '') {
      obj.imageUrl = message.imageUrl;
    }
    if (message.metadata !== '') {
      obj.metadata = message.metadata;
    }
    if (message.price !== '') {
      obj.price = message.price;
    }
    if (message.currency !== '') {
      obj.currency = message.currency;
    }
    if (message.effectDuration !== 0) {
      obj.effectDuration = Math.round(message.effectDuration);
    }
    if (message.effectApplyType !== 0) {
      obj.effectApplyType = effectApplyTypeToJSON(message.effectApplyType);
    }
    if (message.acquireLimitByDay !== 0) {
      obj.acquireLimitByDay = Math.round(message.acquireLimitByDay);
    }
    if (message.acquireLimitByWeek !== 0) {
      obj.acquireLimitByWeek = Math.round(message.acquireLimitByWeek);
    }
    if (message.acquireLimitByMonth !== 0) {
      obj.acquireLimitByMonth = Math.round(message.acquireLimitByMonth);
    }
    if (message.useLimitByDay !== 0) {
      obj.useLimitByDay = Math.round(message.useLimitByDay);
    }
    if (message.useLimitByWeek !== 0) {
      obj.useLimitByWeek = Math.round(message.useLimitByWeek);
    }
    if (message.useLimitByMonth !== 0) {
      obj.useLimitByMonth = Math.round(message.useLimitByMonth);
    }
    if (message.isConsumable !== false) {
      obj.isConsumable = message.isConsumable;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.paymentType !== undefined) {
      obj.paymentType = message.paymentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Item>, I>>(base?: I): Item {
    return Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Item>, I>>(object: I): Item {
    const message = createBaseItem();
    message.itemId = object.itemId ?? '';
    message.itemTypeId = object.itemTypeId ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.imageUrl = object.imageUrl ?? '';
    message.metadata = object.metadata ?? '';
    message.price = object.price ?? '';
    message.currency = object.currency ?? '';
    message.effectDuration = object.effectDuration ?? 0;
    message.effectApplyType = object.effectApplyType ?? 0;
    message.acquireLimitByDay = object.acquireLimitByDay ?? 0;
    message.acquireLimitByWeek = object.acquireLimitByWeek ?? 0;
    message.acquireLimitByMonth = object.acquireLimitByMonth ?? 0;
    message.useLimitByDay = object.useLimitByDay ?? 0;
    message.useLimitByWeek = object.useLimitByWeek ?? 0;
    message.useLimitByMonth = object.useLimitByMonth ?? 0;
    message.isConsumable = object.isConsumable ?? false;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.paymentType = object.paymentType ?? undefined;
    return message;
  },
};

function createBaseItemPack(): ItemPack {
  return {
    itemPackId: '',
    name: '',
    description: '',
    imageUrl: '',
    metadata: '',
    inAppItemId: '',
    currency: '',
    price: '',
    totalPrice: '',
    discount: 0,
    gainPercent: 0,
    sellingState: 0,
    sellingStartAt: '',
    sellingDuration: 0,
    sellingEndAt: '',
    buyLimitByDay: 0,
    buyLimitByWeek: 0,
    buyLimitByMonth: 0,
    isRefundable: false,
    isActive: false,
    createdAt: '',
    elements: [],
  };
}

export const ItemPack = {
  encode(
    message: ItemPack,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemPackId !== '') {
      writer.uint32(10).string(message.itemPackId);
    }
    if (message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(26).string(message.description);
    }
    if (message.imageUrl !== '') {
      writer.uint32(34).string(message.imageUrl);
    }
    if (message.metadata !== '') {
      writer.uint32(42).string(message.metadata);
    }
    if (message.inAppItemId !== '') {
      writer.uint32(50).string(message.inAppItemId);
    }
    if (message.currency !== '') {
      writer.uint32(58).string(message.currency);
    }
    if (message.price !== '') {
      writer.uint32(66).string(message.price);
    }
    if (message.totalPrice !== '') {
      writer.uint32(74).string(message.totalPrice);
    }
    if (message.discount !== 0) {
      writer.uint32(80).int32(message.discount);
    }
    if (message.gainPercent !== 0) {
      writer.uint32(88).int32(message.gainPercent);
    }
    if (message.sellingState !== 0) {
      writer.uint32(96).int32(message.sellingState);
    }
    if (message.sellingStartAt !== '') {
      writer.uint32(106).string(message.sellingStartAt);
    }
    if (message.sellingDuration !== 0) {
      writer.uint32(112).int32(message.sellingDuration);
    }
    if (message.sellingEndAt !== '') {
      writer.uint32(122).string(message.sellingEndAt);
    }
    if (message.buyLimitByDay !== 0) {
      writer.uint32(128).int32(message.buyLimitByDay);
    }
    if (message.buyLimitByWeek !== 0) {
      writer.uint32(136).int32(message.buyLimitByWeek);
    }
    if (message.buyLimitByMonth !== 0) {
      writer.uint32(144).int32(message.buyLimitByMonth);
    }
    if (message.isRefundable !== false) {
      writer.uint32(152).bool(message.isRefundable);
    }
    if (message.isActive !== false) {
      writer.uint32(160).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(170).string(message.createdAt);
    }
    for (const v of message.elements) {
      ItemPackElement.encode(v!, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemPack {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemPack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemPackId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inAppItemId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.price = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.totalPrice = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.discount = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.gainPercent = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.sellingState = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sellingStartAt = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.sellingDuration = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.sellingEndAt = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.buyLimitByDay = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.buyLimitByWeek = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.buyLimitByMonth = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.isRefundable = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.elements.push(
            ItemPackElement.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemPack {
    return {
      itemPackId: isSet(object.itemPackId)
        ? globalThis.String(object.itemPackId)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      imageUrl: isSet(object.imageUrl)
        ? globalThis.String(object.imageUrl)
        : '',
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : '',
      inAppItemId: isSet(object.inAppItemId)
        ? globalThis.String(object.inAppItemId)
        : '',
      currency: isSet(object.currency)
        ? globalThis.String(object.currency)
        : '',
      price: isSet(object.price) ? globalThis.String(object.price) : '',
      totalPrice: isSet(object.totalPrice)
        ? globalThis.String(object.totalPrice)
        : '',
      discount: isSet(object.discount) ? globalThis.Number(object.discount) : 0,
      gainPercent: isSet(object.gainPercent)
        ? globalThis.Number(object.gainPercent)
        : 0,
      sellingState: isSet(object.sellingState)
        ? sellingStateFromJSON(object.sellingState)
        : 0,
      sellingStartAt: isSet(object.sellingStartAt)
        ? globalThis.String(object.sellingStartAt)
        : '',
      sellingDuration: isSet(object.sellingDuration)
        ? globalThis.Number(object.sellingDuration)
        : 0,
      sellingEndAt: isSet(object.sellingEndAt)
        ? globalThis.String(object.sellingEndAt)
        : '',
      buyLimitByDay: isSet(object.buyLimitByDay)
        ? globalThis.Number(object.buyLimitByDay)
        : 0,
      buyLimitByWeek: isSet(object.buyLimitByWeek)
        ? globalThis.Number(object.buyLimitByWeek)
        : 0,
      buyLimitByMonth: isSet(object.buyLimitByMonth)
        ? globalThis.Number(object.buyLimitByMonth)
        : 0,
      isRefundable: isSet(object.isRefundable)
        ? globalThis.Boolean(object.isRefundable)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => ItemPackElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemPack): unknown {
    const obj: any = {};
    if (message.itemPackId !== '') {
      obj.itemPackId = message.itemPackId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.imageUrl !== '') {
      obj.imageUrl = message.imageUrl;
    }
    if (message.metadata !== '') {
      obj.metadata = message.metadata;
    }
    if (message.inAppItemId !== '') {
      obj.inAppItemId = message.inAppItemId;
    }
    if (message.currency !== '') {
      obj.currency = message.currency;
    }
    if (message.price !== '') {
      obj.price = message.price;
    }
    if (message.totalPrice !== '') {
      obj.totalPrice = message.totalPrice;
    }
    if (message.discount !== 0) {
      obj.discount = Math.round(message.discount);
    }
    if (message.gainPercent !== 0) {
      obj.gainPercent = Math.round(message.gainPercent);
    }
    if (message.sellingState !== 0) {
      obj.sellingState = sellingStateToJSON(message.sellingState);
    }
    if (message.sellingStartAt !== '') {
      obj.sellingStartAt = message.sellingStartAt;
    }
    if (message.sellingDuration !== 0) {
      obj.sellingDuration = Math.round(message.sellingDuration);
    }
    if (message.sellingEndAt !== '') {
      obj.sellingEndAt = message.sellingEndAt;
    }
    if (message.buyLimitByDay !== 0) {
      obj.buyLimitByDay = Math.round(message.buyLimitByDay);
    }
    if (message.buyLimitByWeek !== 0) {
      obj.buyLimitByWeek = Math.round(message.buyLimitByWeek);
    }
    if (message.buyLimitByMonth !== 0) {
      obj.buyLimitByMonth = Math.round(message.buyLimitByMonth);
    }
    if (message.isRefundable !== false) {
      obj.isRefundable = message.isRefundable;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.elements?.length) {
      obj.elements = message.elements.map(e => ItemPackElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemPack>, I>>(base?: I): ItemPack {
    return ItemPack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemPack>, I>>(object: I): ItemPack {
    const message = createBaseItemPack();
    message.itemPackId = object.itemPackId ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.imageUrl = object.imageUrl ?? '';
    message.metadata = object.metadata ?? '';
    message.inAppItemId = object.inAppItemId ?? '';
    message.currency = object.currency ?? '';
    message.price = object.price ?? '';
    message.totalPrice = object.totalPrice ?? '';
    message.discount = object.discount ?? 0;
    message.gainPercent = object.gainPercent ?? 0;
    message.sellingState = object.sellingState ?? 0;
    message.sellingStartAt = object.sellingStartAt ?? '';
    message.sellingDuration = object.sellingDuration ?? 0;
    message.sellingEndAt = object.sellingEndAt ?? '';
    message.buyLimitByDay = object.buyLimitByDay ?? 0;
    message.buyLimitByWeek = object.buyLimitByWeek ?? 0;
    message.buyLimitByMonth = object.buyLimitByMonth ?? 0;
    message.isRefundable = object.isRefundable ?? false;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.elements =
      object.elements?.map(e => ItemPackElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemPackElement(): ItemPackElement {
  return {
    itemPackElementId: 0,
    itemPackId: '',
    childPackId: '',
    itemId: '',
    amount: '',
    order: 0,
    createdAt: '',
    updatedAt: '',
    item: undefined,
    childPack: undefined,
  };
}

export const ItemPackElement = {
  encode(
    message: ItemPackElement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemPackElementId !== 0) {
      writer.uint32(8).int32(message.itemPackElementId);
    }
    if (message.itemPackId !== '') {
      writer.uint32(18).string(message.itemPackId);
    }
    if (message.childPackId !== '') {
      writer.uint32(26).string(message.childPackId);
    }
    if (message.itemId !== '') {
      writer.uint32(34).string(message.itemId);
    }
    if (message.amount !== '') {
      writer.uint32(42).string(message.amount);
    }
    if (message.order !== 0) {
      writer.uint32(48).int32(message.order);
    }
    if (message.createdAt !== '') {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(66).string(message.updatedAt);
    }
    if (message.item !== undefined) {
      Item.encode(message.item, writer.uint32(74).fork()).join();
    }
    if (message.childPack !== undefined) {
      ItemPack.encode(message.childPack, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemPackElement {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemPackElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemPackElementId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemPackId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.childPackId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.order = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.item = Item.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.childPack = ItemPack.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemPackElement {
    return {
      itemPackElementId: isSet(object.itemPackElementId)
        ? globalThis.Number(object.itemPackElementId)
        : 0,
      itemPackId: isSet(object.itemPackId)
        ? globalThis.String(object.itemPackId)
        : '',
      childPackId: isSet(object.childPackId)
        ? globalThis.String(object.childPackId)
        : '',
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      item: isSet(object.item) ? Item.fromJSON(object.item) : undefined,
      childPack: isSet(object.childPack)
        ? ItemPack.fromJSON(object.childPack)
        : undefined,
    };
  },

  toJSON(message: ItemPackElement): unknown {
    const obj: any = {};
    if (message.itemPackElementId !== 0) {
      obj.itemPackElementId = Math.round(message.itemPackElementId);
    }
    if (message.itemPackId !== '') {
      obj.itemPackId = message.itemPackId;
    }
    if (message.childPackId !== '') {
      obj.childPackId = message.childPackId;
    }
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.item !== undefined) {
      obj.item = Item.toJSON(message.item);
    }
    if (message.childPack !== undefined) {
      obj.childPack = ItemPack.toJSON(message.childPack);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemPackElement>, I>>(
    base?: I,
  ): ItemPackElement {
    return ItemPackElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemPackElement>, I>>(
    object: I,
  ): ItemPackElement {
    const message = createBaseItemPackElement();
    message.itemPackElementId = object.itemPackElementId ?? 0;
    message.itemPackId = object.itemPackId ?? '';
    message.childPackId = object.childPackId ?? '';
    message.itemId = object.itemId ?? '';
    message.amount = object.amount ?? '';
    message.order = object.order ?? 0;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.item =
      object.item !== undefined && object.item !== null
        ? Item.fromPartial(object.item)
        : undefined;
    message.childPack =
      object.childPack !== undefined && object.childPack !== null
        ? ItemPack.fromPartial(object.childPack)
        : undefined;
    return message;
  },
};

function createBaseInAppItem(): InAppItem {
  return {
    inAppItemId: 0,
    platform: '',
    name: '',
    description: '',
    currency: '',
    price: 0,
    isActive: false,
    createdAt: '',
    updatedAt: '',
  };
}

export const InAppItem = {
  encode(
    message: InAppItem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.inAppItemId !== 0) {
      writer.uint32(8).int32(message.inAppItemId);
    }
    if (message.platform !== '') {
      writer.uint32(18).string(message.platform);
    }
    if (message.name !== '') {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(34).string(message.description);
    }
    if (message.currency !== '') {
      writer.uint32(42).string(message.currency);
    }
    if (message.price !== 0) {
      writer.uint32(48).int32(message.price);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InAppItem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInAppItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inAppItemId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.platform = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.price = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InAppItem {
    return {
      inAppItemId: isSet(object.inAppItemId)
        ? globalThis.Number(object.inAppItemId)
        : 0,
      platform: isSet(object.platform)
        ? globalThis.String(object.platform)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      currency: isSet(object.currency)
        ? globalThis.String(object.currency)
        : '',
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
    };
  },

  toJSON(message: InAppItem): unknown {
    const obj: any = {};
    if (message.inAppItemId !== 0) {
      obj.inAppItemId = Math.round(message.inAppItemId);
    }
    if (message.platform !== '') {
      obj.platform = message.platform;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.currency !== '') {
      obj.currency = message.currency;
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InAppItem>, I>>(base?: I): InAppItem {
    return InAppItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InAppItem>, I>>(
    object: I,
  ): InAppItem {
    const message = createBaseInAppItem();
    message.inAppItemId = object.inAppItemId ?? 0;
    message.platform = object.platform ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.currency = object.currency ?? '';
    message.price = object.price ?? 0;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    return message;
  },
};

function createBasePostBox(): PostBox {
  return {
    postboxId: 0,
    accountId: '',
    senderId: '',
    message: '',
    itemPackId: '',
    itemId: '',
    amount: '',
    cash: '',
    game: '',
    type: 0,
    state: 0,
    isVisible: false,
    limitedAt: '',
    openedAt: '',
    receivedAt: '',
    createdAt: '',
    updatedAt: '',
  };
}

export const PostBox = {
  encode(
    message: PostBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.postboxId !== 0) {
      writer.uint32(8).int32(message.postboxId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.senderId !== '') {
      writer.uint32(26).string(message.senderId);
    }
    if (message.message !== '') {
      writer.uint32(34).string(message.message);
    }
    if (message.itemPackId !== '') {
      writer.uint32(42).string(message.itemPackId);
    }
    if (message.itemId !== '') {
      writer.uint32(50).string(message.itemId);
    }
    if (message.amount !== '') {
      writer.uint32(58).string(message.amount);
    }
    if (message.cash !== '') {
      writer.uint32(66).string(message.cash);
    }
    if (message.game !== '') {
      writer.uint32(74).string(message.game);
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(88).int32(message.state);
    }
    if (message.isVisible !== false) {
      writer.uint32(96).bool(message.isVisible);
    }
    if (message.limitedAt !== '') {
      writer.uint32(106).string(message.limitedAt);
    }
    if (message.openedAt !== '') {
      writer.uint32(114).string(message.openedAt);
    }
    if (message.receivedAt !== '') {
      writer.uint32(122).string(message.receivedAt);
    }
    if (message.createdAt !== '') {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(138).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostBox {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.postboxId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.senderId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.itemPackId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cash = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.game = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.limitedAt = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.openedAt = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostBox {
    return {
      postboxId: isSet(object.postboxId)
        ? globalThis.Number(object.postboxId)
        : 0,
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      senderId: isSet(object.senderId)
        ? globalThis.String(object.senderId)
        : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      itemPackId: isSet(object.itemPackId)
        ? globalThis.String(object.itemPackId)
        : '',
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
      cash: isSet(object.cash) ? globalThis.String(object.cash) : '',
      game: isSet(object.game) ? globalThis.String(object.game) : '',
      type: isSet(object.type) ? postTypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? postBoxStateFromJSON(object.state) : 0,
      isVisible: isSet(object.isVisible)
        ? globalThis.Boolean(object.isVisible)
        : false,
      limitedAt: isSet(object.limitedAt)
        ? globalThis.String(object.limitedAt)
        : '',
      openedAt: isSet(object.openedAt)
        ? globalThis.String(object.openedAt)
        : '',
      receivedAt: isSet(object.receivedAt)
        ? globalThis.String(object.receivedAt)
        : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
    };
  },

  toJSON(message: PostBox): unknown {
    const obj: any = {};
    if (message.postboxId !== 0) {
      obj.postboxId = Math.round(message.postboxId);
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.senderId !== '') {
      obj.senderId = message.senderId;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.itemPackId !== '') {
      obj.itemPackId = message.itemPackId;
    }
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    if (message.cash !== '') {
      obj.cash = message.cash;
    }
    if (message.game !== '') {
      obj.game = message.game;
    }
    if (message.type !== 0) {
      obj.type = postTypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = postBoxStateToJSON(message.state);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.limitedAt !== '') {
      obj.limitedAt = message.limitedAt;
    }
    if (message.openedAt !== '') {
      obj.openedAt = message.openedAt;
    }
    if (message.receivedAt !== '') {
      obj.receivedAt = message.receivedAt;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostBox>, I>>(base?: I): PostBox {
    return PostBox.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostBox>, I>>(object: I): PostBox {
    const message = createBasePostBox();
    message.postboxId = object.postboxId ?? 0;
    message.accountId = object.accountId ?? '';
    message.senderId = object.senderId ?? '';
    message.message = object.message ?? '';
    message.itemPackId = object.itemPackId ?? '';
    message.itemId = object.itemId ?? '';
    message.amount = object.amount ?? '';
    message.cash = object.cash ?? '';
    message.game = object.game ?? '';
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    message.isVisible = object.isVisible ?? false;
    message.limitedAt = object.limitedAt ?? '';
    message.openedAt = object.openedAt ?? '';
    message.receivedAt = object.receivedAt ?? '';
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    return message;
  },
};

function createBaseInventory(): Inventory {
  return {
    inventoryId: 0,
    accountId: '',
    itemId: '',
    itemTypeId: '',
    amount: 0,
    isEffective: false,
    effectStartAt: '',
    effectUpdatedAt: '',
    effectEndAt: '',
    effectTotalTime: 0,
    acquireByDay: 0,
    acquireByWeek: 0,
    acquireByMonth: 0,
    acquireTotal: 0,
    lastAcquiredAt: '',
    useByDay: 0,
    useByWeek: 0,
    useByMonth: 0,
    useTotal: 0,
    lastUsedAt: '',
    createdAt: '',
    updatedAt: '',
    item: undefined,
  };
}

export const Inventory = {
  encode(
    message: Inventory,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.inventoryId !== 0) {
      writer.uint32(8).int32(message.inventoryId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.itemId !== '') {
      writer.uint32(26).string(message.itemId);
    }
    if (message.itemTypeId !== '') {
      writer.uint32(34).string(message.itemTypeId);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int32(message.amount);
    }
    if (message.isEffective !== false) {
      writer.uint32(48).bool(message.isEffective);
    }
    if (message.effectStartAt !== '') {
      writer.uint32(58).string(message.effectStartAt);
    }
    if (message.effectUpdatedAt !== '') {
      writer.uint32(66).string(message.effectUpdatedAt);
    }
    if (message.effectEndAt !== '') {
      writer.uint32(74).string(message.effectEndAt);
    }
    if (message.effectTotalTime !== 0) {
      writer.uint32(80).int32(message.effectTotalTime);
    }
    if (message.acquireByDay !== 0) {
      writer.uint32(88).int32(message.acquireByDay);
    }
    if (message.acquireByWeek !== 0) {
      writer.uint32(96).int32(message.acquireByWeek);
    }
    if (message.acquireByMonth !== 0) {
      writer.uint32(104).int32(message.acquireByMonth);
    }
    if (message.acquireTotal !== 0) {
      writer.uint32(112).int32(message.acquireTotal);
    }
    if (message.lastAcquiredAt !== '') {
      writer.uint32(122).string(message.lastAcquiredAt);
    }
    if (message.useByDay !== 0) {
      writer.uint32(128).int32(message.useByDay);
    }
    if (message.useByWeek !== 0) {
      writer.uint32(136).int32(message.useByWeek);
    }
    if (message.useByMonth !== 0) {
      writer.uint32(144).int32(message.useByMonth);
    }
    if (message.useTotal !== 0) {
      writer.uint32(152).int32(message.useTotal);
    }
    if (message.lastUsedAt !== '') {
      writer.uint32(162).string(message.lastUsedAt);
    }
    if (message.createdAt !== '') {
      writer.uint32(170).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(178).string(message.updatedAt);
    }
    if (message.item !== undefined) {
      Item.encode(message.item, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Inventory {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inventoryId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.itemTypeId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.amount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isEffective = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.effectStartAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.effectUpdatedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.effectEndAt = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.effectTotalTime = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.acquireByDay = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.acquireByWeek = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.acquireByMonth = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.acquireTotal = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.lastAcquiredAt = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.useByDay = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.useByWeek = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.useByMonth = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.useTotal = reader.int32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.lastUsedAt = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.item = Item.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Inventory {
    return {
      inventoryId: isSet(object.inventoryId)
        ? globalThis.Number(object.inventoryId)
        : 0,
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      itemTypeId: isSet(object.itemTypeId)
        ? globalThis.String(object.itemTypeId)
        : '',
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      isEffective: isSet(object.isEffective)
        ? globalThis.Boolean(object.isEffective)
        : false,
      effectStartAt: isSet(object.effectStartAt)
        ? globalThis.String(object.effectStartAt)
        : '',
      effectUpdatedAt: isSet(object.effectUpdatedAt)
        ? globalThis.String(object.effectUpdatedAt)
        : '',
      effectEndAt: isSet(object.effectEndAt)
        ? globalThis.String(object.effectEndAt)
        : '',
      effectTotalTime: isSet(object.effectTotalTime)
        ? globalThis.Number(object.effectTotalTime)
        : 0,
      acquireByDay: isSet(object.acquireByDay)
        ? globalThis.Number(object.acquireByDay)
        : 0,
      acquireByWeek: isSet(object.acquireByWeek)
        ? globalThis.Number(object.acquireByWeek)
        : 0,
      acquireByMonth: isSet(object.acquireByMonth)
        ? globalThis.Number(object.acquireByMonth)
        : 0,
      acquireTotal: isSet(object.acquireTotal)
        ? globalThis.Number(object.acquireTotal)
        : 0,
      lastAcquiredAt: isSet(object.lastAcquiredAt)
        ? globalThis.String(object.lastAcquiredAt)
        : '',
      useByDay: isSet(object.useByDay) ? globalThis.Number(object.useByDay) : 0,
      useByWeek: isSet(object.useByWeek)
        ? globalThis.Number(object.useByWeek)
        : 0,
      useByMonth: isSet(object.useByMonth)
        ? globalThis.Number(object.useByMonth)
        : 0,
      useTotal: isSet(object.useTotal) ? globalThis.Number(object.useTotal) : 0,
      lastUsedAt: isSet(object.lastUsedAt)
        ? globalThis.String(object.lastUsedAt)
        : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      item: isSet(object.item) ? Item.fromJSON(object.item) : undefined,
    };
  },

  toJSON(message: Inventory): unknown {
    const obj: any = {};
    if (message.inventoryId !== 0) {
      obj.inventoryId = Math.round(message.inventoryId);
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.itemTypeId !== '') {
      obj.itemTypeId = message.itemTypeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.isEffective !== false) {
      obj.isEffective = message.isEffective;
    }
    if (message.effectStartAt !== '') {
      obj.effectStartAt = message.effectStartAt;
    }
    if (message.effectUpdatedAt !== '') {
      obj.effectUpdatedAt = message.effectUpdatedAt;
    }
    if (message.effectEndAt !== '') {
      obj.effectEndAt = message.effectEndAt;
    }
    if (message.effectTotalTime !== 0) {
      obj.effectTotalTime = Math.round(message.effectTotalTime);
    }
    if (message.acquireByDay !== 0) {
      obj.acquireByDay = Math.round(message.acquireByDay);
    }
    if (message.acquireByWeek !== 0) {
      obj.acquireByWeek = Math.round(message.acquireByWeek);
    }
    if (message.acquireByMonth !== 0) {
      obj.acquireByMonth = Math.round(message.acquireByMonth);
    }
    if (message.acquireTotal !== 0) {
      obj.acquireTotal = Math.round(message.acquireTotal);
    }
    if (message.lastAcquiredAt !== '') {
      obj.lastAcquiredAt = message.lastAcquiredAt;
    }
    if (message.useByDay !== 0) {
      obj.useByDay = Math.round(message.useByDay);
    }
    if (message.useByWeek !== 0) {
      obj.useByWeek = Math.round(message.useByWeek);
    }
    if (message.useByMonth !== 0) {
      obj.useByMonth = Math.round(message.useByMonth);
    }
    if (message.useTotal !== 0) {
      obj.useTotal = Math.round(message.useTotal);
    }
    if (message.lastUsedAt !== '') {
      obj.lastUsedAt = message.lastUsedAt;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.item !== undefined) {
      obj.item = Item.toJSON(message.item);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Inventory>, I>>(base?: I): Inventory {
    return Inventory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Inventory>, I>>(
    object: I,
  ): Inventory {
    const message = createBaseInventory();
    message.inventoryId = object.inventoryId ?? 0;
    message.accountId = object.accountId ?? '';
    message.itemId = object.itemId ?? '';
    message.itemTypeId = object.itemTypeId ?? '';
    message.amount = object.amount ?? 0;
    message.isEffective = object.isEffective ?? false;
    message.effectStartAt = object.effectStartAt ?? '';
    message.effectUpdatedAt = object.effectUpdatedAt ?? '';
    message.effectEndAt = object.effectEndAt ?? '';
    message.effectTotalTime = object.effectTotalTime ?? 0;
    message.acquireByDay = object.acquireByDay ?? 0;
    message.acquireByWeek = object.acquireByWeek ?? 0;
    message.acquireByMonth = object.acquireByMonth ?? 0;
    message.acquireTotal = object.acquireTotal ?? 0;
    message.lastAcquiredAt = object.lastAcquiredAt ?? '';
    message.useByDay = object.useByDay ?? 0;
    message.useByWeek = object.useByWeek ?? 0;
    message.useByMonth = object.useByMonth ?? 0;
    message.useTotal = object.useTotal ?? 0;
    message.lastUsedAt = object.lastUsedAt ?? '';
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.item =
      object.item !== undefined && object.item !== null
        ? Item.fromPartial(object.item)
        : undefined;
    return message;
  },
};

function createBaseReward(): Reward {
  return {
    rewardId: '',
    rewardType: '',
    name: '',
    description: '',
    value: '',
    condition: '',
    createdAt: '',
    updatedAt: '',
  };
}

export const Reward = {
  encode(
    message: Reward,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardId !== '') {
      writer.uint32(10).string(message.rewardId);
    }
    if (message.rewardType !== '') {
      writer.uint32(18).string(message.rewardType);
    }
    if (message.name !== '') {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(34).string(message.description);
    }
    if (message.value !== '') {
      writer.uint32(42).string(message.value);
    }
    if (message.condition !== '') {
      writer.uint32(50).string(message.condition);
    }
    if (message.createdAt !== '') {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reward {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rewardId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rewardType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.value = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reward {
    return {
      rewardId: isSet(object.rewardId)
        ? globalThis.String(object.rewardId)
        : '',
      rewardType: isSet(object.rewardType)
        ? globalThis.String(object.rewardType)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      value: isSet(object.value) ? globalThis.String(object.value) : '',
      condition: isSet(object.condition)
        ? globalThis.String(object.condition)
        : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
    };
  },

  toJSON(message: Reward): unknown {
    const obj: any = {};
    if (message.rewardId !== '') {
      obj.rewardId = message.rewardId;
    }
    if (message.rewardType !== '') {
      obj.rewardType = message.rewardType;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.value !== '') {
      obj.value = message.value;
    }
    if (message.condition !== '') {
      obj.condition = message.condition;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reward>, I>>(base?: I): Reward {
    return Reward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reward>, I>>(object: I): Reward {
    const message = createBaseReward();
    message.rewardId = object.rewardId ?? '';
    message.rewardType = object.rewardType ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.value = object.value ?? '';
    message.condition = object.condition ?? '';
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    return message;
  },
};

function createBasePaidReward(): PaidReward {
  return {
    txGroupId: '',
    transactionId: '',
    rewardId: '',
    rewardType: '',
    paidAt: '',
  };
}

export const PaidReward = {
  encode(
    message: PaidReward,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txGroupId !== '') {
      writer.uint32(10).string(message.txGroupId);
    }
    if (message.transactionId !== '') {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.rewardId !== '') {
      writer.uint32(26).string(message.rewardId);
    }
    if (message.rewardType !== '') {
      writer.uint32(34).string(message.rewardType);
    }
    if (message.paidAt !== '') {
      writer.uint32(42).string(message.paidAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaidReward {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaidReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txGroupId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rewardId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rewardType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paidAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaidReward {
    return {
      txGroupId: isSet(object.txGroupId)
        ? globalThis.String(object.txGroupId)
        : '',
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : '',
      rewardId: isSet(object.rewardId)
        ? globalThis.String(object.rewardId)
        : '',
      rewardType: isSet(object.rewardType)
        ? globalThis.String(object.rewardType)
        : '',
      paidAt: isSet(object.paidAt) ? globalThis.String(object.paidAt) : '',
    };
  },

  toJSON(message: PaidReward): unknown {
    const obj: any = {};
    if (message.txGroupId !== '') {
      obj.txGroupId = message.txGroupId;
    }
    if (message.transactionId !== '') {
      obj.transactionId = message.transactionId;
    }
    if (message.rewardId !== '') {
      obj.rewardId = message.rewardId;
    }
    if (message.rewardType !== '') {
      obj.rewardType = message.rewardType;
    }
    if (message.paidAt !== '') {
      obj.paidAt = message.paidAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaidReward>, I>>(base?: I): PaidReward {
    return PaidReward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaidReward>, I>>(
    object: I,
  ): PaidReward {
    const message = createBasePaidReward();
    message.txGroupId = object.txGroupId ?? '';
    message.transactionId = object.transactionId ?? '';
    message.rewardId = object.rewardId ?? '';
    message.rewardType = object.rewardType ?? '';
    message.paidAt = object.paidAt ?? '';
    return message;
  },
};

function createBaseDefaultStringIdRequest(): DefaultStringIdRequest {
  return { id: '' };
}

export const DefaultStringIdRequest = {
  encode(
    message: DefaultStringIdRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DefaultStringIdRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultStringIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultStringIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : '' };
  },

  toJSON(message: DefaultStringIdRequest): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultStringIdRequest>, I>>(
    base?: I,
  ): DefaultStringIdRequest {
    return DefaultStringIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultStringIdRequest>, I>>(
    object: I,
  ): DefaultStringIdRequest {
    const message = createBaseDefaultStringIdRequest();
    message.id = object.id ?? '';
    return message;
  },
};

function createBaseDefaultIntIdRequest(): DefaultIntIdRequest {
  return { id: 0 };
}

export const DefaultIntIdRequest = {
  encode(
    message: DefaultIntIdRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DefaultIntIdRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultIntIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultIntIdRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DefaultIntIdRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultIntIdRequest>, I>>(
    base?: I,
  ): DefaultIntIdRequest {
    return DefaultIntIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultIntIdRequest>, I>>(
    object: I,
  ): DefaultIntIdRequest {
    const message = createBaseDefaultIntIdRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseDefaultResponse(): DefaultResponse {
  return { success: false, errorMessage: '' };
}

export const DefaultResponse = {
  encode(
    message: DefaultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: DefaultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    base?: I,
  ): DefaultResponse {
    return DefaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    object: I,
  ): DefaultResponse {
    const message = createBaseDefaultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

function createBaseEmptyRequest(): EmptyRequest {
  return {};
}

export const EmptyRequest = {
  encode(
    _: EmptyRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EmptyRequest {
    return {};
  },

  toJSON(_: EmptyRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EmptyRequest>, I>>(
    base?: I,
  ): EmptyRequest {
    return EmptyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmptyRequest>, I>>(
    _: I,
  ): EmptyRequest {
    const message = createBaseEmptyRequest();
    return message;
  },
};

function createBaseEmptyResponse(): EmptyResponse {
  return {};
}

export const EmptyResponse = {
  encode(
    _: EmptyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EmptyResponse {
    return {};
  },

  toJSON(_: EmptyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EmptyResponse>, I>>(
    base?: I,
  ): EmptyResponse {
    return EmptyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmptyResponse>, I>>(
    _: I,
  ): EmptyResponse {
    const message = createBaseEmptyResponse();
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
