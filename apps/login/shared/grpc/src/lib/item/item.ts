// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: item.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import {
  DefaultIntIdRequest,
  DefaultResponse,
  DefaultStringIdRequest,
  EffectApplyType,
  effectApplyTypeFromJSON,
  effectApplyTypeToJSON,
  EmptyRequest,
  Item,
  ItemPack,
  ItemPackElement,
  ItemType,
  SellingState,
  sellingStateFromJSON,
  sellingStateToJSON,
} from './item-common';

export const protobufPackage = 'item';

export interface ItemTypeRequest {
  itemTypeId: string;
  name: string;
  description: string;
  image: string;
  meta: string;
}

export interface ItemTypeResponse {
  success: boolean;
  errorMessage: string;
  itemType?: ItemType | undefined;
}

export interface GetItemTypeResponse {
  success: boolean;
  errorMessage: string;
  itemType: ItemType[];
}

export interface ItemRequest {
  itemId: string;
  itemTypeId: string;
  name: string;
  description: string;
  imageUrl: string;
  metadata: string;
  /** bigint */
  price: string;
  currency: string;
  /** 효과 지속 시간 (초) | null 이면 영구 적용 */
  effectDuration: number;
  /** 효과 적용 방식 */
  effectApplyType: EffectApplyType;
  /** 일일 취득 제한 횟수 | 0 이면 무제한 */
  acquireLimitByDay: number;
  /** 주간 취득 제한 횟수 | 0 이면 무제한 */
  acquireLimitByWeek: number;
  /** 월간 취득 제한 횟수 | 0 이면 무제한 */
  acquireLimitByMonth: number;
  /** 일일 사용 제한 횟수 | 0 이면 무제한 */
  useLimitByDay: number;
  /** 주간 사용 제한 횟수 | 0 이면 무제한 */
  useLimitByWeek: number;
  /** 월간 사용 제한 횟수 | 0 이면 무제한 */
  useLimitByMonth: number;
  /** 소모성 여부 */
  isConsumable: boolean;
  isActive: boolean;
  page: number;
  countPerPage: number;
}

export interface ItemResponse {
  success: boolean;
  errorMessage: string;
  item?: Item | undefined;
}

export interface ItemsRequest {
  itemId: string[];
}

export interface ItemsResponse {
  success: boolean;
  errorMessage: string;
  item: Item[];
}

export interface ItemPackRequest {
  itemPackId: string;
  name: string;
  description: string;
  imageUrl: string;
  metadata: string;
  /** 구매 시 사용할 인앱 상품 ID */
  inAppItemId: string;
  currency: string;
  /** bigint */
  price: string;
  /** bigint */
  totalPrice: string;
  /** 할인율 */
  discount: number;
  /** 증가율 : 패키지 구매 시 얼마나 이득인지 표시 */
  gainPercent: number;
  /** 판매 형태 | 판매중, 판매 예정, 판매 일시 중지, 판매 종료 */
  sellingState: SellingState;
  /** 판매 시작 시간 | null 이면 즉시 판매 가능 */
  sellingStartAt: string;
  /** 판매 기간 (초) | null 이면 무제한 판매 */
  sellingDuration: number;
  /** 판매 종료 시간 | null 이면 무제한 판매 */
  sellingEndAt: string;
  /** 일일 구매 제한 횟수 | 0 이면 무제한 */
  buyLimitByDay: number;
  /** 주간 구매 제한 횟수 | 0 이면 무제한 */
  buyLimitByWeek: number;
  /** 월간 구매 제한 횟수 | 0 이면 무제한 */
  buyLimitByMonth: number;
  /** 환불 가능 여부 */
  isRefundable: boolean;
  isActive: boolean;
  page: number;
  countPerPage: number;
}

export interface ItemPackResponse {
  success: boolean;
  errorMessage: string;
  itemPack?: ItemPack | undefined;
}

export interface ItemPackElementRequest {
  itemPackElementId: number;
  itemPackId: string;
  childPackId: string;
  itemId: string;
  amount: string;
  order: number;
}

export interface ItemPackElementResponse {
  success: boolean;
  errorMessage: string;
  itemPackElement?: ItemPackElement | undefined;
}

export interface GetItemPacksRequest {
  itemPackId: string[];
}

export interface ItemPacksResponse {
  success: boolean;
  errorMessage: string;
  itemPack: ItemPack[];
}

export interface AdminGetRequest {
  page: number;
  countPerPage: number;
  isActive: boolean;
}

function createBaseItemTypeRequest(): ItemTypeRequest {
  return { itemTypeId: '', name: '', description: '', image: '', meta: '' };
}

export const ItemTypeRequest = {
  encode(
    message: ItemTypeRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemTypeId !== '') {
      writer.uint32(10).string(message.itemTypeId);
    }
    if (message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(26).string(message.description);
    }
    if (message.image !== '') {
      writer.uint32(34).string(message.image);
    }
    if (message.meta !== '') {
      writer.uint32(42).string(message.meta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemTypeRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemTypeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.meta = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemTypeRequest {
    return {
      itemTypeId: isSet(object.itemTypeId)
        ? globalThis.String(object.itemTypeId)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      image: isSet(object.image) ? globalThis.String(object.image) : '',
      meta: isSet(object.meta) ? globalThis.String(object.meta) : '',
    };
  },

  toJSON(message: ItemTypeRequest): unknown {
    const obj: any = {};
    if (message.itemTypeId !== '') {
      obj.itemTypeId = message.itemTypeId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.image !== '') {
      obj.image = message.image;
    }
    if (message.meta !== '') {
      obj.meta = message.meta;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemTypeRequest>, I>>(
    base?: I,
  ): ItemTypeRequest {
    return ItemTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemTypeRequest>, I>>(
    object: I,
  ): ItemTypeRequest {
    const message = createBaseItemTypeRequest();
    message.itemTypeId = object.itemTypeId ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.image = object.image ?? '';
    message.meta = object.meta ?? '';
    return message;
  },
};

function createBaseItemTypeResponse(): ItemTypeResponse {
  return { success: false, errorMessage: '', itemType: undefined };
}

export const ItemTypeResponse = {
  encode(
    message: ItemTypeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.itemType !== undefined) {
      ItemType.encode(message.itemType, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemTypeResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemType = ItemType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemTypeResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      itemType: isSet(object.itemType)
        ? ItemType.fromJSON(object.itemType)
        : undefined,
    };
  },

  toJSON(message: ItemTypeResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.itemType !== undefined) {
      obj.itemType = ItemType.toJSON(message.itemType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemTypeResponse>, I>>(
    base?: I,
  ): ItemTypeResponse {
    return ItemTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemTypeResponse>, I>>(
    object: I,
  ): ItemTypeResponse {
    const message = createBaseItemTypeResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.itemType =
      object.itemType !== undefined && object.itemType !== null
        ? ItemType.fromPartial(object.itemType)
        : undefined;
    return message;
  },
};

function createBaseGetItemTypeResponse(): GetItemTypeResponse {
  return { success: false, errorMessage: '', itemType: [] };
}

export const GetItemTypeResponse = {
  encode(
    message: GetItemTypeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.itemType) {
      ItemType.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetItemTypeResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetItemTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemType.push(ItemType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetItemTypeResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      itemType: globalThis.Array.isArray(object?.itemType)
        ? object.itemType.map((e: any) => ItemType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetItemTypeResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.itemType?.length) {
      obj.itemType = message.itemType.map(e => ItemType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetItemTypeResponse>, I>>(
    base?: I,
  ): GetItemTypeResponse {
    return GetItemTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetItemTypeResponse>, I>>(
    object: I,
  ): GetItemTypeResponse {
    const message = createBaseGetItemTypeResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.itemType = object.itemType?.map(e => ItemType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemRequest(): ItemRequest {
  return {
    itemId: '',
    itemTypeId: '',
    name: '',
    description: '',
    imageUrl: '',
    metadata: '',
    price: '',
    currency: '',
    effectDuration: 0,
    effectApplyType: 0,
    acquireLimitByDay: 0,
    acquireLimitByWeek: 0,
    acquireLimitByMonth: 0,
    useLimitByDay: 0,
    useLimitByWeek: 0,
    useLimitByMonth: 0,
    isConsumable: false,
    isActive: false,
    page: 0,
    countPerPage: 0,
  };
}

export const ItemRequest = {
  encode(
    message: ItemRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemId !== '') {
      writer.uint32(10).string(message.itemId);
    }
    if (message.itemTypeId !== '') {
      writer.uint32(18).string(message.itemTypeId);
    }
    if (message.name !== '') {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(34).string(message.description);
    }
    if (message.imageUrl !== '') {
      writer.uint32(42).string(message.imageUrl);
    }
    if (message.metadata !== '') {
      writer.uint32(50).string(message.metadata);
    }
    if (message.price !== '') {
      writer.uint32(58).string(message.price);
    }
    if (message.currency !== '') {
      writer.uint32(66).string(message.currency);
    }
    if (message.effectDuration !== 0) {
      writer.uint32(72).int32(message.effectDuration);
    }
    if (message.effectApplyType !== 0) {
      writer.uint32(80).int32(message.effectApplyType);
    }
    if (message.acquireLimitByDay !== 0) {
      writer.uint32(88).int32(message.acquireLimitByDay);
    }
    if (message.acquireLimitByWeek !== 0) {
      writer.uint32(96).int32(message.acquireLimitByWeek);
    }
    if (message.acquireLimitByMonth !== 0) {
      writer.uint32(104).int32(message.acquireLimitByMonth);
    }
    if (message.useLimitByDay !== 0) {
      writer.uint32(112).int32(message.useLimitByDay);
    }
    if (message.useLimitByWeek !== 0) {
      writer.uint32(120).int32(message.useLimitByWeek);
    }
    if (message.useLimitByMonth !== 0) {
      writer.uint32(128).int32(message.useLimitByMonth);
    }
    if (message.isConsumable !== false) {
      writer.uint32(136).bool(message.isConsumable);
    }
    if (message.isActive !== false) {
      writer.uint32(144).bool(message.isActive);
    }
    if (message.page !== 0) {
      writer.uint32(152).int32(message.page);
    }
    if (message.countPerPage !== 0) {
      writer.uint32(160).int32(message.countPerPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.price = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.effectDuration = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.effectApplyType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.acquireLimitByDay = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.acquireLimitByWeek = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.acquireLimitByMonth = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.useLimitByDay = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.useLimitByWeek = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.useLimitByMonth = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.isConsumable = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.countPerPage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRequest {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      itemTypeId: isSet(object.itemTypeId)
        ? globalThis.String(object.itemTypeId)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      imageUrl: isSet(object.imageUrl)
        ? globalThis.String(object.imageUrl)
        : '',
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : '',
      price: isSet(object.price) ? globalThis.String(object.price) : '',
      currency: isSet(object.currency)
        ? globalThis.String(object.currency)
        : '',
      effectDuration: isSet(object.effectDuration)
        ? globalThis.Number(object.effectDuration)
        : 0,
      effectApplyType: isSet(object.effectApplyType)
        ? effectApplyTypeFromJSON(object.effectApplyType)
        : 0,
      acquireLimitByDay: isSet(object.acquireLimitByDay)
        ? globalThis.Number(object.acquireLimitByDay)
        : 0,
      acquireLimitByWeek: isSet(object.acquireLimitByWeek)
        ? globalThis.Number(object.acquireLimitByWeek)
        : 0,
      acquireLimitByMonth: isSet(object.acquireLimitByMonth)
        ? globalThis.Number(object.acquireLimitByMonth)
        : 0,
      useLimitByDay: isSet(object.useLimitByDay)
        ? globalThis.Number(object.useLimitByDay)
        : 0,
      useLimitByWeek: isSet(object.useLimitByWeek)
        ? globalThis.Number(object.useLimitByWeek)
        : 0,
      useLimitByMonth: isSet(object.useLimitByMonth)
        ? globalThis.Number(object.useLimitByMonth)
        : 0,
      isConsumable: isSet(object.isConsumable)
        ? globalThis.Boolean(object.isConsumable)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      countPerPage: isSet(object.countPerPage)
        ? globalThis.Number(object.countPerPage)
        : 0,
    };
  },

  toJSON(message: ItemRequest): unknown {
    const obj: any = {};
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.itemTypeId !== '') {
      obj.itemTypeId = message.itemTypeId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.imageUrl !== '') {
      obj.imageUrl = message.imageUrl;
    }
    if (message.metadata !== '') {
      obj.metadata = message.metadata;
    }
    if (message.price !== '') {
      obj.price = message.price;
    }
    if (message.currency !== '') {
      obj.currency = message.currency;
    }
    if (message.effectDuration !== 0) {
      obj.effectDuration = Math.round(message.effectDuration);
    }
    if (message.effectApplyType !== 0) {
      obj.effectApplyType = effectApplyTypeToJSON(message.effectApplyType);
    }
    if (message.acquireLimitByDay !== 0) {
      obj.acquireLimitByDay = Math.round(message.acquireLimitByDay);
    }
    if (message.acquireLimitByWeek !== 0) {
      obj.acquireLimitByWeek = Math.round(message.acquireLimitByWeek);
    }
    if (message.acquireLimitByMonth !== 0) {
      obj.acquireLimitByMonth = Math.round(message.acquireLimitByMonth);
    }
    if (message.useLimitByDay !== 0) {
      obj.useLimitByDay = Math.round(message.useLimitByDay);
    }
    if (message.useLimitByWeek !== 0) {
      obj.useLimitByWeek = Math.round(message.useLimitByWeek);
    }
    if (message.useLimitByMonth !== 0) {
      obj.useLimitByMonth = Math.round(message.useLimitByMonth);
    }
    if (message.isConsumable !== false) {
      obj.isConsumable = message.isConsumable;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.countPerPage !== 0) {
      obj.countPerPage = Math.round(message.countPerPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRequest>, I>>(base?: I): ItemRequest {
    return ItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRequest>, I>>(
    object: I,
  ): ItemRequest {
    const message = createBaseItemRequest();
    message.itemId = object.itemId ?? '';
    message.itemTypeId = object.itemTypeId ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.imageUrl = object.imageUrl ?? '';
    message.metadata = object.metadata ?? '';
    message.price = object.price ?? '';
    message.currency = object.currency ?? '';
    message.effectDuration = object.effectDuration ?? 0;
    message.effectApplyType = object.effectApplyType ?? 0;
    message.acquireLimitByDay = object.acquireLimitByDay ?? 0;
    message.acquireLimitByWeek = object.acquireLimitByWeek ?? 0;
    message.acquireLimitByMonth = object.acquireLimitByMonth ?? 0;
    message.useLimitByDay = object.useLimitByDay ?? 0;
    message.useLimitByWeek = object.useLimitByWeek ?? 0;
    message.useLimitByMonth = object.useLimitByMonth ?? 0;
    message.isConsumable = object.isConsumable ?? false;
    message.isActive = object.isActive ?? false;
    message.page = object.page ?? 0;
    message.countPerPage = object.countPerPage ?? 0;
    return message;
  },
};

function createBaseItemResponse(): ItemResponse {
  return { success: false, errorMessage: '', item: undefined };
}

export const ItemResponse = {
  encode(
    message: ItemResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.item !== undefined) {
      Item.encode(message.item, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.item = Item.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      item: isSet(object.item) ? Item.fromJSON(object.item) : undefined,
    };
  },

  toJSON(message: ItemResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.item !== undefined) {
      obj.item = Item.toJSON(message.item);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemResponse>, I>>(
    base?: I,
  ): ItemResponse {
    return ItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemResponse>, I>>(
    object: I,
  ): ItemResponse {
    const message = createBaseItemResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.item =
      object.item !== undefined && object.item !== null
        ? Item.fromPartial(object.item)
        : undefined;
    return message;
  },
};

function createBaseItemsRequest(): ItemsRequest {
  return { itemId: [] };
}

export const ItemsRequest = {
  encode(
    message: ItemsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.itemId) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemsRequest {
    return {
      itemId: globalThis.Array.isArray(object?.itemId)
        ? object.itemId.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ItemsRequest): unknown {
    const obj: any = {};
    if (message.itemId?.length) {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemsRequest>, I>>(
    base?: I,
  ): ItemsRequest {
    return ItemsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemsRequest>, I>>(
    object: I,
  ): ItemsRequest {
    const message = createBaseItemsRequest();
    message.itemId = object.itemId?.map(e => e) || [];
    return message;
  },
};

function createBaseItemsResponse(): ItemsResponse {
  return { success: false, errorMessage: '', item: [] };
}

export const ItemsResponse = {
  encode(
    message: ItemsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.item) {
      Item.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.item.push(Item.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      item: globalThis.Array.isArray(object?.item)
        ? object.item.map((e: any) => Item.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.item?.length) {
      obj.item = message.item.map(e => Item.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemsResponse>, I>>(
    base?: I,
  ): ItemsResponse {
    return ItemsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemsResponse>, I>>(
    object: I,
  ): ItemsResponse {
    const message = createBaseItemsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.item = object.item?.map(e => Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemPackRequest(): ItemPackRequest {
  return {
    itemPackId: '',
    name: '',
    description: '',
    imageUrl: '',
    metadata: '',
    inAppItemId: '',
    currency: '',
    price: '',
    totalPrice: '',
    discount: 0,
    gainPercent: 0,
    sellingState: 0,
    sellingStartAt: '',
    sellingDuration: 0,
    sellingEndAt: '',
    buyLimitByDay: 0,
    buyLimitByWeek: 0,
    buyLimitByMonth: 0,
    isRefundable: false,
    isActive: false,
    page: 0,
    countPerPage: 0,
  };
}

export const ItemPackRequest = {
  encode(
    message: ItemPackRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemPackId !== '') {
      writer.uint32(10).string(message.itemPackId);
    }
    if (message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(26).string(message.description);
    }
    if (message.imageUrl !== '') {
      writer.uint32(34).string(message.imageUrl);
    }
    if (message.metadata !== '') {
      writer.uint32(42).string(message.metadata);
    }
    if (message.inAppItemId !== '') {
      writer.uint32(50).string(message.inAppItemId);
    }
    if (message.currency !== '') {
      writer.uint32(58).string(message.currency);
    }
    if (message.price !== '') {
      writer.uint32(66).string(message.price);
    }
    if (message.totalPrice !== '') {
      writer.uint32(74).string(message.totalPrice);
    }
    if (message.discount !== 0) {
      writer.uint32(80).int32(message.discount);
    }
    if (message.gainPercent !== 0) {
      writer.uint32(88).int32(message.gainPercent);
    }
    if (message.sellingState !== 0) {
      writer.uint32(96).int32(message.sellingState);
    }
    if (message.sellingStartAt !== '') {
      writer.uint32(106).string(message.sellingStartAt);
    }
    if (message.sellingDuration !== 0) {
      writer.uint32(112).int32(message.sellingDuration);
    }
    if (message.sellingEndAt !== '') {
      writer.uint32(122).string(message.sellingEndAt);
    }
    if (message.buyLimitByDay !== 0) {
      writer.uint32(128).int32(message.buyLimitByDay);
    }
    if (message.buyLimitByWeek !== 0) {
      writer.uint32(136).int32(message.buyLimitByWeek);
    }
    if (message.buyLimitByMonth !== 0) {
      writer.uint32(144).int32(message.buyLimitByMonth);
    }
    if (message.isRefundable !== false) {
      writer.uint32(152).bool(message.isRefundable);
    }
    if (message.isActive !== false) {
      writer.uint32(160).bool(message.isActive);
    }
    if (message.page !== 0) {
      writer.uint32(168).int32(message.page);
    }
    if (message.countPerPage !== 0) {
      writer.uint32(176).int32(message.countPerPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemPackRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemPackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemPackId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inAppItemId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.price = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.totalPrice = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.discount = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.gainPercent = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.sellingState = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sellingStartAt = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.sellingDuration = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.sellingEndAt = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.buyLimitByDay = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.buyLimitByWeek = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.buyLimitByMonth = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.isRefundable = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.countPerPage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemPackRequest {
    return {
      itemPackId: isSet(object.itemPackId)
        ? globalThis.String(object.itemPackId)
        : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      imageUrl: isSet(object.imageUrl)
        ? globalThis.String(object.imageUrl)
        : '',
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : '',
      inAppItemId: isSet(object.inAppItemId)
        ? globalThis.String(object.inAppItemId)
        : '',
      currency: isSet(object.currency)
        ? globalThis.String(object.currency)
        : '',
      price: isSet(object.price) ? globalThis.String(object.price) : '',
      totalPrice: isSet(object.totalPrice)
        ? globalThis.String(object.totalPrice)
        : '',
      discount: isSet(object.discount) ? globalThis.Number(object.discount) : 0,
      gainPercent: isSet(object.gainPercent)
        ? globalThis.Number(object.gainPercent)
        : 0,
      sellingState: isSet(object.sellingState)
        ? sellingStateFromJSON(object.sellingState)
        : 0,
      sellingStartAt: isSet(object.sellingStartAt)
        ? globalThis.String(object.sellingStartAt)
        : '',
      sellingDuration: isSet(object.sellingDuration)
        ? globalThis.Number(object.sellingDuration)
        : 0,
      sellingEndAt: isSet(object.sellingEndAt)
        ? globalThis.String(object.sellingEndAt)
        : '',
      buyLimitByDay: isSet(object.buyLimitByDay)
        ? globalThis.Number(object.buyLimitByDay)
        : 0,
      buyLimitByWeek: isSet(object.buyLimitByWeek)
        ? globalThis.Number(object.buyLimitByWeek)
        : 0,
      buyLimitByMonth: isSet(object.buyLimitByMonth)
        ? globalThis.Number(object.buyLimitByMonth)
        : 0,
      isRefundable: isSet(object.isRefundable)
        ? globalThis.Boolean(object.isRefundable)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      countPerPage: isSet(object.countPerPage)
        ? globalThis.Number(object.countPerPage)
        : 0,
    };
  },

  toJSON(message: ItemPackRequest): unknown {
    const obj: any = {};
    if (message.itemPackId !== '') {
      obj.itemPackId = message.itemPackId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.imageUrl !== '') {
      obj.imageUrl = message.imageUrl;
    }
    if (message.metadata !== '') {
      obj.metadata = message.metadata;
    }
    if (message.inAppItemId !== '') {
      obj.inAppItemId = message.inAppItemId;
    }
    if (message.currency !== '') {
      obj.currency = message.currency;
    }
    if (message.price !== '') {
      obj.price = message.price;
    }
    if (message.totalPrice !== '') {
      obj.totalPrice = message.totalPrice;
    }
    if (message.discount !== 0) {
      obj.discount = Math.round(message.discount);
    }
    if (message.gainPercent !== 0) {
      obj.gainPercent = Math.round(message.gainPercent);
    }
    if (message.sellingState !== 0) {
      obj.sellingState = sellingStateToJSON(message.sellingState);
    }
    if (message.sellingStartAt !== '') {
      obj.sellingStartAt = message.sellingStartAt;
    }
    if (message.sellingDuration !== 0) {
      obj.sellingDuration = Math.round(message.sellingDuration);
    }
    if (message.sellingEndAt !== '') {
      obj.sellingEndAt = message.sellingEndAt;
    }
    if (message.buyLimitByDay !== 0) {
      obj.buyLimitByDay = Math.round(message.buyLimitByDay);
    }
    if (message.buyLimitByWeek !== 0) {
      obj.buyLimitByWeek = Math.round(message.buyLimitByWeek);
    }
    if (message.buyLimitByMonth !== 0) {
      obj.buyLimitByMonth = Math.round(message.buyLimitByMonth);
    }
    if (message.isRefundable !== false) {
      obj.isRefundable = message.isRefundable;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.countPerPage !== 0) {
      obj.countPerPage = Math.round(message.countPerPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemPackRequest>, I>>(
    base?: I,
  ): ItemPackRequest {
    return ItemPackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemPackRequest>, I>>(
    object: I,
  ): ItemPackRequest {
    const message = createBaseItemPackRequest();
    message.itemPackId = object.itemPackId ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.imageUrl = object.imageUrl ?? '';
    message.metadata = object.metadata ?? '';
    message.inAppItemId = object.inAppItemId ?? '';
    message.currency = object.currency ?? '';
    message.price = object.price ?? '';
    message.totalPrice = object.totalPrice ?? '';
    message.discount = object.discount ?? 0;
    message.gainPercent = object.gainPercent ?? 0;
    message.sellingState = object.sellingState ?? 0;
    message.sellingStartAt = object.sellingStartAt ?? '';
    message.sellingDuration = object.sellingDuration ?? 0;
    message.sellingEndAt = object.sellingEndAt ?? '';
    message.buyLimitByDay = object.buyLimitByDay ?? 0;
    message.buyLimitByWeek = object.buyLimitByWeek ?? 0;
    message.buyLimitByMonth = object.buyLimitByMonth ?? 0;
    message.isRefundable = object.isRefundable ?? false;
    message.isActive = object.isActive ?? false;
    message.page = object.page ?? 0;
    message.countPerPage = object.countPerPage ?? 0;
    return message;
  },
};

function createBaseItemPackResponse(): ItemPackResponse {
  return { success: false, errorMessage: '', itemPack: undefined };
}

export const ItemPackResponse = {
  encode(
    message: ItemPackResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.itemPack !== undefined) {
      ItemPack.encode(message.itemPack, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemPackResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemPackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemPack = ItemPack.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemPackResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      itemPack: isSet(object.itemPack)
        ? ItemPack.fromJSON(object.itemPack)
        : undefined,
    };
  },

  toJSON(message: ItemPackResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.itemPack !== undefined) {
      obj.itemPack = ItemPack.toJSON(message.itemPack);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemPackResponse>, I>>(
    base?: I,
  ): ItemPackResponse {
    return ItemPackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemPackResponse>, I>>(
    object: I,
  ): ItemPackResponse {
    const message = createBaseItemPackResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.itemPack =
      object.itemPack !== undefined && object.itemPack !== null
        ? ItemPack.fromPartial(object.itemPack)
        : undefined;
    return message;
  },
};

function createBaseItemPackElementRequest(): ItemPackElementRequest {
  return {
    itemPackElementId: 0,
    itemPackId: '',
    childPackId: '',
    itemId: '',
    amount: '',
    order: 0,
  };
}

export const ItemPackElementRequest = {
  encode(
    message: ItemPackElementRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemPackElementId !== 0) {
      writer.uint32(8).int32(message.itemPackElementId);
    }
    if (message.itemPackId !== '') {
      writer.uint32(18).string(message.itemPackId);
    }
    if (message.childPackId !== '') {
      writer.uint32(26).string(message.childPackId);
    }
    if (message.itemId !== '') {
      writer.uint32(34).string(message.itemId);
    }
    if (message.amount !== '') {
      writer.uint32(42).string(message.amount);
    }
    if (message.order !== 0) {
      writer.uint32(48).int32(message.order);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ItemPackElementRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemPackElementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemPackElementId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemPackId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.childPackId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemPackElementRequest {
    return {
      itemPackElementId: isSet(object.itemPackElementId)
        ? globalThis.Number(object.itemPackElementId)
        : 0,
      itemPackId: isSet(object.itemPackId)
        ? globalThis.String(object.itemPackId)
        : '',
      childPackId: isSet(object.childPackId)
        ? globalThis.String(object.childPackId)
        : '',
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: ItemPackElementRequest): unknown {
    const obj: any = {};
    if (message.itemPackElementId !== 0) {
      obj.itemPackElementId = Math.round(message.itemPackElementId);
    }
    if (message.itemPackId !== '') {
      obj.itemPackId = message.itemPackId;
    }
    if (message.childPackId !== '') {
      obj.childPackId = message.childPackId;
    }
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemPackElementRequest>, I>>(
    base?: I,
  ): ItemPackElementRequest {
    return ItemPackElementRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemPackElementRequest>, I>>(
    object: I,
  ): ItemPackElementRequest {
    const message = createBaseItemPackElementRequest();
    message.itemPackElementId = object.itemPackElementId ?? 0;
    message.itemPackId = object.itemPackId ?? '';
    message.childPackId = object.childPackId ?? '';
    message.itemId = object.itemId ?? '';
    message.amount = object.amount ?? '';
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseItemPackElementResponse(): ItemPackElementResponse {
  return { success: false, errorMessage: '', itemPackElement: undefined };
}

export const ItemPackElementResponse = {
  encode(
    message: ItemPackElementResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.itemPackElement !== undefined) {
      ItemPackElement.encode(
        message.itemPackElement,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ItemPackElementResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemPackElementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemPackElement = ItemPackElement.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemPackElementResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      itemPackElement: isSet(object.itemPackElement)
        ? ItemPackElement.fromJSON(object.itemPackElement)
        : undefined,
    };
  },

  toJSON(message: ItemPackElementResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.itemPackElement !== undefined) {
      obj.itemPackElement = ItemPackElement.toJSON(message.itemPackElement);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemPackElementResponse>, I>>(
    base?: I,
  ): ItemPackElementResponse {
    return ItemPackElementResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemPackElementResponse>, I>>(
    object: I,
  ): ItemPackElementResponse {
    const message = createBaseItemPackElementResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.itemPackElement =
      object.itemPackElement !== undefined && object.itemPackElement !== null
        ? ItemPackElement.fromPartial(object.itemPackElement)
        : undefined;
    return message;
  },
};

function createBaseGetItemPacksRequest(): GetItemPacksRequest {
  return { itemPackId: [] };
}

export const GetItemPacksRequest = {
  encode(
    message: GetItemPacksRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.itemPackId) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetItemPacksRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetItemPacksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemPackId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetItemPacksRequest {
    return {
      itemPackId: globalThis.Array.isArray(object?.itemPackId)
        ? object.itemPackId.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetItemPacksRequest): unknown {
    const obj: any = {};
    if (message.itemPackId?.length) {
      obj.itemPackId = message.itemPackId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetItemPacksRequest>, I>>(
    base?: I,
  ): GetItemPacksRequest {
    return GetItemPacksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetItemPacksRequest>, I>>(
    object: I,
  ): GetItemPacksRequest {
    const message = createBaseGetItemPacksRequest();
    message.itemPackId = object.itemPackId?.map(e => e) || [];
    return message;
  },
};

function createBaseItemPacksResponse(): ItemPacksResponse {
  return { success: false, errorMessage: '', itemPack: [] };
}

export const ItemPacksResponse = {
  encode(
    message: ItemPacksResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.itemPack) {
      ItemPack.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemPacksResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemPacksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemPack.push(ItemPack.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemPacksResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      itemPack: globalThis.Array.isArray(object?.itemPack)
        ? object.itemPack.map((e: any) => ItemPack.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemPacksResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.itemPack?.length) {
      obj.itemPack = message.itemPack.map(e => ItemPack.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemPacksResponse>, I>>(
    base?: I,
  ): ItemPacksResponse {
    return ItemPacksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemPacksResponse>, I>>(
    object: I,
  ): ItemPacksResponse {
    const message = createBaseItemPacksResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.itemPack = object.itemPack?.map(e => ItemPack.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdminGetRequest(): AdminGetRequest {
  return { page: 0, countPerPage: 0, isActive: false };
}

export const AdminGetRequest = {
  encode(
    message: AdminGetRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.countPerPage !== 0) {
      writer.uint32(16).int32(message.countPerPage);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminGetRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.countPerPage = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminGetRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      countPerPage: isSet(object.countPerPage)
        ? globalThis.Number(object.countPerPage)
        : 0,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
    };
  },

  toJSON(message: AdminGetRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.countPerPage !== 0) {
      obj.countPerPage = Math.round(message.countPerPage);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminGetRequest>, I>>(
    base?: I,
  ): AdminGetRequest {
    return AdminGetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminGetRequest>, I>>(
    object: I,
  ): AdminGetRequest {
    const message = createBaseAdminGetRequest();
    message.page = object.page ?? 0;
    message.countPerPage = object.countPerPage ?? 0;
    message.isActive = object.isActive ?? false;
    return message;
  },
};

export type ItemServiceService = typeof ItemServiceService;
export const ItemServiceService = {
  createItemType: {
    path: '/item.ItemService/CreateItemType',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemTypeRequest) =>
      Buffer.from(ItemTypeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemTypeRequest.decode(value),
    responseSerialize: (value: ItemTypeResponse) =>
      Buffer.from(ItemTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemTypeResponse.decode(value),
  },
  getItemTypes: {
    path: '/item.ItemService/GetItemTypes',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyRequest) =>
      Buffer.from(EmptyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyRequest.decode(value),
    responseSerialize: (value: GetItemTypeResponse) =>
      Buffer.from(GetItemTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetItemTypeResponse.decode(value),
  },
  updateItemType: {
    path: '/item.ItemService/UpdateItemType',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemTypeRequest) =>
      Buffer.from(ItemTypeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemTypeRequest.decode(value),
    responseSerialize: (value: ItemTypeResponse) =>
      Buffer.from(ItemTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemTypeResponse.decode(value),
  },
  deactiveItemType: {
    path: '/item.ItemService/DeactiveItemType',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultStringIdRequest) =>
      Buffer.from(DefaultStringIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultStringIdRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  createItem: {
    path: '/item.ItemService/CreateItem',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemRequest) =>
      Buffer.from(ItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemRequest.decode(value),
    responseSerialize: (value: ItemResponse) =>
      Buffer.from(ItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemResponse.decode(value),
  },
  getItem: {
    path: '/item.ItemService/GetItem',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultStringIdRequest) =>
      Buffer.from(DefaultStringIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultStringIdRequest.decode(value),
    responseSerialize: (value: ItemResponse) =>
      Buffer.from(ItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemResponse.decode(value),
  },
  getItemStream: {
    path: '/item.ItemService/GetItemStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: DefaultStringIdRequest) =>
      Buffer.from(DefaultStringIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultStringIdRequest.decode(value),
    responseSerialize: (value: ItemResponse) =>
      Buffer.from(ItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemResponse.decode(value),
  },
  getItems: {
    path: '/item.ItemService/GetItems',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemRequest) =>
      Buffer.from(ItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemRequest.decode(value),
    responseSerialize: (value: ItemsResponse) =>
      Buffer.from(ItemsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemsResponse.decode(value),
  },
  getItemsStream: {
    path: '/item.ItemService/GetItemsStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ItemRequest) =>
      Buffer.from(ItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemRequest.decode(value),
    responseSerialize: (value: ItemsResponse) =>
      Buffer.from(ItemsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemsResponse.decode(value),
  },
  getItemsById: {
    path: '/item.ItemService/GetItemsById',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemsRequest) =>
      Buffer.from(ItemsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemsRequest.decode(value),
    responseSerialize: (value: ItemsResponse) =>
      Buffer.from(ItemsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemsResponse.decode(value),
  },
  getItemsByIdStream: {
    path: '/item.ItemService/GetItemsByIdStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ItemsRequest) =>
      Buffer.from(ItemsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemsRequest.decode(value),
    responseSerialize: (value: ItemsResponse) =>
      Buffer.from(ItemsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemsResponse.decode(value),
  },
  updateItem: {
    path: '/item.ItemService/UpdateItem',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemRequest) =>
      Buffer.from(ItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemRequest.decode(value),
    responseSerialize: (value: ItemResponse) =>
      Buffer.from(ItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemResponse.decode(value),
  },
  deactiveItem: {
    path: '/item.ItemService/DeactiveItem',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultStringIdRequest) =>
      Buffer.from(DefaultStringIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultStringIdRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  getDefaultCurrency: {
    path: '/item.ItemService/GetDefaultCurrency',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyRequest) =>
      Buffer.from(EmptyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyRequest.decode(value),
    responseSerialize: (value: ItemResponse) =>
      Buffer.from(ItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemResponse.decode(value),
  },
  createItemPack: {
    path: '/item.ItemService/CreateItemPack',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemPackRequest) =>
      Buffer.from(ItemPackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemPackRequest.decode(value),
    responseSerialize: (value: ItemPackResponse) =>
      Buffer.from(ItemPackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPackResponse.decode(value),
  },
  createItemPackElement: {
    path: '/item.ItemService/CreateItemPackElement',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemPackElementRequest) =>
      Buffer.from(ItemPackElementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemPackElementRequest.decode(value),
    responseSerialize: (value: ItemPackElementResponse) =>
      Buffer.from(ItemPackElementResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ItemPackElementResponse.decode(value),
  },
  updateItemPackElement: {
    path: '/item.ItemService/UpdateItemPackElement',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemPackElementRequest) =>
      Buffer.from(ItemPackElementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemPackElementRequest.decode(value),
    responseSerialize: (value: ItemPackElementResponse) =>
      Buffer.from(ItemPackElementResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ItemPackElementResponse.decode(value),
  },
  deleteItemPackElement: {
    path: '/item.ItemService/DeleteItemPackElement',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultIntIdRequest) =>
      Buffer.from(DefaultIntIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultIntIdRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  getItemPack: {
    path: '/item.ItemService/GetItemPack',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultStringIdRequest) =>
      Buffer.from(DefaultStringIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultStringIdRequest.decode(value),
    responseSerialize: (value: ItemPackResponse) =>
      Buffer.from(ItemPackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPackResponse.decode(value),
  },
  getItemPackStream: {
    path: '/item.ItemService/GetItemPackStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: DefaultStringIdRequest) =>
      Buffer.from(DefaultStringIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultStringIdRequest.decode(value),
    responseSerialize: (value: ItemPackResponse) =>
      Buffer.from(ItemPackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPackResponse.decode(value),
  },
  getItemPacks: {
    path: '/item.ItemService/GetItemPacks',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemPackRequest) =>
      Buffer.from(ItemPackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemPackRequest.decode(value),
    responseSerialize: (value: ItemPacksResponse) =>
      Buffer.from(ItemPacksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPacksResponse.decode(value),
  },
  getItemPacksStream: {
    path: '/item.ItemService/GetItemPacksStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ItemPackRequest) =>
      Buffer.from(ItemPackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemPackRequest.decode(value),
    responseSerialize: (value: ItemPacksResponse) =>
      Buffer.from(ItemPacksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPacksResponse.decode(value),
  },
  getItemPacksById: {
    path: '/item.ItemService/GetItemPacksById',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetItemPacksRequest) =>
      Buffer.from(GetItemPacksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetItemPacksRequest.decode(value),
    responseSerialize: (value: ItemPacksResponse) =>
      Buffer.from(ItemPacksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPacksResponse.decode(value),
  },
  getItemPacksByIdStream: {
    path: '/item.ItemService/GetItemPacksByIdStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: GetItemPacksRequest) =>
      Buffer.from(GetItemPacksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetItemPacksRequest.decode(value),
    responseSerialize: (value: ItemPacksResponse) =>
      Buffer.from(ItemPacksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPacksResponse.decode(value),
  },
  updateItemPack: {
    path: '/item.ItemService/UpdateItemPack',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ItemPackRequest) =>
      Buffer.from(ItemPackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ItemPackRequest.decode(value),
    responseSerialize: (value: ItemPackResponse) =>
      Buffer.from(ItemPackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPackResponse.decode(value),
  },
  deactiveItemPack: {
    path: '/item.ItemService/DeactiveItemPack',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultStringIdRequest) =>
      Buffer.from(DefaultStringIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultStringIdRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** admin */
  adminGetAllItemType: {
    path: '/item.ItemService/AdminGetAllItemType',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminGetRequest) =>
      Buffer.from(AdminGetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdminGetRequest.decode(value),
    responseSerialize: (value: GetItemTypeResponse) =>
      Buffer.from(GetItemTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetItemTypeResponse.decode(value),
  },
  adminGetAllItem: {
    path: '/item.ItemService/AdminGetAllItem',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminGetRequest) =>
      Buffer.from(AdminGetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdminGetRequest.decode(value),
    responseSerialize: (value: ItemsResponse) =>
      Buffer.from(ItemsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemsResponse.decode(value),
  },
  adminGetAllItemPack: {
    path: '/item.ItemService/AdminGetAllItemPack',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminGetRequest) =>
      Buffer.from(AdminGetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdminGetRequest.decode(value),
    responseSerialize: (value: ItemPacksResponse) =>
      Buffer.from(ItemPacksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ItemPacksResponse.decode(value),
  },
} as const;

export interface ItemServiceServer extends UntypedServiceImplementation {
  createItemType: handleUnaryCall<ItemTypeRequest, ItemTypeResponse>;
  getItemTypes: handleUnaryCall<EmptyRequest, GetItemTypeResponse>;
  updateItemType: handleUnaryCall<ItemTypeRequest, ItemTypeResponse>;
  deactiveItemType: handleUnaryCall<DefaultStringIdRequest, DefaultResponse>;
  createItem: handleUnaryCall<ItemRequest, ItemResponse>;
  getItem: handleUnaryCall<DefaultStringIdRequest, ItemResponse>;
  getItemStream: handleBidiStreamingCall<DefaultStringIdRequest, ItemResponse>;
  getItems: handleUnaryCall<ItemRequest, ItemsResponse>;
  getItemsStream: handleBidiStreamingCall<ItemRequest, ItemsResponse>;
  getItemsById: handleUnaryCall<ItemsRequest, ItemsResponse>;
  getItemsByIdStream: handleBidiStreamingCall<ItemsRequest, ItemsResponse>;
  updateItem: handleUnaryCall<ItemRequest, ItemResponse>;
  deactiveItem: handleUnaryCall<DefaultStringIdRequest, DefaultResponse>;
  getDefaultCurrency: handleUnaryCall<EmptyRequest, ItemResponse>;
  createItemPack: handleUnaryCall<ItemPackRequest, ItemPackResponse>;
  createItemPackElement: handleUnaryCall<
    ItemPackElementRequest,
    ItemPackElementResponse
  >;
  updateItemPackElement: handleUnaryCall<
    ItemPackElementRequest,
    ItemPackElementResponse
  >;
  deleteItemPackElement: handleUnaryCall<DefaultIntIdRequest, DefaultResponse>;
  getItemPack: handleUnaryCall<DefaultStringIdRequest, ItemPackResponse>;
  getItemPackStream: handleBidiStreamingCall<
    DefaultStringIdRequest,
    ItemPackResponse
  >;
  getItemPacks: handleUnaryCall<ItemPackRequest, ItemPacksResponse>;
  getItemPacksStream: handleBidiStreamingCall<
    ItemPackRequest,
    ItemPacksResponse
  >;
  getItemPacksById: handleUnaryCall<GetItemPacksRequest, ItemPacksResponse>;
  getItemPacksByIdStream: handleBidiStreamingCall<
    GetItemPacksRequest,
    ItemPacksResponse
  >;
  updateItemPack: handleUnaryCall<ItemPackRequest, ItemPackResponse>;
  deactiveItemPack: handleUnaryCall<DefaultStringIdRequest, DefaultResponse>;
  /** admin */
  adminGetAllItemType: handleUnaryCall<AdminGetRequest, GetItemTypeResponse>;
  adminGetAllItem: handleUnaryCall<AdminGetRequest, ItemsResponse>;
  adminGetAllItemPack: handleUnaryCall<AdminGetRequest, ItemPacksResponse>;
}

export interface ItemServiceClient extends Client {
  createItemType(
    request: ItemTypeRequest,
    callback: (error: ServiceError | null, response: ItemTypeResponse) => void,
  ): ClientUnaryCall;
  createItemType(
    request: ItemTypeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemTypeResponse) => void,
  ): ClientUnaryCall;
  createItemType(
    request: ItemTypeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemTypeResponse) => void,
  ): ClientUnaryCall;
  getItemTypes(
    request: EmptyRequest,
    callback: (
      error: ServiceError | null,
      response: GetItemTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  getItemTypes(
    request: EmptyRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetItemTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  getItemTypes(
    request: EmptyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetItemTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  updateItemType(
    request: ItemTypeRequest,
    callback: (error: ServiceError | null, response: ItemTypeResponse) => void,
  ): ClientUnaryCall;
  updateItemType(
    request: ItemTypeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemTypeResponse) => void,
  ): ClientUnaryCall;
  updateItemType(
    request: ItemTypeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemTypeResponse) => void,
  ): ClientUnaryCall;
  deactiveItemType(
    request: DefaultStringIdRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactiveItemType(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactiveItemType(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  createItem(
    request: ItemRequest,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  createItem(
    request: ItemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  createItem(
    request: ItemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  getItem(
    request: DefaultStringIdRequest,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  getItem(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  getItem(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  getItemStream(): ClientDuplexStream<DefaultStringIdRequest, ItemResponse>;
  getItemStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<DefaultStringIdRequest, ItemResponse>;
  getItemStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<DefaultStringIdRequest, ItemResponse>;
  getItems(
    request: ItemRequest,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  getItems(
    request: ItemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  getItems(
    request: ItemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  getItemsStream(): ClientDuplexStream<ItemRequest, ItemsResponse>;
  getItemsStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<ItemRequest, ItemsResponse>;
  getItemsStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ItemRequest, ItemsResponse>;
  getItemsById(
    request: ItemsRequest,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  getItemsById(
    request: ItemsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  getItemsById(
    request: ItemsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  getItemsByIdStream(): ClientDuplexStream<ItemsRequest, ItemsResponse>;
  getItemsByIdStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<ItemsRequest, ItemsResponse>;
  getItemsByIdStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ItemsRequest, ItemsResponse>;
  updateItem(
    request: ItemRequest,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  updateItem(
    request: ItemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  updateItem(
    request: ItemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  deactiveItem(
    request: DefaultStringIdRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactiveItem(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactiveItem(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  getDefaultCurrency(
    request: EmptyRequest,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  getDefaultCurrency(
    request: EmptyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  getDefaultCurrency(
    request: EmptyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemResponse) => void,
  ): ClientUnaryCall;
  createItemPack(
    request: ItemPackRequest,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  createItemPack(
    request: ItemPackRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  createItemPack(
    request: ItemPackRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  createItemPackElement(
    request: ItemPackElementRequest,
    callback: (
      error: ServiceError | null,
      response: ItemPackElementResponse,
    ) => void,
  ): ClientUnaryCall;
  createItemPackElement(
    request: ItemPackElementRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ItemPackElementResponse,
    ) => void,
  ): ClientUnaryCall;
  createItemPackElement(
    request: ItemPackElementRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ItemPackElementResponse,
    ) => void,
  ): ClientUnaryCall;
  updateItemPackElement(
    request: ItemPackElementRequest,
    callback: (
      error: ServiceError | null,
      response: ItemPackElementResponse,
    ) => void,
  ): ClientUnaryCall;
  updateItemPackElement(
    request: ItemPackElementRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ItemPackElementResponse,
    ) => void,
  ): ClientUnaryCall;
  updateItemPackElement(
    request: ItemPackElementRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ItemPackElementResponse,
    ) => void,
  ): ClientUnaryCall;
  deleteItemPackElement(
    request: DefaultIntIdRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deleteItemPackElement(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deleteItemPackElement(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  getItemPack(
    request: DefaultStringIdRequest,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  getItemPack(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  getItemPack(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  getItemPackStream(): ClientDuplexStream<
    DefaultStringIdRequest,
    ItemPackResponse
  >;
  getItemPackStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<DefaultStringIdRequest, ItemPackResponse>;
  getItemPackStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<DefaultStringIdRequest, ItemPackResponse>;
  getItemPacks(
    request: ItemPackRequest,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  getItemPacks(
    request: ItemPackRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  getItemPacks(
    request: ItemPackRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  getItemPacksStream(): ClientDuplexStream<ItemPackRequest, ItemPacksResponse>;
  getItemPacksStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<ItemPackRequest, ItemPacksResponse>;
  getItemPacksStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ItemPackRequest, ItemPacksResponse>;
  getItemPacksById(
    request: GetItemPacksRequest,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  getItemPacksById(
    request: GetItemPacksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  getItemPacksById(
    request: GetItemPacksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  getItemPacksByIdStream(): ClientDuplexStream<
    GetItemPacksRequest,
    ItemPacksResponse
  >;
  getItemPacksByIdStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<GetItemPacksRequest, ItemPacksResponse>;
  getItemPacksByIdStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<GetItemPacksRequest, ItemPacksResponse>;
  updateItemPack(
    request: ItemPackRequest,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  updateItemPack(
    request: ItemPackRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  updateItemPack(
    request: ItemPackRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemPackResponse) => void,
  ): ClientUnaryCall;
  deactiveItemPack(
    request: DefaultStringIdRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactiveItemPack(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactiveItemPack(
    request: DefaultStringIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** admin */
  adminGetAllItemType(
    request: AdminGetRequest,
    callback: (
      error: ServiceError | null,
      response: GetItemTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  adminGetAllItemType(
    request: AdminGetRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetItemTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  adminGetAllItemType(
    request: AdminGetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetItemTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  adminGetAllItem(
    request: AdminGetRequest,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  adminGetAllItem(
    request: AdminGetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  adminGetAllItem(
    request: AdminGetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemsResponse) => void,
  ): ClientUnaryCall;
  adminGetAllItemPack(
    request: AdminGetRequest,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  adminGetAllItemPack(
    request: AdminGetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
  adminGetAllItemPack(
    request: AdminGetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ItemPacksResponse) => void,
  ): ClientUnaryCall;
}

export const ItemServiceClient = makeGenericClientConstructor(
  ItemServiceService,
  'item.ItemService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): ItemServiceClient;
  service: typeof ItemServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
