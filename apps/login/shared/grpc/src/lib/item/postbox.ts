// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: postbox.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import {
  Amount,
  DefaultIntIdRequest,
  DefaultResponse,
  PostBox,
  PostBoxState,
  postBoxStateFromJSON,
  postBoxStateToJSON,
  PostType,
  postTypeFromJSON,
  postTypeToJSON,
} from './item-common';

export const protobufPackage = 'item';

export interface SendPostRequest {
  accountId: string;
  senderId: string;
  message: string;
  itemPackId: string;
  itemId: string;
  amount: string;
  cash: string;
  game: string;
  type: PostType;
  state: PostBoxState;
  /** 노출 여부 | 삭제처리 */
  isVisible: boolean;
  /** 삭제 시간 */
  limitedAt: string;
  /** 열람 시간 */
  openedAt: string;
  /** 수령 시간 */
  receivedAt: string;
  txGroupId: string;
}

export interface SendMessageRequest {
  accountId: string;
  senderId: string;
  message: string;
}

export interface PostResponse {
  success: boolean;
  errorMessage: string;
  postBox?: PostBox | undefined;
}

export interface GetPostsRequest {
  accountId: string;
  type: PostType;
  state: PostBoxState;
  /** 노출 여부 | 삭제처리 */
  isVisible: boolean;
}

export interface GetPostsResponse {
  success: boolean;
  errorMessage: string;
  postBoxes: PostBox[];
}

export interface MoneyRequest {
  accountId: string;
  txGroupId: string;
  amount?: Amount | undefined;
}

export interface BulkRequest {
  accountId: string;
  postboxIds: number[];
  type: PostType;
  state: PostBoxState;
}

export interface BulkExcution {
  postboxId: number;
  success: boolean;
  errorMessage: string;
}

export interface BulkResponse {
  success: boolean;
  errorMessage: string;
  excutionSuccess: BulkExcution[];
  excutionFail: BulkExcution[];
}

function createBaseSendPostRequest(): SendPostRequest {
  return {
    accountId: '',
    senderId: '',
    message: '',
    itemPackId: '',
    itemId: '',
    amount: '',
    cash: '',
    game: '',
    type: 0,
    state: 0,
    isVisible: false,
    limitedAt: '',
    openedAt: '',
    receivedAt: '',
    txGroupId: '',
  };
}

export const SendPostRequest = {
  encode(
    message: SendPostRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.senderId !== '') {
      writer.uint32(18).string(message.senderId);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    if (message.itemPackId !== '') {
      writer.uint32(34).string(message.itemPackId);
    }
    if (message.itemId !== '') {
      writer.uint32(42).string(message.itemId);
    }
    if (message.amount !== '') {
      writer.uint32(50).string(message.amount);
    }
    if (message.cash !== '') {
      writer.uint32(58).string(message.cash);
    }
    if (message.game !== '') {
      writer.uint32(66).string(message.game);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.isVisible !== false) {
      writer.uint32(88).bool(message.isVisible);
    }
    if (message.limitedAt !== '') {
      writer.uint32(98).string(message.limitedAt);
    }
    if (message.openedAt !== '') {
      writer.uint32(106).string(message.openedAt);
    }
    if (message.receivedAt !== '') {
      writer.uint32(114).string(message.receivedAt);
    }
    if (message.txGroupId !== '') {
      writer.uint32(122).string(message.txGroupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPostRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.senderId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.itemPackId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cash = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.game = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.limitedAt = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.openedAt = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.txGroupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPostRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      senderId: isSet(object.senderId)
        ? globalThis.String(object.senderId)
        : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      itemPackId: isSet(object.itemPackId)
        ? globalThis.String(object.itemPackId)
        : '',
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
      cash: isSet(object.cash) ? globalThis.String(object.cash) : '',
      game: isSet(object.game) ? globalThis.String(object.game) : '',
      type: isSet(object.type) ? postTypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? postBoxStateFromJSON(object.state) : 0,
      isVisible: isSet(object.isVisible)
        ? globalThis.Boolean(object.isVisible)
        : false,
      limitedAt: isSet(object.limitedAt)
        ? globalThis.String(object.limitedAt)
        : '',
      openedAt: isSet(object.openedAt)
        ? globalThis.String(object.openedAt)
        : '',
      receivedAt: isSet(object.receivedAt)
        ? globalThis.String(object.receivedAt)
        : '',
      txGroupId: isSet(object.txGroupId)
        ? globalThis.String(object.txGroupId)
        : '',
    };
  },

  toJSON(message: SendPostRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.senderId !== '') {
      obj.senderId = message.senderId;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.itemPackId !== '') {
      obj.itemPackId = message.itemPackId;
    }
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    if (message.cash !== '') {
      obj.cash = message.cash;
    }
    if (message.game !== '') {
      obj.game = message.game;
    }
    if (message.type !== 0) {
      obj.type = postTypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = postBoxStateToJSON(message.state);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.limitedAt !== '') {
      obj.limitedAt = message.limitedAt;
    }
    if (message.openedAt !== '') {
      obj.openedAt = message.openedAt;
    }
    if (message.receivedAt !== '') {
      obj.receivedAt = message.receivedAt;
    }
    if (message.txGroupId !== '') {
      obj.txGroupId = message.txGroupId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendPostRequest>, I>>(
    base?: I,
  ): SendPostRequest {
    return SendPostRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendPostRequest>, I>>(
    object: I,
  ): SendPostRequest {
    const message = createBaseSendPostRequest();
    message.accountId = object.accountId ?? '';
    message.senderId = object.senderId ?? '';
    message.message = object.message ?? '';
    message.itemPackId = object.itemPackId ?? '';
    message.itemId = object.itemId ?? '';
    message.amount = object.amount ?? '';
    message.cash = object.cash ?? '';
    message.game = object.game ?? '';
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    message.isVisible = object.isVisible ?? false;
    message.limitedAt = object.limitedAt ?? '';
    message.openedAt = object.openedAt ?? '';
    message.receivedAt = object.receivedAt ?? '';
    message.txGroupId = object.txGroupId ?? '';
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { accountId: '', senderId: '', message: '' };
}

export const SendMessageRequest = {
  encode(
    message: SendMessageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.senderId !== '') {
      writer.uint32(18).string(message.senderId);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SendMessageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.senderId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      senderId: isSet(object.senderId)
        ? globalThis.String(object.senderId)
        : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.senderId !== '') {
      obj.senderId = message.senderId;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageRequest>, I>>(
    base?: I,
  ): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(
    object: I,
  ): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.accountId = object.accountId ?? '';
    message.senderId = object.senderId ?? '';
    message.message = object.message ?? '';
    return message;
  },
};

function createBasePostResponse(): PostResponse {
  return { success: false, errorMessage: '', postBox: undefined };
}

export const PostResponse = {
  encode(
    message: PostResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.postBox !== undefined) {
      PostBox.encode(message.postBox, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.postBox = PostBox.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      postBox: isSet(object.postBox)
        ? PostBox.fromJSON(object.postBox)
        : undefined,
    };
  },

  toJSON(message: PostResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.postBox !== undefined) {
      obj.postBox = PostBox.toJSON(message.postBox);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostResponse>, I>>(
    base?: I,
  ): PostResponse {
    return PostResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostResponse>, I>>(
    object: I,
  ): PostResponse {
    const message = createBasePostResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.postBox =
      object.postBox !== undefined && object.postBox !== null
        ? PostBox.fromPartial(object.postBox)
        : undefined;
    return message;
  },
};

function createBaseGetPostsRequest(): GetPostsRequest {
  return { accountId: '', type: 0, state: 0, isVisible: false };
}

export const GetPostsRequest = {
  encode(
    message: GetPostsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.isVisible !== false) {
      writer.uint32(32).bool(message.isVisible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPostsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPostsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPostsRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      type: isSet(object.type) ? postTypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? postBoxStateFromJSON(object.state) : 0,
      isVisible: isSet(object.isVisible)
        ? globalThis.Boolean(object.isVisible)
        : false,
    };
  },

  toJSON(message: GetPostsRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.type !== 0) {
      obj.type = postTypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = postBoxStateToJSON(message.state);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPostsRequest>, I>>(
    base?: I,
  ): GetPostsRequest {
    return GetPostsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPostsRequest>, I>>(
    object: I,
  ): GetPostsRequest {
    const message = createBaseGetPostsRequest();
    message.accountId = object.accountId ?? '';
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    message.isVisible = object.isVisible ?? false;
    return message;
  },
};

function createBaseGetPostsResponse(): GetPostsResponse {
  return { success: false, errorMessage: '', postBoxes: [] };
}

export const GetPostsResponse = {
  encode(
    message: GetPostsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.postBoxes) {
      PostBox.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPostsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPostsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.postBoxes.push(PostBox.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPostsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      postBoxes: globalThis.Array.isArray(object?.postBoxes)
        ? object.postBoxes.map((e: any) => PostBox.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPostsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.postBoxes?.length) {
      obj.postBoxes = message.postBoxes.map(e => PostBox.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPostsResponse>, I>>(
    base?: I,
  ): GetPostsResponse {
    return GetPostsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPostsResponse>, I>>(
    object: I,
  ): GetPostsResponse {
    const message = createBaseGetPostsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.postBoxes =
      object.postBoxes?.map(e => PostBox.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMoneyRequest(): MoneyRequest {
  return { accountId: '', txGroupId: '', amount: undefined };
}

export const MoneyRequest = {
  encode(
    message: MoneyRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.txGroupId !== '') {
      writer.uint32(18).string(message.txGroupId);
    }
    if (message.amount !== undefined) {
      Amount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoneyRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoneyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txGroupId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = Amount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoneyRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      txGroupId: isSet(object.txGroupId)
        ? globalThis.String(object.txGroupId)
        : '',
      amount: isSet(object.amount) ? Amount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MoneyRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.txGroupId !== '') {
      obj.txGroupId = message.txGroupId;
    }
    if (message.amount !== undefined) {
      obj.amount = Amount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoneyRequest>, I>>(
    base?: I,
  ): MoneyRequest {
    return MoneyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoneyRequest>, I>>(
    object: I,
  ): MoneyRequest {
    const message = createBaseMoneyRequest();
    message.accountId = object.accountId ?? '';
    message.txGroupId = object.txGroupId ?? '';
    message.amount =
      object.amount !== undefined && object.amount !== null
        ? Amount.fromPartial(object.amount)
        : undefined;
    return message;
  },
};

function createBaseBulkRequest(): BulkRequest {
  return { accountId: '', postboxIds: [], type: 0, state: 0 };
}

export const BulkRequest = {
  encode(
    message: BulkRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    writer.uint32(18).fork();
    for (const v of message.postboxIds) {
      writer.int32(v);
    }
    writer.join();
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.postboxIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.postboxIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      postboxIds: globalThis.Array.isArray(object?.postboxIds)
        ? object.postboxIds.map((e: any) => globalThis.Number(e))
        : [],
      type: isSet(object.type) ? postTypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? postBoxStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: BulkRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.postboxIds?.length) {
      obj.postboxIds = message.postboxIds.map(e => Math.round(e));
    }
    if (message.type !== 0) {
      obj.type = postTypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = postBoxStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkRequest>, I>>(base?: I): BulkRequest {
    return BulkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkRequest>, I>>(
    object: I,
  ): BulkRequest {
    const message = createBaseBulkRequest();
    message.accountId = object.accountId ?? '';
    message.postboxIds = object.postboxIds?.map(e => e) || [];
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseBulkExcution(): BulkExcution {
  return { postboxId: 0, success: false, errorMessage: '' };
}

export const BulkExcution = {
  encode(
    message: BulkExcution,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.postboxId !== 0) {
      writer.uint32(8).int32(message.postboxId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkExcution {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkExcution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.postboxId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkExcution {
    return {
      postboxId: isSet(object.postboxId)
        ? globalThis.Number(object.postboxId)
        : 0,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: BulkExcution): unknown {
    const obj: any = {};
    if (message.postboxId !== 0) {
      obj.postboxId = Math.round(message.postboxId);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkExcution>, I>>(
    base?: I,
  ): BulkExcution {
    return BulkExcution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkExcution>, I>>(
    object: I,
  ): BulkExcution {
    const message = createBaseBulkExcution();
    message.postboxId = object.postboxId ?? 0;
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

function createBaseBulkResponse(): BulkResponse {
  return {
    success: false,
    errorMessage: '',
    excutionSuccess: [],
    excutionFail: [],
  };
}

export const BulkResponse = {
  encode(
    message: BulkResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.excutionSuccess) {
      BulkExcution.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.excutionFail) {
      BulkExcution.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.excutionSuccess.push(
            BulkExcution.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.excutionFail.push(
            BulkExcution.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      excutionSuccess: globalThis.Array.isArray(object?.excutionSuccess)
        ? object.excutionSuccess.map((e: any) => BulkExcution.fromJSON(e))
        : [],
      excutionFail: globalThis.Array.isArray(object?.excutionFail)
        ? object.excutionFail.map((e: any) => BulkExcution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BulkResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.excutionSuccess?.length) {
      obj.excutionSuccess = message.excutionSuccess.map(e =>
        BulkExcution.toJSON(e),
      );
    }
    if (message.excutionFail?.length) {
      obj.excutionFail = message.excutionFail.map(e => BulkExcution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkResponse>, I>>(
    base?: I,
  ): BulkResponse {
    return BulkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkResponse>, I>>(
    object: I,
  ): BulkResponse {
    const message = createBaseBulkResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.excutionSuccess =
      object.excutionSuccess?.map(e => BulkExcution.fromPartial(e)) || [];
    message.excutionFail =
      object.excutionFail?.map(e => BulkExcution.fromPartial(e)) || [];
    return message;
  },
};

export type PostBoxServiceService = typeof PostBoxServiceService;
export const PostBoxServiceService = {
  /** get */
  getPosts: {
    path: '/item.PostBoxService/GetPosts',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPostsRequest) =>
      Buffer.from(GetPostsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPostsRequest.decode(value),
    responseSerialize: (value: GetPostsResponse) =>
      Buffer.from(GetPostsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPostsResponse.decode(value),
  },
  /** send */
  gameOverflow: {
    path: '/item.PostBoxService/GameOverflow',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MoneyRequest) =>
      Buffer.from(MoneyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MoneyRequest.decode(value),
    responseSerialize: (value: PostResponse) =>
      Buffer.from(PostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PostResponse.decode(value),
  },
  moneyOverflow: {
    path: '/item.PostBoxService/MoneyOverflow',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MoneyRequest) =>
      Buffer.from(MoneyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MoneyRequest.decode(value),
    responseSerialize: (value: PostResponse) =>
      Buffer.from(PostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PostResponse.decode(value),
  },
  moneyRefund: {
    path: '/item.PostBoxService/MoneyRefund',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MoneyRequest) =>
      Buffer.from(MoneyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MoneyRequest.decode(value),
    responseSerialize: (value: PostResponse) =>
      Buffer.from(PostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PostResponse.decode(value),
  },
  sendPost: {
    path: '/item.PostBoxService/SendPost',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendPostRequest) =>
      Buffer.from(SendPostRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendPostRequest.decode(value),
    responseSerialize: (value: PostResponse) =>
      Buffer.from(PostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PostResponse.decode(value),
  },
  sendMessage: {
    path: '/item.PostBoxService/SendMessage',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest) =>
      Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: PostResponse) =>
      Buffer.from(PostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PostResponse.decode(value),
  },
  /** update */
  openPost: {
    path: '/item.PostBoxService/OpenPost',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultIntIdRequest) =>
      Buffer.from(DefaultIntIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultIntIdRequest.decode(value),
    responseSerialize: (value: PostResponse) =>
      Buffer.from(PostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PostResponse.decode(value),
  },
  receivItem: {
    path: '/item.PostBoxService/ReceivItem',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultIntIdRequest) =>
      Buffer.from(DefaultIntIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultIntIdRequest.decode(value),
    responseSerialize: (value: PostResponse) =>
      Buffer.from(PostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PostResponse.decode(value),
  },
  bulkReceivItem: {
    path: '/item.PostBoxService/BulkReceivItem',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkRequest) =>
      Buffer.from(BulkRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BulkRequest.decode(value),
    responseSerialize: (value: BulkResponse) =>
      Buffer.from(BulkResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BulkResponse.decode(value),
  },
  /** delete */
  deactivePost: {
    path: '/item.PostBoxService/DeactivePost',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DefaultIntIdRequest) =>
      Buffer.from(DefaultIntIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DefaultIntIdRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  bulkDeactive: {
    path: '/item.PostBoxService/BulkDeactive',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkRequest) =>
      Buffer.from(BulkRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BulkRequest.decode(value),
    responseSerialize: (value: BulkResponse) =>
      Buffer.from(BulkResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BulkResponse.decode(value),
  },
} as const;

export interface PostBoxServiceServer extends UntypedServiceImplementation {
  /** get */
  getPosts: handleUnaryCall<GetPostsRequest, GetPostsResponse>;
  /** send */
  gameOverflow: handleUnaryCall<MoneyRequest, PostResponse>;
  moneyOverflow: handleUnaryCall<MoneyRequest, PostResponse>;
  moneyRefund: handleUnaryCall<MoneyRequest, PostResponse>;
  sendPost: handleUnaryCall<SendPostRequest, PostResponse>;
  sendMessage: handleUnaryCall<SendMessageRequest, PostResponse>;
  /** update */
  openPost: handleUnaryCall<DefaultIntIdRequest, PostResponse>;
  receivItem: handleUnaryCall<DefaultIntIdRequest, PostResponse>;
  bulkReceivItem: handleUnaryCall<BulkRequest, BulkResponse>;
  /** delete */
  deactivePost: handleUnaryCall<DefaultIntIdRequest, DefaultResponse>;
  bulkDeactive: handleUnaryCall<BulkRequest, BulkResponse>;
}

export interface PostBoxServiceClient extends Client {
  /** get */
  getPosts(
    request: GetPostsRequest,
    callback: (error: ServiceError | null, response: GetPostsResponse) => void,
  ): ClientUnaryCall;
  getPosts(
    request: GetPostsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPostsResponse) => void,
  ): ClientUnaryCall;
  getPosts(
    request: GetPostsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPostsResponse) => void,
  ): ClientUnaryCall;
  /** send */
  gameOverflow(
    request: MoneyRequest,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  gameOverflow(
    request: MoneyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  gameOverflow(
    request: MoneyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  moneyOverflow(
    request: MoneyRequest,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  moneyOverflow(
    request: MoneyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  moneyOverflow(
    request: MoneyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  moneyRefund(
    request: MoneyRequest,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  moneyRefund(
    request: MoneyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  moneyRefund(
    request: MoneyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  sendPost(
    request: SendPostRequest,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  sendPost(
    request: SendPostRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  sendPost(
    request: SendPostRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  /** update */
  openPost(
    request: DefaultIntIdRequest,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  openPost(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  openPost(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  receivItem(
    request: DefaultIntIdRequest,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  receivItem(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  receivItem(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostResponse) => void,
  ): ClientUnaryCall;
  bulkReceivItem(
    request: BulkRequest,
    callback: (error: ServiceError | null, response: BulkResponse) => void,
  ): ClientUnaryCall;
  bulkReceivItem(
    request: BulkRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BulkResponse) => void,
  ): ClientUnaryCall;
  bulkReceivItem(
    request: BulkRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BulkResponse) => void,
  ): ClientUnaryCall;
  /** delete */
  deactivePost(
    request: DefaultIntIdRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactivePost(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  deactivePost(
    request: DefaultIntIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  bulkDeactive(
    request: BulkRequest,
    callback: (error: ServiceError | null, response: BulkResponse) => void,
  ): ClientUnaryCall;
  bulkDeactive(
    request: BulkRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BulkResponse) => void,
  ): ClientUnaryCall;
  bulkDeactive(
    request: BulkRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BulkResponse) => void,
  ): ClientUnaryCall;
}

export const PostBoxServiceClient = makeGenericClientConstructor(
  PostBoxServiceService,
  'item.PostBoxService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): PostBoxServiceClient;
  service: typeof PostBoxServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
