// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v6.31.1
// source: purchase.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { EmptyResponse, Inventory, PostBox } from './item-common';

export const protobufPackage = 'item';

export interface MonthlyPurchase {
  userId: string;
  purchasable: boolean;
  remainAmount: number;
  year: number;
  month: number;
  purchaseCount: number;
  purchasePrice: number;
  subscriptionCount: number;
  subscriptionPrice: number;
}

export interface SubscriptionReceipt {
  subscriptionReceiptId: string;
  platform: string;
  productId: string;
  originalTransactionId: string;
  latestTransactionId: string;
  status: string;
  expiresAt: string;
  startedAt: string;
  canceledAt: string;
  isAutoRenew: boolean;
}

export interface PurchaseReceipt {
  purchaseReceiptId: string;
  transactionId: string;
  productId: string;
  quantity: number;
  price: number;
}

export interface NotificationRequest {
  body: string;
}

export interface UserIdRequest {
  userId: string;
}

export interface MonthlyPurchaseResponse {
  success: boolean;
  errorMessage: string;
  monthly?: MonthlyPurchase | undefined;
}

export interface PurchaseRequest {
  userId: string;
  accountId: string;
  rawReceipt: string;
  productId: string;
}

export interface PurchaseResponse {
  success: boolean;
  errorMessage: string;
  receipt?: PurchaseReceipt | undefined;
  monthly?: MonthlyPurchase | undefined;
  postBox?: PostBox | undefined;
  inventory: Inventory[];
  gold: string;
}

export interface SubscriptionResponse {
  success: boolean;
  errorMessage: string;
  receipt?: SubscriptionReceipt | undefined;
  monthly?: MonthlyPurchase | undefined;
  postBox?: PostBox | undefined;
  inventory: Inventory[];
  gold: string;
}

export interface AppleSubscriptionRequest {
  /** JWT from Apple */
  jwt: string;
}

export interface GoogleSubscriptionRequest {
  /** JWT from Google */
  jwt: string;
}

function createBaseMonthlyPurchase(): MonthlyPurchase {
  return {
    userId: '',
    purchasable: false,
    remainAmount: 0,
    year: 0,
    month: 0,
    purchaseCount: 0,
    purchasePrice: 0,
    subscriptionCount: 0,
    subscriptionPrice: 0,
  };
}

export const MonthlyPurchase = {
  encode(
    message: MonthlyPurchase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.purchasable !== false) {
      writer.uint32(16).bool(message.purchasable);
    }
    if (message.remainAmount !== 0) {
      writer.uint32(24).int32(message.remainAmount);
    }
    if (message.year !== 0) {
      writer.uint32(32).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(40).int32(message.month);
    }
    if (message.purchaseCount !== 0) {
      writer.uint32(48).int32(message.purchaseCount);
    }
    if (message.purchasePrice !== 0) {
      writer.uint32(56).int32(message.purchasePrice);
    }
    if (message.subscriptionCount !== 0) {
      writer.uint32(64).int32(message.subscriptionCount);
    }
    if (message.subscriptionPrice !== 0) {
      writer.uint32(72).int32(message.subscriptionPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonthlyPurchase {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonthlyPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.purchasable = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.remainAmount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.year = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.month = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.purchaseCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.purchasePrice = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.subscriptionCount = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.subscriptionPrice = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonthlyPurchase {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      purchasable: isSet(object.purchasable)
        ? globalThis.Boolean(object.purchasable)
        : false,
      remainAmount: isSet(object.remainAmount)
        ? globalThis.Number(object.remainAmount)
        : 0,
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
      purchaseCount: isSet(object.purchaseCount)
        ? globalThis.Number(object.purchaseCount)
        : 0,
      purchasePrice: isSet(object.purchasePrice)
        ? globalThis.Number(object.purchasePrice)
        : 0,
      subscriptionCount: isSet(object.subscriptionCount)
        ? globalThis.Number(object.subscriptionCount)
        : 0,
      subscriptionPrice: isSet(object.subscriptionPrice)
        ? globalThis.Number(object.subscriptionPrice)
        : 0,
    };
  },

  toJSON(message: MonthlyPurchase): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.purchasable !== false) {
      obj.purchasable = message.purchasable;
    }
    if (message.remainAmount !== 0) {
      obj.remainAmount = Math.round(message.remainAmount);
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.purchaseCount !== 0) {
      obj.purchaseCount = Math.round(message.purchaseCount);
    }
    if (message.purchasePrice !== 0) {
      obj.purchasePrice = Math.round(message.purchasePrice);
    }
    if (message.subscriptionCount !== 0) {
      obj.subscriptionCount = Math.round(message.subscriptionCount);
    }
    if (message.subscriptionPrice !== 0) {
      obj.subscriptionPrice = Math.round(message.subscriptionPrice);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MonthlyPurchase>, I>>(
    base?: I,
  ): MonthlyPurchase {
    return MonthlyPurchase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MonthlyPurchase>, I>>(
    object: I,
  ): MonthlyPurchase {
    const message = createBaseMonthlyPurchase();
    message.userId = object.userId ?? '';
    message.purchasable = object.purchasable ?? false;
    message.remainAmount = object.remainAmount ?? 0;
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.purchaseCount = object.purchaseCount ?? 0;
    message.purchasePrice = object.purchasePrice ?? 0;
    message.subscriptionCount = object.subscriptionCount ?? 0;
    message.subscriptionPrice = object.subscriptionPrice ?? 0;
    return message;
  },
};

function createBaseSubscriptionReceipt(): SubscriptionReceipt {
  return {
    subscriptionReceiptId: '',
    platform: '',
    productId: '',
    originalTransactionId: '',
    latestTransactionId: '',
    status: '',
    expiresAt: '',
    startedAt: '',
    canceledAt: '',
    isAutoRenew: false,
  };
}

export const SubscriptionReceipt = {
  encode(
    message: SubscriptionReceipt,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.subscriptionReceiptId !== '') {
      writer.uint32(10).string(message.subscriptionReceiptId);
    }
    if (message.platform !== '') {
      writer.uint32(18).string(message.platform);
    }
    if (message.productId !== '') {
      writer.uint32(26).string(message.productId);
    }
    if (message.originalTransactionId !== '') {
      writer.uint32(34).string(message.originalTransactionId);
    }
    if (message.latestTransactionId !== '') {
      writer.uint32(42).string(message.latestTransactionId);
    }
    if (message.status !== '') {
      writer.uint32(50).string(message.status);
    }
    if (message.expiresAt !== '') {
      writer.uint32(58).string(message.expiresAt);
    }
    if (message.startedAt !== '') {
      writer.uint32(66).string(message.startedAt);
    }
    if (message.canceledAt !== '') {
      writer.uint32(74).string(message.canceledAt);
    }
    if (message.isAutoRenew !== false) {
      writer.uint32(80).bool(message.isAutoRenew);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SubscriptionReceipt {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptionReceiptId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.platform = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.originalTransactionId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.latestTransactionId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.canceledAt = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isAutoRenew = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionReceipt {
    return {
      subscriptionReceiptId: isSet(object.subscriptionReceiptId)
        ? globalThis.String(object.subscriptionReceiptId)
        : '',
      platform: isSet(object.platform)
        ? globalThis.String(object.platform)
        : '',
      productId: isSet(object.productId)
        ? globalThis.String(object.productId)
        : '',
      originalTransactionId: isSet(object.originalTransactionId)
        ? globalThis.String(object.originalTransactionId)
        : '',
      latestTransactionId: isSet(object.latestTransactionId)
        ? globalThis.String(object.latestTransactionId)
        : '',
      status: isSet(object.status) ? globalThis.String(object.status) : '',
      expiresAt: isSet(object.expiresAt)
        ? globalThis.String(object.expiresAt)
        : '',
      startedAt: isSet(object.startedAt)
        ? globalThis.String(object.startedAt)
        : '',
      canceledAt: isSet(object.canceledAt)
        ? globalThis.String(object.canceledAt)
        : '',
      isAutoRenew: isSet(object.isAutoRenew)
        ? globalThis.Boolean(object.isAutoRenew)
        : false,
    };
  },

  toJSON(message: SubscriptionReceipt): unknown {
    const obj: any = {};
    if (message.subscriptionReceiptId !== '') {
      obj.subscriptionReceiptId = message.subscriptionReceiptId;
    }
    if (message.platform !== '') {
      obj.platform = message.platform;
    }
    if (message.productId !== '') {
      obj.productId = message.productId;
    }
    if (message.originalTransactionId !== '') {
      obj.originalTransactionId = message.originalTransactionId;
    }
    if (message.latestTransactionId !== '') {
      obj.latestTransactionId = message.latestTransactionId;
    }
    if (message.status !== '') {
      obj.status = message.status;
    }
    if (message.expiresAt !== '') {
      obj.expiresAt = message.expiresAt;
    }
    if (message.startedAt !== '') {
      obj.startedAt = message.startedAt;
    }
    if (message.canceledAt !== '') {
      obj.canceledAt = message.canceledAt;
    }
    if (message.isAutoRenew !== false) {
      obj.isAutoRenew = message.isAutoRenew;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionReceipt>, I>>(
    base?: I,
  ): SubscriptionReceipt {
    return SubscriptionReceipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionReceipt>, I>>(
    object: I,
  ): SubscriptionReceipt {
    const message = createBaseSubscriptionReceipt();
    message.subscriptionReceiptId = object.subscriptionReceiptId ?? '';
    message.platform = object.platform ?? '';
    message.productId = object.productId ?? '';
    message.originalTransactionId = object.originalTransactionId ?? '';
    message.latestTransactionId = object.latestTransactionId ?? '';
    message.status = object.status ?? '';
    message.expiresAt = object.expiresAt ?? '';
    message.startedAt = object.startedAt ?? '';
    message.canceledAt = object.canceledAt ?? '';
    message.isAutoRenew = object.isAutoRenew ?? false;
    return message;
  },
};

function createBasePurchaseReceipt(): PurchaseReceipt {
  return {
    purchaseReceiptId: '',
    transactionId: '',
    productId: '',
    quantity: 0,
    price: 0,
  };
}

export const PurchaseReceipt = {
  encode(
    message: PurchaseReceipt,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.purchaseReceiptId !== '') {
      writer.uint32(10).string(message.purchaseReceiptId);
    }
    if (message.transactionId !== '') {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.productId !== '') {
      writer.uint32(26).string(message.productId);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(40).int32(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchaseReceipt {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchaseReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.purchaseReceiptId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.price = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchaseReceipt {
    return {
      purchaseReceiptId: isSet(object.purchaseReceiptId)
        ? globalThis.String(object.purchaseReceiptId)
        : '',
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : '',
      productId: isSet(object.productId)
        ? globalThis.String(object.productId)
        : '',
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
    };
  },

  toJSON(message: PurchaseReceipt): unknown {
    const obj: any = {};
    if (message.purchaseReceiptId !== '') {
      obj.purchaseReceiptId = message.purchaseReceiptId;
    }
    if (message.transactionId !== '') {
      obj.transactionId = message.transactionId;
    }
    if (message.productId !== '') {
      obj.productId = message.productId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurchaseReceipt>, I>>(
    base?: I,
  ): PurchaseReceipt {
    return PurchaseReceipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurchaseReceipt>, I>>(
    object: I,
  ): PurchaseReceipt {
    const message = createBasePurchaseReceipt();
    message.purchaseReceiptId = object.purchaseReceiptId ?? '';
    message.transactionId = object.transactionId ?? '';
    message.productId = object.productId ?? '';
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    return message;
  },
};

function createBaseNotificationRequest(): NotificationRequest {
  return { body: '' };
}

export const NotificationRequest = {
  encode(
    message: NotificationRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.body !== '') {
      writer.uint32(10).string(message.body);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): NotificationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.body = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationRequest {
    return { body: isSet(object.body) ? globalThis.String(object.body) : '' };
  },

  toJSON(message: NotificationRequest): unknown {
    const obj: any = {};
    if (message.body !== '') {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationRequest>, I>>(
    base?: I,
  ): NotificationRequest {
    return NotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationRequest>, I>>(
    object: I,
  ): NotificationRequest {
    const message = createBaseNotificationRequest();
    message.body = object.body ?? '';
    return message;
  },
};

function createBaseUserIdRequest(): UserIdRequest {
  return { userId: '' };
}

export const UserIdRequest = {
  encode(
    message: UserIdRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserIdRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserIdRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: UserIdRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserIdRequest>, I>>(
    base?: I,
  ): UserIdRequest {
    return UserIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserIdRequest>, I>>(
    object: I,
  ): UserIdRequest {
    const message = createBaseUserIdRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseMonthlyPurchaseResponse(): MonthlyPurchaseResponse {
  return { success: false, errorMessage: '', monthly: undefined };
}

export const MonthlyPurchaseResponse = {
  encode(
    message: MonthlyPurchaseResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.monthly !== undefined) {
      MonthlyPurchase.encode(message.monthly, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MonthlyPurchaseResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonthlyPurchaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.monthly = MonthlyPurchase.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonthlyPurchaseResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      monthly: isSet(object.monthly)
        ? MonthlyPurchase.fromJSON(object.monthly)
        : undefined,
    };
  },

  toJSON(message: MonthlyPurchaseResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.monthly !== undefined) {
      obj.monthly = MonthlyPurchase.toJSON(message.monthly);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MonthlyPurchaseResponse>, I>>(
    base?: I,
  ): MonthlyPurchaseResponse {
    return MonthlyPurchaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MonthlyPurchaseResponse>, I>>(
    object: I,
  ): MonthlyPurchaseResponse {
    const message = createBaseMonthlyPurchaseResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.monthly =
      object.monthly !== undefined && object.monthly !== null
        ? MonthlyPurchase.fromPartial(object.monthly)
        : undefined;
    return message;
  },
};

function createBasePurchaseRequest(): PurchaseRequest {
  return { userId: '', accountId: '', rawReceipt: '', productId: '' };
}

export const PurchaseRequest = {
  encode(
    message: PurchaseRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.rawReceipt !== '') {
      writer.uint32(26).string(message.rawReceipt);
    }
    if (message.productId !== '') {
      writer.uint32(34).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchaseRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rawReceipt = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.productId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchaseRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      rawReceipt: isSet(object.rawReceipt)
        ? globalThis.String(object.rawReceipt)
        : '',
      productId: isSet(object.productId)
        ? globalThis.String(object.productId)
        : '',
    };
  },

  toJSON(message: PurchaseRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.rawReceipt !== '') {
      obj.rawReceipt = message.rawReceipt;
    }
    if (message.productId !== '') {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurchaseRequest>, I>>(
    base?: I,
  ): PurchaseRequest {
    return PurchaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurchaseRequest>, I>>(
    object: I,
  ): PurchaseRequest {
    const message = createBasePurchaseRequest();
    message.userId = object.userId ?? '';
    message.accountId = object.accountId ?? '';
    message.rawReceipt = object.rawReceipt ?? '';
    message.productId = object.productId ?? '';
    return message;
  },
};

function createBasePurchaseResponse(): PurchaseResponse {
  return {
    success: false,
    errorMessage: '',
    receipt: undefined,
    monthly: undefined,
    postBox: undefined,
    inventory: [],
    gold: '',
  };
}

export const PurchaseResponse = {
  encode(
    message: PurchaseResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.receipt !== undefined) {
      PurchaseReceipt.encode(message.receipt, writer.uint32(26).fork()).join();
    }
    if (message.monthly !== undefined) {
      MonthlyPurchase.encode(message.monthly, writer.uint32(34).fork()).join();
    }
    if (message.postBox !== undefined) {
      PostBox.encode(message.postBox, writer.uint32(42).fork()).join();
    }
    for (const v of message.inventory) {
      Inventory.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.gold !== '') {
      writer.uint32(58).string(message.gold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchaseResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receipt = PurchaseReceipt.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.monthly = MonthlyPurchase.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.postBox = PostBox.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inventory.push(Inventory.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gold = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchaseResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      receipt: isSet(object.receipt)
        ? PurchaseReceipt.fromJSON(object.receipt)
        : undefined,
      monthly: isSet(object.monthly)
        ? MonthlyPurchase.fromJSON(object.monthly)
        : undefined,
      postBox: isSet(object.postBox)
        ? PostBox.fromJSON(object.postBox)
        : undefined,
      inventory: globalThis.Array.isArray(object?.inventory)
        ? object.inventory.map((e: any) => Inventory.fromJSON(e))
        : [],
      gold: isSet(object.gold) ? globalThis.String(object.gold) : '',
    };
  },

  toJSON(message: PurchaseResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.receipt !== undefined) {
      obj.receipt = PurchaseReceipt.toJSON(message.receipt);
    }
    if (message.monthly !== undefined) {
      obj.monthly = MonthlyPurchase.toJSON(message.monthly);
    }
    if (message.postBox !== undefined) {
      obj.postBox = PostBox.toJSON(message.postBox);
    }
    if (message.inventory?.length) {
      obj.inventory = message.inventory.map(e => Inventory.toJSON(e));
    }
    if (message.gold !== '') {
      obj.gold = message.gold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurchaseResponse>, I>>(
    base?: I,
  ): PurchaseResponse {
    return PurchaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurchaseResponse>, I>>(
    object: I,
  ): PurchaseResponse {
    const message = createBasePurchaseResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.receipt =
      object.receipt !== undefined && object.receipt !== null
        ? PurchaseReceipt.fromPartial(object.receipt)
        : undefined;
    message.monthly =
      object.monthly !== undefined && object.monthly !== null
        ? MonthlyPurchase.fromPartial(object.monthly)
        : undefined;
    message.postBox =
      object.postBox !== undefined && object.postBox !== null
        ? PostBox.fromPartial(object.postBox)
        : undefined;
    message.inventory =
      object.inventory?.map(e => Inventory.fromPartial(e)) || [];
    message.gold = object.gold ?? '';
    return message;
  },
};

function createBaseSubscriptionResponse(): SubscriptionResponse {
  return {
    success: false,
    errorMessage: '',
    receipt: undefined,
    monthly: undefined,
    postBox: undefined,
    inventory: [],
    gold: '',
  };
}

export const SubscriptionResponse = {
  encode(
    message: SubscriptionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.receipt !== undefined) {
      SubscriptionReceipt.encode(
        message.receipt,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.monthly !== undefined) {
      MonthlyPurchase.encode(message.monthly, writer.uint32(34).fork()).join();
    }
    if (message.postBox !== undefined) {
      PostBox.encode(message.postBox, writer.uint32(42).fork()).join();
    }
    for (const v of message.inventory) {
      Inventory.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.gold !== '') {
      writer.uint32(58).string(message.gold);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SubscriptionResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receipt = SubscriptionReceipt.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.monthly = MonthlyPurchase.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.postBox = PostBox.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inventory.push(Inventory.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gold = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      receipt: isSet(object.receipt)
        ? SubscriptionReceipt.fromJSON(object.receipt)
        : undefined,
      monthly: isSet(object.monthly)
        ? MonthlyPurchase.fromJSON(object.monthly)
        : undefined,
      postBox: isSet(object.postBox)
        ? PostBox.fromJSON(object.postBox)
        : undefined,
      inventory: globalThis.Array.isArray(object?.inventory)
        ? object.inventory.map((e: any) => Inventory.fromJSON(e))
        : [],
      gold: isSet(object.gold) ? globalThis.String(object.gold) : '',
    };
  },

  toJSON(message: SubscriptionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.receipt !== undefined) {
      obj.receipt = SubscriptionReceipt.toJSON(message.receipt);
    }
    if (message.monthly !== undefined) {
      obj.monthly = MonthlyPurchase.toJSON(message.monthly);
    }
    if (message.postBox !== undefined) {
      obj.postBox = PostBox.toJSON(message.postBox);
    }
    if (message.inventory?.length) {
      obj.inventory = message.inventory.map(e => Inventory.toJSON(e));
    }
    if (message.gold !== '') {
      obj.gold = message.gold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionResponse>, I>>(
    base?: I,
  ): SubscriptionResponse {
    return SubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionResponse>, I>>(
    object: I,
  ): SubscriptionResponse {
    const message = createBaseSubscriptionResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.receipt =
      object.receipt !== undefined && object.receipt !== null
        ? SubscriptionReceipt.fromPartial(object.receipt)
        : undefined;
    message.monthly =
      object.monthly !== undefined && object.monthly !== null
        ? MonthlyPurchase.fromPartial(object.monthly)
        : undefined;
    message.postBox =
      object.postBox !== undefined && object.postBox !== null
        ? PostBox.fromPartial(object.postBox)
        : undefined;
    message.inventory =
      object.inventory?.map(e => Inventory.fromPartial(e)) || [];
    message.gold = object.gold ?? '';
    return message;
  },
};

function createBaseAppleSubscriptionRequest(): AppleSubscriptionRequest {
  return { jwt: '' };
}

export const AppleSubscriptionRequest = {
  encode(
    message: AppleSubscriptionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.jwt !== '') {
      writer.uint32(10).string(message.jwt);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AppleSubscriptionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppleSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jwt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppleSubscriptionRequest {
    return { jwt: isSet(object.jwt) ? globalThis.String(object.jwt) : '' };
  },

  toJSON(message: AppleSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.jwt !== '') {
      obj.jwt = message.jwt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppleSubscriptionRequest>, I>>(
    base?: I,
  ): AppleSubscriptionRequest {
    return AppleSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppleSubscriptionRequest>, I>>(
    object: I,
  ): AppleSubscriptionRequest {
    const message = createBaseAppleSubscriptionRequest();
    message.jwt = object.jwt ?? '';
    return message;
  },
};

function createBaseGoogleSubscriptionRequest(): GoogleSubscriptionRequest {
  return { jwt: '' };
}

export const GoogleSubscriptionRequest = {
  encode(
    message: GoogleSubscriptionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.jwt !== '') {
      writer.uint32(10).string(message.jwt);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GoogleSubscriptionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jwt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleSubscriptionRequest {
    return { jwt: isSet(object.jwt) ? globalThis.String(object.jwt) : '' };
  },

  toJSON(message: GoogleSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.jwt !== '') {
      obj.jwt = message.jwt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleSubscriptionRequest>, I>>(
    base?: I,
  ): GoogleSubscriptionRequest {
    return GoogleSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleSubscriptionRequest>, I>>(
    object: I,
  ): GoogleSubscriptionRequest {
    const message = createBaseGoogleSubscriptionRequest();
    message.jwt = object.jwt ?? '';
    return message;
  },
};

export type PurchaseServiceService = typeof PurchaseServiceService;
export const PurchaseServiceService = {
  monthlyPurchase: {
    path: '/item.PurchaseService/MonthlyPurchase',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserIdRequest) =>
      Buffer.from(UserIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserIdRequest.decode(value),
    responseSerialize: (value: MonthlyPurchaseResponse) =>
      Buffer.from(MonthlyPurchaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      MonthlyPurchaseResponse.decode(value),
  },
  applePurchase: {
    path: '/item.PurchaseService/ApplePurchase',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PurchaseRequest) =>
      Buffer.from(PurchaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PurchaseRequest.decode(value),
    responseSerialize: (value: PurchaseResponse) =>
      Buffer.from(PurchaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PurchaseResponse.decode(value),
  },
  googlePurchase: {
    path: '/item.PurchaseService/GooglePurchase',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PurchaseRequest) =>
      Buffer.from(PurchaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PurchaseRequest.decode(value),
    responseSerialize: (value: PurchaseResponse) =>
      Buffer.from(PurchaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PurchaseResponse.decode(value),
  },
  /** for store subscription callback */
  appleSubscription: {
    path: '/item.PurchaseService/AppleSubscription',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PurchaseRequest) =>
      Buffer.from(PurchaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PurchaseRequest.decode(value),
    responseSerialize: (value: SubscriptionResponse) =>
      Buffer.from(SubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SubscriptionResponse.decode(value),
  },
  googleSubscription: {
    path: '/item.PurchaseService/GoogleSubscription',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PurchaseRequest) =>
      Buffer.from(PurchaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PurchaseRequest.decode(value),
    responseSerialize: (value: SubscriptionResponse) =>
      Buffer.from(SubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SubscriptionResponse.decode(value),
  },
  appleSubscriptionCallback: {
    path: '/item.PurchaseService/AppleSubscriptionCallback',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AppleSubscriptionRequest) =>
      Buffer.from(AppleSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      AppleSubscriptionRequest.decode(value),
    responseSerialize: (value: EmptyResponse) =>
      Buffer.from(EmptyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EmptyResponse.decode(value),
  },
  googleSubscriptionCallback: {
    path: '/item.PurchaseService/GoogleSubscriptionCallback',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GoogleSubscriptionRequest) =>
      Buffer.from(GoogleSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GoogleSubscriptionRequest.decode(value),
    responseSerialize: (value: EmptyResponse) =>
      Buffer.from(EmptyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EmptyResponse.decode(value),
  },
  googleNotification: {
    path: '/item.PurchaseService/GoogleNotification',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotificationRequest) =>
      Buffer.from(NotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NotificationRequest.decode(value),
    responseSerialize: (value: EmptyResponse) =>
      Buffer.from(EmptyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EmptyResponse.decode(value),
  },
  appleNotification: {
    path: '/item.PurchaseService/AppleNotification',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotificationRequest) =>
      Buffer.from(NotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NotificationRequest.decode(value),
    responseSerialize: (value: EmptyResponse) =>
      Buffer.from(EmptyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EmptyResponse.decode(value),
  },
} as const;

export interface PurchaseServiceServer extends UntypedServiceImplementation {
  monthlyPurchase: handleUnaryCall<UserIdRequest, MonthlyPurchaseResponse>;
  applePurchase: handleUnaryCall<PurchaseRequest, PurchaseResponse>;
  googlePurchase: handleUnaryCall<PurchaseRequest, PurchaseResponse>;
  /** for store subscription callback */
  appleSubscription: handleUnaryCall<PurchaseRequest, SubscriptionResponse>;
  googleSubscription: handleUnaryCall<PurchaseRequest, SubscriptionResponse>;
  appleSubscriptionCallback: handleUnaryCall<
    AppleSubscriptionRequest,
    EmptyResponse
  >;
  googleSubscriptionCallback: handleUnaryCall<
    GoogleSubscriptionRequest,
    EmptyResponse
  >;
  googleNotification: handleUnaryCall<NotificationRequest, EmptyResponse>;
  appleNotification: handleUnaryCall<NotificationRequest, EmptyResponse>;
}

export interface PurchaseServiceClient extends Client {
  monthlyPurchase(
    request: UserIdRequest,
    callback: (
      error: ServiceError | null,
      response: MonthlyPurchaseResponse,
    ) => void,
  ): ClientUnaryCall;
  monthlyPurchase(
    request: UserIdRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: MonthlyPurchaseResponse,
    ) => void,
  ): ClientUnaryCall;
  monthlyPurchase(
    request: UserIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: MonthlyPurchaseResponse,
    ) => void,
  ): ClientUnaryCall;
  applePurchase(
    request: PurchaseRequest,
    callback: (error: ServiceError | null, response: PurchaseResponse) => void,
  ): ClientUnaryCall;
  applePurchase(
    request: PurchaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PurchaseResponse) => void,
  ): ClientUnaryCall;
  applePurchase(
    request: PurchaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PurchaseResponse) => void,
  ): ClientUnaryCall;
  googlePurchase(
    request: PurchaseRequest,
    callback: (error: ServiceError | null, response: PurchaseResponse) => void,
  ): ClientUnaryCall;
  googlePurchase(
    request: PurchaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PurchaseResponse) => void,
  ): ClientUnaryCall;
  googlePurchase(
    request: PurchaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PurchaseResponse) => void,
  ): ClientUnaryCall;
  /** for store subscription callback */
  appleSubscription(
    request: PurchaseRequest,
    callback: (
      error: ServiceError | null,
      response: SubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  appleSubscription(
    request: PurchaseRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: SubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  appleSubscription(
    request: PurchaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: SubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  googleSubscription(
    request: PurchaseRequest,
    callback: (
      error: ServiceError | null,
      response: SubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  googleSubscription(
    request: PurchaseRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: SubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  googleSubscription(
    request: PurchaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: SubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  appleSubscriptionCallback(
    request: AppleSubscriptionRequest,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  appleSubscriptionCallback(
    request: AppleSubscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  appleSubscriptionCallback(
    request: AppleSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  googleSubscriptionCallback(
    request: GoogleSubscriptionRequest,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  googleSubscriptionCallback(
    request: GoogleSubscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  googleSubscriptionCallback(
    request: GoogleSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  googleNotification(
    request: NotificationRequest,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  googleNotification(
    request: NotificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  googleNotification(
    request: NotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  appleNotification(
    request: NotificationRequest,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  appleNotification(
    request: NotificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
  appleNotification(
    request: NotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EmptyResponse) => void,
  ): ClientUnaryCall;
}

export const PurchaseServiceClient = makeGenericClientConstructor(
  PurchaseServiceService,
  'item.PurchaseService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): PurchaseServiceClient;
  service: typeof PurchaseServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
