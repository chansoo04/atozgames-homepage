// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: reward.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { Amount, PaidReward, Reward } from './item-common';

export const protobufPackage = 'item';

export interface GetRewardsRequest {
  rewardId: string;
  rewardType: string;
}

export interface GetRewardsResponse {
  success: boolean;
  errorMessage: string;
  reward: Reward[];
}

export interface PayRewardRequest {
  rewardId: string;
  accountId: string;
}

export interface PayResult {
  /** ITEM, GAME_MONEY */
  type: string;
  balance?: Amount | undefined;
  overflow?: Amount | undefined;
  postboxId: number;
  itemPackId: string;
  itemId: string;
}

export interface PayRewardResponse {
  success: boolean;
  errorMessage: string;
  json: string;
  payResult: PayResult[];
}

export interface GetPaidRewardsRequest {
  accountId: string;
  startDate: string;
  endDate: string;
}

export interface GetPaidRewardsResponse {
  success: boolean;
  errorMessage: string;
  paidReward: PaidReward[];
}

function createBaseGetRewardsRequest(): GetRewardsRequest {
  return { rewardId: '', rewardType: '' };
}

export const GetRewardsRequest = {
  encode(
    message: GetRewardsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardId !== '') {
      writer.uint32(10).string(message.rewardId);
    }
    if (message.rewardType !== '') {
      writer.uint32(18).string(message.rewardType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRewardsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRewardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rewardId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rewardType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRewardsRequest {
    return {
      rewardId: isSet(object.rewardId)
        ? globalThis.String(object.rewardId)
        : '',
      rewardType: isSet(object.rewardType)
        ? globalThis.String(object.rewardType)
        : '',
    };
  },

  toJSON(message: GetRewardsRequest): unknown {
    const obj: any = {};
    if (message.rewardId !== '') {
      obj.rewardId = message.rewardId;
    }
    if (message.rewardType !== '') {
      obj.rewardType = message.rewardType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRewardsRequest>, I>>(
    base?: I,
  ): GetRewardsRequest {
    return GetRewardsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRewardsRequest>, I>>(
    object: I,
  ): GetRewardsRequest {
    const message = createBaseGetRewardsRequest();
    message.rewardId = object.rewardId ?? '';
    message.rewardType = object.rewardType ?? '';
    return message;
  },
};

function createBaseGetRewardsResponse(): GetRewardsResponse {
  return { success: false, errorMessage: '', reward: [] };
}

export const GetRewardsResponse = {
  encode(
    message: GetRewardsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.reward) {
      Reward.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetRewardsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRewardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reward.push(Reward.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRewardsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      reward: globalThis.Array.isArray(object?.reward)
        ? object.reward.map((e: any) => Reward.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetRewardsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.reward?.length) {
      obj.reward = message.reward.map(e => Reward.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRewardsResponse>, I>>(
    base?: I,
  ): GetRewardsResponse {
    return GetRewardsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRewardsResponse>, I>>(
    object: I,
  ): GetRewardsResponse {
    const message = createBaseGetRewardsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.reward = object.reward?.map(e => Reward.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayRewardRequest(): PayRewardRequest {
  return { rewardId: '', accountId: '' };
}

export const PayRewardRequest = {
  encode(
    message: PayRewardRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardId !== '') {
      writer.uint32(10).string(message.rewardId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayRewardRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayRewardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rewardId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayRewardRequest {
    return {
      rewardId: isSet(object.rewardId)
        ? globalThis.String(object.rewardId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
    };
  },

  toJSON(message: PayRewardRequest): unknown {
    const obj: any = {};
    if (message.rewardId !== '') {
      obj.rewardId = message.rewardId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayRewardRequest>, I>>(
    base?: I,
  ): PayRewardRequest {
    return PayRewardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayRewardRequest>, I>>(
    object: I,
  ): PayRewardRequest {
    const message = createBasePayRewardRequest();
    message.rewardId = object.rewardId ?? '';
    message.accountId = object.accountId ?? '';
    return message;
  },
};

function createBasePayResult(): PayResult {
  return {
    type: '',
    balance: undefined,
    overflow: undefined,
    postboxId: 0,
    itemPackId: '',
    itemId: '',
  };
}

export const PayResult = {
  encode(
    message: PayResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== '') {
      writer.uint32(10).string(message.type);
    }
    if (message.balance !== undefined) {
      Amount.encode(message.balance, writer.uint32(18).fork()).join();
    }
    if (message.overflow !== undefined) {
      Amount.encode(message.overflow, writer.uint32(26).fork()).join();
    }
    if (message.postboxId !== 0) {
      writer.uint32(32).int32(message.postboxId);
    }
    if (message.itemPackId !== '') {
      writer.uint32(42).string(message.itemPackId);
    }
    if (message.itemId !== '') {
      writer.uint32(50).string(message.itemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Amount.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.overflow = Amount.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.postboxId = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.itemPackId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.itemId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayResult {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      balance: isSet(object.balance)
        ? Amount.fromJSON(object.balance)
        : undefined,
      overflow: isSet(object.overflow)
        ? Amount.fromJSON(object.overflow)
        : undefined,
      postboxId: isSet(object.postboxId)
        ? globalThis.Number(object.postboxId)
        : 0,
      itemPackId: isSet(object.itemPackId)
        ? globalThis.String(object.itemPackId)
        : '',
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
    };
  },

  toJSON(message: PayResult): unknown {
    const obj: any = {};
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.balance !== undefined) {
      obj.balance = Amount.toJSON(message.balance);
    }
    if (message.overflow !== undefined) {
      obj.overflow = Amount.toJSON(message.overflow);
    }
    if (message.postboxId !== 0) {
      obj.postboxId = Math.round(message.postboxId);
    }
    if (message.itemPackId !== '') {
      obj.itemPackId = message.itemPackId;
    }
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayResult>, I>>(base?: I): PayResult {
    return PayResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayResult>, I>>(
    object: I,
  ): PayResult {
    const message = createBasePayResult();
    message.type = object.type ?? '';
    message.balance =
      object.balance !== undefined && object.balance !== null
        ? Amount.fromPartial(object.balance)
        : undefined;
    message.overflow =
      object.overflow !== undefined && object.overflow !== null
        ? Amount.fromPartial(object.overflow)
        : undefined;
    message.postboxId = object.postboxId ?? 0;
    message.itemPackId = object.itemPackId ?? '';
    message.itemId = object.itemId ?? '';
    return message;
  },
};

function createBasePayRewardResponse(): PayRewardResponse {
  return { success: false, errorMessage: '', json: '', payResult: [] };
}

export const PayRewardResponse = {
  encode(
    message: PayRewardResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.json !== '') {
      writer.uint32(26).string(message.json);
    }
    for (const v of message.payResult) {
      PayResult.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayRewardResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayRewardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.json = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payResult.push(PayResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayRewardResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      json: isSet(object.json) ? globalThis.String(object.json) : '',
      payResult: globalThis.Array.isArray(object?.payResult)
        ? object.payResult.map((e: any) => PayResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PayRewardResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.json !== '') {
      obj.json = message.json;
    }
    if (message.payResult?.length) {
      obj.payResult = message.payResult.map(e => PayResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayRewardResponse>, I>>(
    base?: I,
  ): PayRewardResponse {
    return PayRewardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayRewardResponse>, I>>(
    object: I,
  ): PayRewardResponse {
    const message = createBasePayRewardResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.json = object.json ?? '';
    message.payResult =
      object.payResult?.map(e => PayResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPaidRewardsRequest(): GetPaidRewardsRequest {
  return { accountId: '', startDate: '', endDate: '' };
}

export const GetPaidRewardsRequest = {
  encode(
    message: GetPaidRewardsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.startDate !== '') {
      writer.uint32(18).string(message.startDate);
    }
    if (message.endDate !== '') {
      writer.uint32(26).string(message.endDate);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetPaidRewardsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaidRewardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaidRewardsRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : '',
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : '',
    };
  },

  toJSON(message: GetPaidRewardsRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.startDate !== '') {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== '') {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaidRewardsRequest>, I>>(
    base?: I,
  ): GetPaidRewardsRequest {
    return GetPaidRewardsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaidRewardsRequest>, I>>(
    object: I,
  ): GetPaidRewardsRequest {
    const message = createBaseGetPaidRewardsRequest();
    message.accountId = object.accountId ?? '';
    message.startDate = object.startDate ?? '';
    message.endDate = object.endDate ?? '';
    return message;
  },
};

function createBaseGetPaidRewardsResponse(): GetPaidRewardsResponse {
  return { success: false, errorMessage: '', paidReward: [] };
}

export const GetPaidRewardsResponse = {
  encode(
    message: GetPaidRewardsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.paidReward) {
      PaidReward.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetPaidRewardsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaidRewardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paidReward.push(PaidReward.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaidRewardsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      paidReward: globalThis.Array.isArray(object?.paidReward)
        ? object.paidReward.map((e: any) => PaidReward.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPaidRewardsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.paidReward?.length) {
      obj.paidReward = message.paidReward.map(e => PaidReward.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaidRewardsResponse>, I>>(
    base?: I,
  ): GetPaidRewardsResponse {
    return GetPaidRewardsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaidRewardsResponse>, I>>(
    object: I,
  ): GetPaidRewardsResponse {
    const message = createBaseGetPaidRewardsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.paidReward =
      object.paidReward?.map(e => PaidReward.fromPartial(e)) || [];
    return message;
  },
};

export type RewardServiceService = typeof RewardServiceService;
export const RewardServiceService = {
  getRewards: {
    path: '/item.RewardService/GetRewards',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRewardsRequest) =>
      Buffer.from(GetRewardsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetRewardsRequest.decode(value),
    responseSerialize: (value: GetRewardsResponse) =>
      Buffer.from(GetRewardsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetRewardsResponse.decode(value),
  },
  getRewardsStream: {
    path: '/item.RewardService/GetRewardsStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: GetRewardsRequest) =>
      Buffer.from(GetRewardsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetRewardsRequest.decode(value),
    responseSerialize: (value: GetRewardsResponse) =>
      Buffer.from(GetRewardsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetRewardsResponse.decode(value),
  },
  payReward: {
    path: '/item.RewardService/PayReward',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PayRewardRequest) =>
      Buffer.from(PayRewardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PayRewardRequest.decode(value),
    responseSerialize: (value: PayRewardResponse) =>
      Buffer.from(PayRewardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PayRewardResponse.decode(value),
  },
  getPaidRewards: {
    path: '/item.RewardService/GetPaidRewards',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPaidRewardsRequest) =>
      Buffer.from(GetPaidRewardsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPaidRewardsRequest.decode(value),
    responseSerialize: (value: GetPaidRewardsResponse) =>
      Buffer.from(GetPaidRewardsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetPaidRewardsResponse.decode(value),
  },
  getPaidRewardsStream: {
    path: '/item.RewardService/GetPaidRewardsStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: GetPaidRewardsRequest) =>
      Buffer.from(GetPaidRewardsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPaidRewardsRequest.decode(value),
    responseSerialize: (value: GetPaidRewardsResponse) =>
      Buffer.from(GetPaidRewardsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetPaidRewardsResponse.decode(value),
  },
} as const;

export interface RewardServiceServer extends UntypedServiceImplementation {
  getRewards: handleUnaryCall<GetRewardsRequest, GetRewardsResponse>;
  getRewardsStream: handleBidiStreamingCall<
    GetRewardsRequest,
    GetRewardsResponse
  >;
  payReward: handleUnaryCall<PayRewardRequest, PayRewardResponse>;
  getPaidRewards: handleUnaryCall<
    GetPaidRewardsRequest,
    GetPaidRewardsResponse
  >;
  getPaidRewardsStream: handleBidiStreamingCall<
    GetPaidRewardsRequest,
    GetPaidRewardsResponse
  >;
}

export interface RewardServiceClient extends Client {
  getRewards(
    request: GetRewardsRequest,
    callback: (
      error: ServiceError | null,
      response: GetRewardsResponse,
    ) => void,
  ): ClientUnaryCall;
  getRewards(
    request: GetRewardsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetRewardsResponse,
    ) => void,
  ): ClientUnaryCall;
  getRewards(
    request: GetRewardsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetRewardsResponse,
    ) => void,
  ): ClientUnaryCall;
  getRewardsStream(): ClientDuplexStream<GetRewardsRequest, GetRewardsResponse>;
  getRewardsStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<GetRewardsRequest, GetRewardsResponse>;
  getRewardsStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<GetRewardsRequest, GetRewardsResponse>;
  payReward(
    request: PayRewardRequest,
    callback: (error: ServiceError | null, response: PayRewardResponse) => void,
  ): ClientUnaryCall;
  payReward(
    request: PayRewardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PayRewardResponse) => void,
  ): ClientUnaryCall;
  payReward(
    request: PayRewardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PayRewardResponse) => void,
  ): ClientUnaryCall;
  getPaidRewards(
    request: GetPaidRewardsRequest,
    callback: (
      error: ServiceError | null,
      response: GetPaidRewardsResponse,
    ) => void,
  ): ClientUnaryCall;
  getPaidRewards(
    request: GetPaidRewardsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetPaidRewardsResponse,
    ) => void,
  ): ClientUnaryCall;
  getPaidRewards(
    request: GetPaidRewardsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetPaidRewardsResponse,
    ) => void,
  ): ClientUnaryCall;
  getPaidRewardsStream(): ClientDuplexStream<
    GetPaidRewardsRequest,
    GetPaidRewardsResponse
  >;
  getPaidRewardsStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<GetPaidRewardsRequest, GetPaidRewardsResponse>;
  getPaidRewardsStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<GetPaidRewardsRequest, GetPaidRewardsResponse>;
}

export const RewardServiceClient = makeGenericClientConstructor(
  RewardServiceService,
  'item.RewardService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): RewardServiceClient;
  service: typeof RewardServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
