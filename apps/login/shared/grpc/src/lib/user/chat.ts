// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: chat.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { Conversation, DefaultResponse, Message } from './user-common';

export const protobufPackage = 'user';

export interface CreateConversationRequest {
  /** 계정 ID */
  account1: string;
  /** 계정 ID */
  account2: string;
}

export interface CreateConversationResponse {
  success: boolean;
  errorMessage: string;
  /** 생성된 대화 정보 */
  conversation?: Conversation | undefined;
}

export interface GetConversationsRequest {
  /** 계정 ID */
  accountId: string;
}

export interface GetConversationsResponse {
  success: boolean;
  errorMessage: string;
  /** 대화 목록 */
  conversations: Conversation[];
}

export interface OrderingConversationRequest {
  /** 계정 ID */
  accountId: string;
  /** 대화 ID 목록 */
  conversationIds: string[];
}

export interface ExitConversationRequest {
  /** 대화 ID */
  conversationId: string;
  /** 계정 ID */
  accountId: string;
}

export interface SendMessageRequest {
  /** 대화 ID */
  conversationId: string;
  /** 계정 ID */
  accountId: string;
  /** 메시지 내용 */
  message: string;
}

export interface SendMessageResponse {
  success: boolean;
  errorMessage: string;
  /** 아이템 사용 여부 */
  useItem: boolean;
  /** 남은 쪽지 수 */
  remainCount: number;
  /** 전송된 메시지 정보 */
  message?: Message | undefined;
}

export interface GetMessageRequest {
  /** 대화 ID */
  conversationId: string;
  /** 계정 ID */
  accountId: string;
  /** 마지막 읽은 시간 */
  lastReadAt: string;
  page: number;
  countPerPage: number;
}

export interface GetMessageResponse {
  success: boolean;
  errorMessage: string;
  /** 메시지 목록 */
  messages: Message[];
}

export interface EmotionRequest {
  /** 메시지 ID */
  messageId: string;
  /** 계정 ID */
  accountId: string;
  /** 감정 표현 (예: "happy", "sad") */
  emotion: string;
}

function createBaseCreateConversationRequest(): CreateConversationRequest {
  return { account1: '', account2: '' };
}

export const CreateConversationRequest = {
  encode(
    message: CreateConversationRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.account1 !== '') {
      writer.uint32(10).string(message.account1);
    }
    if (message.account2 !== '') {
      writer.uint32(18).string(message.account2);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateConversationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account1 = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account2 = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConversationRequest {
    return {
      account1: isSet(object.account1)
        ? globalThis.String(object.account1)
        : '',
      account2: isSet(object.account2)
        ? globalThis.String(object.account2)
        : '',
    };
  },

  toJSON(message: CreateConversationRequest): unknown {
    const obj: any = {};
    if (message.account1 !== '') {
      obj.account1 = message.account1;
    }
    if (message.account2 !== '') {
      obj.account2 = message.account2;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateConversationRequest>, I>>(
    base?: I,
  ): CreateConversationRequest {
    return CreateConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateConversationRequest>, I>>(
    object: I,
  ): CreateConversationRequest {
    const message = createBaseCreateConversationRequest();
    message.account1 = object.account1 ?? '';
    message.account2 = object.account2 ?? '';
    return message;
  },
};

function createBaseCreateConversationResponse(): CreateConversationResponse {
  return { success: false, errorMessage: '', conversation: undefined };
}

export const CreateConversationResponse = {
  encode(
    message: CreateConversationResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.conversation !== undefined) {
      Conversation.encode(
        message.conversation,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateConversationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConversationResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      conversation: isSet(object.conversation)
        ? Conversation.fromJSON(object.conversation)
        : undefined,
    };
  },

  toJSON(message: CreateConversationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.conversation !== undefined) {
      obj.conversation = Conversation.toJSON(message.conversation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateConversationResponse>, I>>(
    base?: I,
  ): CreateConversationResponse {
    return CreateConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateConversationResponse>, I>>(
    object: I,
  ): CreateConversationResponse {
    const message = createBaseCreateConversationResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.conversation =
      object.conversation !== undefined && object.conversation !== null
        ? Conversation.fromPartial(object.conversation)
        : undefined;
    return message;
  },
};

function createBaseGetConversationsRequest(): GetConversationsRequest {
  return { accountId: '' };
}

export const GetConversationsRequest = {
  encode(
    message: GetConversationsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetConversationsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationsRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
    };
  },

  toJSON(message: GetConversationsRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationsRequest>, I>>(
    base?: I,
  ): GetConversationsRequest {
    return GetConversationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationsRequest>, I>>(
    object: I,
  ): GetConversationsRequest {
    const message = createBaseGetConversationsRequest();
    message.accountId = object.accountId ?? '';
    return message;
  },
};

function createBaseGetConversationsResponse(): GetConversationsResponse {
  return { success: false, errorMessage: '', conversations: [] };
}

export const GetConversationsResponse = {
  encode(
    message: GetConversationsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetConversationsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conversations.push(
            Conversation.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      conversations: globalThis.Array.isArray(object?.conversations)
        ? object.conversations.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetConversationsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.conversations?.length) {
      obj.conversations = message.conversations.map(e =>
        Conversation.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationsResponse>, I>>(
    base?: I,
  ): GetConversationsResponse {
    return GetConversationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationsResponse>, I>>(
    object: I,
  ): GetConversationsResponse {
    const message = createBaseGetConversationsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.conversations =
      object.conversations?.map(e => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderingConversationRequest(): OrderingConversationRequest {
  return { accountId: '', conversationIds: [] };
}

export const OrderingConversationRequest = {
  encode(
    message: OrderingConversationRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    for (const v of message.conversationIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OrderingConversationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderingConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversationIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderingConversationRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      conversationIds: globalThis.Array.isArray(object?.conversationIds)
        ? object.conversationIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OrderingConversationRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.conversationIds?.length) {
      obj.conversationIds = message.conversationIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderingConversationRequest>, I>>(
    base?: I,
  ): OrderingConversationRequest {
    return OrderingConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderingConversationRequest>, I>>(
    object: I,
  ): OrderingConversationRequest {
    const message = createBaseOrderingConversationRequest();
    message.accountId = object.accountId ?? '';
    message.conversationIds = object.conversationIds?.map(e => e) || [];
    return message;
  },
};

function createBaseExitConversationRequest(): ExitConversationRequest {
  return { conversationId: '', accountId: '' };
}

export const ExitConversationRequest = {
  encode(
    message: ExitConversationRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ExitConversationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitConversationRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
    };
  },

  toJSON(message: ExitConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExitConversationRequest>, I>>(
    base?: I,
  ): ExitConversationRequest {
    return ExitConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExitConversationRequest>, I>>(
    object: I,
  ): ExitConversationRequest {
    const message = createBaseExitConversationRequest();
    message.conversationId = object.conversationId ?? '';
    message.accountId = object.accountId ?? '';
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { conversationId: '', accountId: '', message: '' };
}

export const SendMessageRequest = {
  encode(
    message: SendMessageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SendMessageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageRequest>, I>>(
    base?: I,
  ): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(
    object: I,
  ): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.conversationId = object.conversationId ?? '';
    message.accountId = object.accountId ?? '';
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseSendMessageResponse(): SendMessageResponse {
  return {
    success: false,
    errorMessage: '',
    useItem: false,
    remainCount: 0,
    message: undefined,
  };
}

export const SendMessageResponse = {
  encode(
    message: SendMessageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.useItem !== false) {
      writer.uint32(24).bool(message.useItem);
    }
    if (message.remainCount !== 0) {
      writer.uint32(32).int32(message.remainCount);
    }
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SendMessageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.useItem = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.remainCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      useItem: isSet(object.useItem)
        ? globalThis.Boolean(object.useItem)
        : false,
      remainCount: isSet(object.remainCount)
        ? globalThis.Number(object.remainCount)
        : 0,
      message: isSet(object.message)
        ? Message.fromJSON(object.message)
        : undefined,
    };
  },

  toJSON(message: SendMessageResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.useItem !== false) {
      obj.useItem = message.useItem;
    }
    if (message.remainCount !== 0) {
      obj.remainCount = Math.round(message.remainCount);
    }
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResponse>, I>>(
    base?: I,
  ): SendMessageResponse {
    return SendMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResponse>, I>>(
    object: I,
  ): SendMessageResponse {
    const message = createBaseSendMessageResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.useItem = object.useItem ?? false;
    message.remainCount = object.remainCount ?? 0;
    message.message =
      object.message !== undefined && object.message !== null
        ? Message.fromPartial(object.message)
        : undefined;
    return message;
  },
};

function createBaseGetMessageRequest(): GetMessageRequest {
  return {
    conversationId: '',
    accountId: '',
    lastReadAt: '',
    page: 0,
    countPerPage: 0,
  };
}

export const GetMessageRequest = {
  encode(
    message: GetMessageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.lastReadAt !== '') {
      writer.uint32(26).string(message.lastReadAt);
    }
    if (message.page !== 0) {
      writer.uint32(32).int32(message.page);
    }
    if (message.countPerPage !== 0) {
      writer.uint32(40).int32(message.countPerPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastReadAt = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.countPerPage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessageRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      lastReadAt: isSet(object.lastReadAt)
        ? globalThis.String(object.lastReadAt)
        : '',
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      countPerPage: isSet(object.countPerPage)
        ? globalThis.Number(object.countPerPage)
        : 0,
    };
  },

  toJSON(message: GetMessageRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.lastReadAt !== '') {
      obj.lastReadAt = message.lastReadAt;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.countPerPage !== 0) {
      obj.countPerPage = Math.round(message.countPerPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessageRequest>, I>>(
    base?: I,
  ): GetMessageRequest {
    return GetMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessageRequest>, I>>(
    object: I,
  ): GetMessageRequest {
    const message = createBaseGetMessageRequest();
    message.conversationId = object.conversationId ?? '';
    message.accountId = object.accountId ?? '';
    message.lastReadAt = object.lastReadAt ?? '';
    message.page = object.page ?? 0;
    message.countPerPage = object.countPerPage ?? 0;
    return message;
  },
};

function createBaseGetMessageResponse(): GetMessageResponse {
  return { success: false, errorMessage: '', messages: [] };
}

export const GetMessageResponse = {
  encode(
    message: GetMessageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetMessageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessageResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => Message.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMessageResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map(e => Message.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessageResponse>, I>>(
    base?: I,
  ): GetMessageResponse {
    return GetMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessageResponse>, I>>(
    object: I,
  ): GetMessageResponse {
    const message = createBaseGetMessageResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.messages = object.messages?.map(e => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEmotionRequest(): EmotionRequest {
  return { messageId: '', accountId: '', emotion: '' };
}

export const EmotionRequest = {
  encode(
    message: EmotionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.messageId !== '') {
      writer.uint32(10).string(message.messageId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.emotion !== '') {
      writer.uint32(26).string(message.emotion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmotionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmotionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emotion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmotionRequest {
    return {
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      emotion: isSet(object.emotion) ? globalThis.String(object.emotion) : '',
    };
  },

  toJSON(message: EmotionRequest): unknown {
    const obj: any = {};
    if (message.messageId !== '') {
      obj.messageId = message.messageId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.emotion !== '') {
      obj.emotion = message.emotion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmotionRequest>, I>>(
    base?: I,
  ): EmotionRequest {
    return EmotionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmotionRequest>, I>>(
    object: I,
  ): EmotionRequest {
    const message = createBaseEmotionRequest();
    message.messageId = object.messageId ?? '';
    message.accountId = object.accountId ?? '';
    message.emotion = object.emotion ?? '';
    return message;
  },
};

export type ChatServiceService = typeof ChatServiceService;
export const ChatServiceService = {
  /** 대화 생성 */
  createConversation: {
    path: '/user.ChatService/CreateConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateConversationRequest) =>
      Buffer.from(CreateConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CreateConversationRequest.decode(value),
    responseSerialize: (value: CreateConversationResponse) =>
      Buffer.from(CreateConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CreateConversationResponse.decode(value),
  },
  /** 대화 목록 조회 */
  getConversations: {
    path: '/user.ChatService/GetConversations',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConversationsRequest) =>
      Buffer.from(GetConversationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GetConversationsRequest.decode(value),
    responseSerialize: (value: GetConversationsResponse) =>
      Buffer.from(GetConversationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetConversationsResponse.decode(value),
  },
  /** 대화 목록 정렬 */
  orderingConversation: {
    path: '/user.ChatService/OrderingConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OrderingConversationRequest) =>
      Buffer.from(OrderingConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      OrderingConversationRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 대화 나가기 */
  exitConversation: {
    path: '/user.ChatService/ExitConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExitConversationRequest) =>
      Buffer.from(ExitConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      ExitConversationRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 메시지 전송 */
  sendMessage: {
    path: '/user.ChatService/SendMessage',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest) =>
      Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: SendMessageResponse) =>
      Buffer.from(SendMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendMessageResponse.decode(value),
  },
  /** 채팅 메시지 조회 */
  getMessage: {
    path: '/user.ChatService/GetMessage',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMessageRequest) =>
      Buffer.from(GetMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetMessageRequest.decode(value),
    responseSerialize: (value: GetMessageResponse) =>
      Buffer.from(GetMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetMessageResponse.decode(value),
  },
  /** 감정 표현 */
  emotion: {
    path: '/user.ChatService/Emotion',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmotionRequest) =>
      Buffer.from(EmotionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmotionRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
} as const;

export interface ChatServiceServer extends UntypedServiceImplementation {
  /** 대화 생성 */
  createConversation: handleUnaryCall<
    CreateConversationRequest,
    CreateConversationResponse
  >;
  /** 대화 목록 조회 */
  getConversations: handleUnaryCall<
    GetConversationsRequest,
    GetConversationsResponse
  >;
  /** 대화 목록 정렬 */
  orderingConversation: handleUnaryCall<
    OrderingConversationRequest,
    DefaultResponse
  >;
  /** 대화 나가기 */
  exitConversation: handleUnaryCall<ExitConversationRequest, DefaultResponse>;
  /** 메시지 전송 */
  sendMessage: handleUnaryCall<SendMessageRequest, SendMessageResponse>;
  /** 채팅 메시지 조회 */
  getMessage: handleUnaryCall<GetMessageRequest, GetMessageResponse>;
  /** 감정 표현 */
  emotion: handleUnaryCall<EmotionRequest, DefaultResponse>;
}

export interface ChatServiceClient extends Client {
  /** 대화 생성 */
  createConversation(
    request: CreateConversationRequest,
    callback: (
      error: ServiceError | null,
      response: CreateConversationResponse,
    ) => void,
  ): ClientUnaryCall;
  createConversation(
    request: CreateConversationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CreateConversationResponse,
    ) => void,
  ): ClientUnaryCall;
  createConversation(
    request: CreateConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CreateConversationResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 대화 목록 조회 */
  getConversations(
    request: GetConversationsRequest,
    callback: (
      error: ServiceError | null,
      response: GetConversationsResponse,
    ) => void,
  ): ClientUnaryCall;
  getConversations(
    request: GetConversationsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetConversationsResponse,
    ) => void,
  ): ClientUnaryCall;
  getConversations(
    request: GetConversationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetConversationsResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 대화 목록 정렬 */
  orderingConversation(
    request: OrderingConversationRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  orderingConversation(
    request: OrderingConversationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  orderingConversation(
    request: OrderingConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 대화 나가기 */
  exitConversation(
    request: ExitConversationRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  exitConversation(
    request: ExitConversationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  exitConversation(
    request: ExitConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 메시지 전송 */
  sendMessage(
    request: SendMessageRequest,
    callback: (
      error: ServiceError | null,
      response: SendMessageResponse,
    ) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: SendMessageResponse,
    ) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: SendMessageResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 채팅 메시지 조회 */
  getMessage(
    request: GetMessageRequest,
    callback: (
      error: ServiceError | null,
      response: GetMessageResponse,
    ) => void,
  ): ClientUnaryCall;
  getMessage(
    request: GetMessageRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetMessageResponse,
    ) => void,
  ): ClientUnaryCall;
  getMessage(
    request: GetMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetMessageResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 감정 표현 */
  emotion(
    request: EmotionRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  emotion(
    request: EmotionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  emotion(
    request: EmotionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
}

export const ChatServiceClient = makeGenericClientConstructor(
  ChatServiceService,
  'user.ChatService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): ChatServiceClient;
  service: typeof ChatServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
