// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: user-common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';

export const protobufPackage = 'user';

export enum FriendRequestState {
  FRS_NONE = 0,
  FRS_PENDING = 1,
  FRS_ACCEPTED = 2,
  FRS_REJECTED = 3,
  FRS_EXPIRED = 4,
  FRS_CANCELED = 5,
  UNRECOGNIZED = -1,
}

export function friendRequestStateFromJSON(object: any): FriendRequestState {
  switch (object) {
    case 0:
    case 'FRS_NONE':
      return FriendRequestState.FRS_NONE;
    case 1:
    case 'FRS_PENDING':
      return FriendRequestState.FRS_PENDING;
    case 2:
    case 'FRS_ACCEPTED':
      return FriendRequestState.FRS_ACCEPTED;
    case 3:
    case 'FRS_REJECTED':
      return FriendRequestState.FRS_REJECTED;
    case 4:
    case 'FRS_EXPIRED':
      return FriendRequestState.FRS_EXPIRED;
    case 5:
    case 'FRS_CANCELED':
      return FriendRequestState.FRS_CANCELED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return FriendRequestState.UNRECOGNIZED;
  }
}

export function friendRequestStateToJSON(object: FriendRequestState): string {
  switch (object) {
    case FriendRequestState.FRS_NONE:
      return 'FRS_NONE';
    case FriendRequestState.FRS_PENDING:
      return 'FRS_PENDING';
    case FriendRequestState.FRS_ACCEPTED:
      return 'FRS_ACCEPTED';
    case FriendRequestState.FRS_REJECTED:
      return 'FRS_REJECTED';
    case FriendRequestState.FRS_EXPIRED:
      return 'FRS_EXPIRED';
    case FriendRequestState.FRS_CANCELED:
      return 'FRS_CANCELED';
    case FriendRequestState.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/**
 * ======================================== //
 * enum
 */
export enum AccountType {
  NONE = 0,
  ID = 1,
  GOOGLE = 2,
  APPLE = 3,
  NAVER = 4,
  KAKAO = 5,
  TEST = 99,
  UNRECOGNIZED = -1,
}

export function accountTypeFromJSON(object: any): AccountType {
  switch (object) {
    case 0:
    case 'NONE':
      return AccountType.NONE;
    case 1:
    case 'ID':
      return AccountType.ID;
    case 2:
    case 'GOOGLE':
      return AccountType.GOOGLE;
    case 3:
    case 'APPLE':
      return AccountType.APPLE;
    case 4:
    case 'NAVER':
      return AccountType.NAVER;
    case 5:
    case 'KAKAO':
      return AccountType.KAKAO;
    case 99:
    case 'TEST':
      return AccountType.TEST;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return AccountType.UNRECOGNIZED;
  }
}

export function accountTypeToJSON(object: AccountType): string {
  switch (object) {
    case AccountType.NONE:
      return 'NONE';
    case AccountType.ID:
      return 'ID';
    case AccountType.GOOGLE:
      return 'GOOGLE';
    case AccountType.APPLE:
      return 'APPLE';
    case AccountType.NAVER:
      return 'NAVER';
    case AccountType.KAKAO:
      return 'KAKAO';
    case AccountType.TEST:
      return 'TEST';
    case AccountType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum ActionType {
  NONE_STATE = 0,
  SIGN_UP = 1,
  SIGN_IN = 2,
  SIGN_OUT = 3,
  SIGN_FAIL = 4,
  UPDATE = 5,
  WITHDRAWAL = 6,
  PAUSE = 7,
  DISABLE = 8,
  DEACTIVE = 9,
  DORMANT = 10,
  RE_VERIFY = 11,
  LOSS_LIMIT = 12,
  GAME_PAUSE = 13,
  MARKETING_AGREE = 14,
  MARKETING_DISAGREE = 15,
  TERMS_AGREE = 16,
  TERMS_UPDATE = 17,
  TRANSFER_ACCOUNT = 18,
  UNRECOGNIZED = -1,
}

export function actionTypeFromJSON(object: any): ActionType {
  switch (object) {
    case 0:
    case 'NONE_STATE':
      return ActionType.NONE_STATE;
    case 1:
    case 'SIGN_UP':
      return ActionType.SIGN_UP;
    case 2:
    case 'SIGN_IN':
      return ActionType.SIGN_IN;
    case 3:
    case 'SIGN_OUT':
      return ActionType.SIGN_OUT;
    case 4:
    case 'SIGN_FAIL':
      return ActionType.SIGN_FAIL;
    case 5:
    case 'UPDATE':
      return ActionType.UPDATE;
    case 6:
    case 'WITHDRAWAL':
      return ActionType.WITHDRAWAL;
    case 7:
    case 'PAUSE':
      return ActionType.PAUSE;
    case 8:
    case 'DISABLE':
      return ActionType.DISABLE;
    case 9:
    case 'DEACTIVE':
      return ActionType.DEACTIVE;
    case 10:
    case 'DORMANT':
      return ActionType.DORMANT;
    case 11:
    case 'RE_VERIFY':
      return ActionType.RE_VERIFY;
    case 12:
    case 'LOSS_LIMIT':
      return ActionType.LOSS_LIMIT;
    case 13:
    case 'GAME_PAUSE':
      return ActionType.GAME_PAUSE;
    case 14:
    case 'MARKETING_AGREE':
      return ActionType.MARKETING_AGREE;
    case 15:
    case 'MARKETING_DISAGREE':
      return ActionType.MARKETING_DISAGREE;
    case 16:
    case 'TERMS_AGREE':
      return ActionType.TERMS_AGREE;
    case 17:
    case 'TERMS_UPDATE':
      return ActionType.TERMS_UPDATE;
    case 18:
    case 'TRANSFER_ACCOUNT':
      return ActionType.TRANSFER_ACCOUNT;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ActionType.UNRECOGNIZED;
  }
}

export function actionTypeToJSON(object: ActionType): string {
  switch (object) {
    case ActionType.NONE_STATE:
      return 'NONE_STATE';
    case ActionType.SIGN_UP:
      return 'SIGN_UP';
    case ActionType.SIGN_IN:
      return 'SIGN_IN';
    case ActionType.SIGN_OUT:
      return 'SIGN_OUT';
    case ActionType.SIGN_FAIL:
      return 'SIGN_FAIL';
    case ActionType.UPDATE:
      return 'UPDATE';
    case ActionType.WITHDRAWAL:
      return 'WITHDRAWAL';
    case ActionType.PAUSE:
      return 'PAUSE';
    case ActionType.DISABLE:
      return 'DISABLE';
    case ActionType.DEACTIVE:
      return 'DEACTIVE';
    case ActionType.DORMANT:
      return 'DORMANT';
    case ActionType.RE_VERIFY:
      return 'RE_VERIFY';
    case ActionType.LOSS_LIMIT:
      return 'LOSS_LIMIT';
    case ActionType.GAME_PAUSE:
      return 'GAME_PAUSE';
    case ActionType.MARKETING_AGREE:
      return 'MARKETING_AGREE';
    case ActionType.MARKETING_DISAGREE:
      return 'MARKETING_DISAGREE';
    case ActionType.TERMS_AGREE:
      return 'TERMS_AGREE';
    case ActionType.TERMS_UPDATE:
      return 'TERMS_UPDATE';
    case ActionType.TRANSFER_ACCOUNT:
      return 'TRANSFER_ACCOUNT';
    case ActionType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/**
 * ======================================== //
 * structure
 */
export interface User {
  userId: string;
  reVerifyAt: string;
  gamePauseAt: string;
  /** 손실한도 설정 bigint */
  lossLimit: string;
  /** 탈퇴시간 */
  withdrawal: string;
  /** 일시정지 해제시간 */
  pause: string;
  /** 영구정지 여부 */
  disable: boolean;
  /** 휴면계정 여부 */
  dormant: boolean;
  /** 계정 이용 제한 여부 */
  isPublic: boolean;
  /** 삭제 여부 */
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  verifyAt: string;
}

export interface Account {
  userId: string;
  accountId: string;
  firebaseUid: string;
  /** 고유 코드 (계정 생성 시 발급) 대문자+0-9 7자리 */
  uniqueCode: string;
  accountType: AccountType;
  /** 계정명 */
  accountName: string;
  /** 닉네임 */
  nickname: string;
  /** 연속 로그인 일수 */
  continuousDay: number;
  /** 탈퇴시간 */
  withdrawal: string;
  /** 일시정지 해제시간 */
  pause: string;
  /** 영구정지 여부 */
  disable: boolean;
  /** 휴면계정 여부 */
  dormant: boolean;
  /** 계정 이용 제한 여부 */
  isPublic: boolean;
  /** 삭제 여부 */
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface UserLogs {
  /** bigint */
  userLogId: string;
  userId: string;
  actionType: ActionType;
  json: string;
  createdAt: string;
}

export interface AccountLogs {
  /** bigint */
  accountLogId: string;
  userId: string;
  accountId: string;
  actionType: ActionType;
  json: string;
  createdAt: string;
}

export interface FriendRequest {
  /** 친구 요청 ID */
  friendReqId: string;
  /** 요청하는 사람 */
  fromAccount: string;
  /** 요청받는 사람 */
  toAccount: string;
  /** 요청 메시지 */
  message: string;
  state: FriendRequestState;
  /** 요청 시간 */
  createdAt: string;
  /** 요청하는 사람 정보 */
  from?: Friend | undefined;
  /** 요청받는 사람 정보 */
  to?: Friend | undefined;
}

export interface Friend {
  /** 친구 ID */
  accountId: string;
  /** 친구 닉네임 */
  nickname: string;
  /** 친구 클래스 */
  class: string;
  /** 친구 프로필 이미지 URL */
  profile: string;
  /** 보유 금액 bigint */
  amount: string;
  /** 온라인 여부 */
  isOnline: boolean;
  /** 마지막 로그인 시간 */
  lastLoginAt: string;
  /** 업데이트 시간 */
  updatedAt: string;
  /** 친구 관계 ID */
  friendShipId: string;
}

export interface Block {
  /** 차단 ID */
  blockId: string;
  /** 차단된 account 정보 */
  friend?: Friend | undefined;
}

export interface Participant {
  /** 참여자 ID */
  participantId: string;
  /** 대화 ID */
  conversationId: string;
  /** 계정 ID */
  accountId: string;
  /** 마지막 읽은 시간 */
  lastReadAt: string;
  /** 마지막 메시지 ID */
  lastMessageId: string;
  /** 나간 시간 */
  exitAt: string;
  /** 정렬 순서 */
  ordered: number;
  /** 차단 여부 */
  isBlocked: boolean;
  /** 활성화 여부 */
  isActive: boolean;
  /** 생성 시간 */
  createdAt: string;
  /** 수정 시간 */
  updatedAt: string;
  /** 친구 정보 */
  profile?: Friend | undefined;
  /** 마지막 메시지 */
  lastMessage?: Message | undefined;
  /** 메시지 목록 */
  messages: Message[];
}

export interface Message {
  /** 메시지 ID */
  messageId: string;
  /** 대화 ID */
  conversationId: string;
  /** 계정 ID */
  accountId: string;
  /** 메시지 내용 */
  message: string;
  /** 이모티콘 */
  emotion: string;
  /** 메시지 전송 시간 */
  createdAt: string;
  /** 수정 시간 */
  updatedAt: string;
}

export interface Conversation {
  /** 대화 ID */
  conversationId: string;
  /** 계정 ID */
  account1: string;
  /** 계정 ID */
  account2: string;
  /** 친구 여부 */
  isFriend: boolean;
  /** 길드 여부 */
  isGuild: boolean;
  /** 활성화 여부 */
  isActive: boolean;
  /** 생성 시간 */
  createdAt: string;
  /** 수정 시간 */
  updatedAt: string;
  /** 참여자 목록 */
  participants: Participant[];
  /** 메시지 목록 */
  messages: Message[];
}

/**
 * ======================================== //
 * req & res
 */
export interface DefaultResponse {
  success: boolean;
  errorMessage: string;
}

function createBaseUser(): User {
  return {
    userId: '',
    reVerifyAt: '',
    gamePauseAt: '',
    lossLimit: '',
    withdrawal: '',
    pause: '',
    disable: false,
    dormant: false,
    isPublic: false,
    isActive: false,
    createdAt: '',
    updatedAt: '',
    verifyAt: '',
  };
}

export const User = {
  encode(
    message: User,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.reVerifyAt !== '') {
      writer.uint32(18).string(message.reVerifyAt);
    }
    if (message.gamePauseAt !== '') {
      writer.uint32(26).string(message.gamePauseAt);
    }
    if (message.lossLimit !== '') {
      writer.uint32(34).string(message.lossLimit);
    }
    if (message.withdrawal !== '') {
      writer.uint32(42).string(message.withdrawal);
    }
    if (message.pause !== '') {
      writer.uint32(50).string(message.pause);
    }
    if (message.disable !== false) {
      writer.uint32(56).bool(message.disable);
    }
    if (message.dormant !== false) {
      writer.uint32(64).bool(message.dormant);
    }
    if (message.isPublic !== false) {
      writer.uint32(72).bool(message.isPublic);
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(90).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(98).string(message.updatedAt);
    }
    if (message.verifyAt !== '') {
      writer.uint32(106).string(message.verifyAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reVerifyAt = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gamePauseAt = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lossLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.withdrawal = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pause = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.disable = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.dormant = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.verifyAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      reVerifyAt: isSet(object.reVerifyAt)
        ? globalThis.String(object.reVerifyAt)
        : '',
      gamePauseAt: isSet(object.gamePauseAt)
        ? globalThis.String(object.gamePauseAt)
        : '',
      lossLimit: isSet(object.lossLimit)
        ? globalThis.String(object.lossLimit)
        : '',
      withdrawal: isSet(object.withdrawal)
        ? globalThis.String(object.withdrawal)
        : '',
      pause: isSet(object.pause) ? globalThis.String(object.pause) : '',
      disable: isSet(object.disable)
        ? globalThis.Boolean(object.disable)
        : false,
      dormant: isSet(object.dormant)
        ? globalThis.Boolean(object.dormant)
        : false,
      isPublic: isSet(object.isPublic)
        ? globalThis.Boolean(object.isPublic)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      verifyAt: isSet(object.verifyAt)
        ? globalThis.String(object.verifyAt)
        : '',
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.reVerifyAt !== '') {
      obj.reVerifyAt = message.reVerifyAt;
    }
    if (message.gamePauseAt !== '') {
      obj.gamePauseAt = message.gamePauseAt;
    }
    if (message.lossLimit !== '') {
      obj.lossLimit = message.lossLimit;
    }
    if (message.withdrawal !== '') {
      obj.withdrawal = message.withdrawal;
    }
    if (message.pause !== '') {
      obj.pause = message.pause;
    }
    if (message.disable !== false) {
      obj.disable = message.disable;
    }
    if (message.dormant !== false) {
      obj.dormant = message.dormant;
    }
    if (message.isPublic !== false) {
      obj.isPublic = message.isPublic;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.verifyAt !== '') {
      obj.verifyAt = message.verifyAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.userId = object.userId ?? '';
    message.reVerifyAt = object.reVerifyAt ?? '';
    message.gamePauseAt = object.gamePauseAt ?? '';
    message.lossLimit = object.lossLimit ?? '';
    message.withdrawal = object.withdrawal ?? '';
    message.pause = object.pause ?? '';
    message.disable = object.disable ?? false;
    message.dormant = object.dormant ?? false;
    message.isPublic = object.isPublic ?? false;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.verifyAt = object.verifyAt ?? '';
    return message;
  },
};

function createBaseAccount(): Account {
  return {
    userId: '',
    accountId: '',
    firebaseUid: '',
    uniqueCode: '',
    accountType: 0,
    accountName: '',
    nickname: '',
    continuousDay: 0,
    withdrawal: '',
    pause: '',
    disable: false,
    dormant: false,
    isPublic: false,
    isActive: false,
    createdAt: '',
    updatedAt: '',
  };
}

export const Account = {
  encode(
    message: Account,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    if (message.firebaseUid !== '') {
      writer.uint32(26).string(message.firebaseUid);
    }
    if (message.uniqueCode !== '') {
      writer.uint32(34).string(message.uniqueCode);
    }
    if (message.accountType !== 0) {
      writer.uint32(40).int32(message.accountType);
    }
    if (message.accountName !== '') {
      writer.uint32(50).string(message.accountName);
    }
    if (message.nickname !== '') {
      writer.uint32(58).string(message.nickname);
    }
    if (message.continuousDay !== 0) {
      writer.uint32(64).int32(message.continuousDay);
    }
    if (message.withdrawal !== '') {
      writer.uint32(74).string(message.withdrawal);
    }
    if (message.pause !== '') {
      writer.uint32(82).string(message.pause);
    }
    if (message.disable !== false) {
      writer.uint32(88).bool(message.disable);
    }
    if (message.dormant !== false) {
      writer.uint32(96).bool(message.dormant);
    }
    if (message.isPublic !== false) {
      writer.uint32(104).bool(message.isPublic);
    }
    if (message.isActive !== false) {
      writer.uint32(112).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Account {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.firebaseUid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.uniqueCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.accountType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.accountName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.nickname = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.continuousDay = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.withdrawal = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.pause = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.disable = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.dormant = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      firebaseUid: isSet(object.firebaseUid)
        ? globalThis.String(object.firebaseUid)
        : '',
      uniqueCode: isSet(object.uniqueCode)
        ? globalThis.String(object.uniqueCode)
        : '',
      accountType: isSet(object.accountType)
        ? accountTypeFromJSON(object.accountType)
        : 0,
      accountName: isSet(object.accountName)
        ? globalThis.String(object.accountName)
        : '',
      nickname: isSet(object.nickname)
        ? globalThis.String(object.nickname)
        : '',
      continuousDay: isSet(object.continuousDay)
        ? globalThis.Number(object.continuousDay)
        : 0,
      withdrawal: isSet(object.withdrawal)
        ? globalThis.String(object.withdrawal)
        : '',
      pause: isSet(object.pause) ? globalThis.String(object.pause) : '',
      disable: isSet(object.disable)
        ? globalThis.Boolean(object.disable)
        : false,
      dormant: isSet(object.dormant)
        ? globalThis.Boolean(object.dormant)
        : false,
      isPublic: isSet(object.isPublic)
        ? globalThis.Boolean(object.isPublic)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.firebaseUid !== '') {
      obj.firebaseUid = message.firebaseUid;
    }
    if (message.uniqueCode !== '') {
      obj.uniqueCode = message.uniqueCode;
    }
    if (message.accountType !== 0) {
      obj.accountType = accountTypeToJSON(message.accountType);
    }
    if (message.accountName !== '') {
      obj.accountName = message.accountName;
    }
    if (message.nickname !== '') {
      obj.nickname = message.nickname;
    }
    if (message.continuousDay !== 0) {
      obj.continuousDay = Math.round(message.continuousDay);
    }
    if (message.withdrawal !== '') {
      obj.withdrawal = message.withdrawal;
    }
    if (message.pause !== '') {
      obj.pause = message.pause;
    }
    if (message.disable !== false) {
      obj.disable = message.disable;
    }
    if (message.dormant !== false) {
      obj.dormant = message.dormant;
    }
    if (message.isPublic !== false) {
      obj.isPublic = message.isPublic;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account>, I>>(base?: I): Account {
    return Account.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account>, I>>(object: I): Account {
    const message = createBaseAccount();
    message.userId = object.userId ?? '';
    message.accountId = object.accountId ?? '';
    message.firebaseUid = object.firebaseUid ?? '';
    message.uniqueCode = object.uniqueCode ?? '';
    message.accountType = object.accountType ?? 0;
    message.accountName = object.accountName ?? '';
    message.nickname = object.nickname ?? '';
    message.continuousDay = object.continuousDay ?? 0;
    message.withdrawal = object.withdrawal ?? '';
    message.pause = object.pause ?? '';
    message.disable = object.disable ?? false;
    message.dormant = object.dormant ?? false;
    message.isPublic = object.isPublic ?? false;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    return message;
  },
};

function createBaseUserLogs(): UserLogs {
  return { userLogId: '', userId: '', actionType: 0, json: '', createdAt: '' };
}

export const UserLogs = {
  encode(
    message: UserLogs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userLogId !== '') {
      writer.uint32(10).string(message.userLogId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.actionType !== 0) {
      writer.uint32(24).int32(message.actionType);
    }
    if (message.json !== '') {
      writer.uint32(34).string(message.json);
    }
    if (message.createdAt !== '') {
      writer.uint32(42).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserLogs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userLogId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.json = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserLogs {
    return {
      userLogId: isSet(object.userLogId)
        ? globalThis.String(object.userLogId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      actionType: isSet(object.actionType)
        ? actionTypeFromJSON(object.actionType)
        : 0,
      json: isSet(object.json) ? globalThis.String(object.json) : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
    };
  },

  toJSON(message: UserLogs): unknown {
    const obj: any = {};
    if (message.userLogId !== '') {
      obj.userLogId = message.userLogId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.actionType !== 0) {
      obj.actionType = actionTypeToJSON(message.actionType);
    }
    if (message.json !== '') {
      obj.json = message.json;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserLogs>, I>>(base?: I): UserLogs {
    return UserLogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserLogs>, I>>(object: I): UserLogs {
    const message = createBaseUserLogs();
    message.userLogId = object.userLogId ?? '';
    message.userId = object.userId ?? '';
    message.actionType = object.actionType ?? 0;
    message.json = object.json ?? '';
    message.createdAt = object.createdAt ?? '';
    return message;
  },
};

function createBaseAccountLogs(): AccountLogs {
  return {
    accountLogId: '',
    userId: '',
    accountId: '',
    actionType: 0,
    json: '',
    createdAt: '',
  };
}

export const AccountLogs = {
  encode(
    message: AccountLogs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountLogId !== '') {
      writer.uint32(10).string(message.accountLogId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.accountId !== '') {
      writer.uint32(26).string(message.accountId);
    }
    if (message.actionType !== 0) {
      writer.uint32(32).int32(message.actionType);
    }
    if (message.json !== '') {
      writer.uint32(42).string(message.json);
    }
    if (message.createdAt !== '') {
      writer.uint32(50).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountLogs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountLogId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.json = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountLogs {
    return {
      accountLogId: isSet(object.accountLogId)
        ? globalThis.String(object.accountLogId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      actionType: isSet(object.actionType)
        ? actionTypeFromJSON(object.actionType)
        : 0,
      json: isSet(object.json) ? globalThis.String(object.json) : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
    };
  },

  toJSON(message: AccountLogs): unknown {
    const obj: any = {};
    if (message.accountLogId !== '') {
      obj.accountLogId = message.accountLogId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.actionType !== 0) {
      obj.actionType = actionTypeToJSON(message.actionType);
    }
    if (message.json !== '') {
      obj.json = message.json;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountLogs>, I>>(base?: I): AccountLogs {
    return AccountLogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountLogs>, I>>(
    object: I,
  ): AccountLogs {
    const message = createBaseAccountLogs();
    message.accountLogId = object.accountLogId ?? '';
    message.userId = object.userId ?? '';
    message.accountId = object.accountId ?? '';
    message.actionType = object.actionType ?? 0;
    message.json = object.json ?? '';
    message.createdAt = object.createdAt ?? '';
    return message;
  },
};

function createBaseFriendRequest(): FriendRequest {
  return {
    friendReqId: '',
    fromAccount: '',
    toAccount: '',
    message: '',
    state: 0,
    createdAt: '',
    from: undefined,
    to: undefined,
  };
}

export const FriendRequest = {
  encode(
    message: FriendRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.friendReqId !== '') {
      writer.uint32(10).string(message.friendReqId);
    }
    if (message.fromAccount !== '') {
      writer.uint32(18).string(message.fromAccount);
    }
    if (message.toAccount !== '') {
      writer.uint32(26).string(message.toAccount);
    }
    if (message.message !== '') {
      writer.uint32(34).string(message.message);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.createdAt !== '') {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.from !== undefined) {
      Friend.encode(message.from, writer.uint32(58).fork()).join();
    }
    if (message.to !== undefined) {
      Friend.encode(message.to, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.friendReqId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromAccount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toAccount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.from = Friend.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.to = Friend.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendRequest {
    return {
      friendReqId: isSet(object.friendReqId)
        ? globalThis.String(object.friendReqId)
        : '',
      fromAccount: isSet(object.fromAccount)
        ? globalThis.String(object.fromAccount)
        : '',
      toAccount: isSet(object.toAccount)
        ? globalThis.String(object.toAccount)
        : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      state: isSet(object.state) ? friendRequestStateFromJSON(object.state) : 0,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      from: isSet(object.from) ? Friend.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Friend.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: FriendRequest): unknown {
    const obj: any = {};
    if (message.friendReqId !== '') {
      obj.friendReqId = message.friendReqId;
    }
    if (message.fromAccount !== '') {
      obj.fromAccount = message.fromAccount;
    }
    if (message.toAccount !== '') {
      obj.toAccount = message.toAccount;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.state !== 0) {
      obj.state = friendRequestStateToJSON(message.state);
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.from !== undefined) {
      obj.from = Friend.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Friend.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendRequest>, I>>(
    base?: I,
  ): FriendRequest {
    return FriendRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendRequest>, I>>(
    object: I,
  ): FriendRequest {
    const message = createBaseFriendRequest();
    message.friendReqId = object.friendReqId ?? '';
    message.fromAccount = object.fromAccount ?? '';
    message.toAccount = object.toAccount ?? '';
    message.message = object.message ?? '';
    message.state = object.state ?? 0;
    message.createdAt = object.createdAt ?? '';
    message.from =
      object.from !== undefined && object.from !== null
        ? Friend.fromPartial(object.from)
        : undefined;
    message.to =
      object.to !== undefined && object.to !== null
        ? Friend.fromPartial(object.to)
        : undefined;
    return message;
  },
};

function createBaseFriend(): Friend {
  return {
    accountId: '',
    nickname: '',
    class: '',
    profile: '',
    amount: '',
    isOnline: false,
    lastLoginAt: '',
    updatedAt: '',
    friendShipId: '',
  };
}

export const Friend = {
  encode(
    message: Friend,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.nickname !== '') {
      writer.uint32(18).string(message.nickname);
    }
    if (message.class !== '') {
      writer.uint32(26).string(message.class);
    }
    if (message.profile !== '') {
      writer.uint32(34).string(message.profile);
    }
    if (message.amount !== '') {
      writer.uint32(42).string(message.amount);
    }
    if (message.isOnline !== false) {
      writer.uint32(48).bool(message.isOnline);
    }
    if (message.lastLoginAt !== '') {
      writer.uint32(58).string(message.lastLoginAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(66).string(message.updatedAt);
    }
    if (message.friendShipId !== '') {
      writer.uint32(74).string(message.friendShipId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Friend {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nickname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.class = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.profile = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isOnline = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastLoginAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.friendShipId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Friend {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      nickname: isSet(object.nickname)
        ? globalThis.String(object.nickname)
        : '',
      class: isSet(object.class) ? globalThis.String(object.class) : '',
      profile: isSet(object.profile) ? globalThis.String(object.profile) : '',
      amount: isSet(object.amount) ? globalThis.String(object.amount) : '',
      isOnline: isSet(object.isOnline)
        ? globalThis.Boolean(object.isOnline)
        : false,
      lastLoginAt: isSet(object.lastLoginAt)
        ? globalThis.String(object.lastLoginAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      friendShipId: isSet(object.friendShipId)
        ? globalThis.String(object.friendShipId)
        : '',
    };
  },

  toJSON(message: Friend): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.nickname !== '') {
      obj.nickname = message.nickname;
    }
    if (message.class !== '') {
      obj.class = message.class;
    }
    if (message.profile !== '') {
      obj.profile = message.profile;
    }
    if (message.amount !== '') {
      obj.amount = message.amount;
    }
    if (message.isOnline !== false) {
      obj.isOnline = message.isOnline;
    }
    if (message.lastLoginAt !== '') {
      obj.lastLoginAt = message.lastLoginAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.friendShipId !== '') {
      obj.friendShipId = message.friendShipId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Friend>, I>>(base?: I): Friend {
    return Friend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Friend>, I>>(object: I): Friend {
    const message = createBaseFriend();
    message.accountId = object.accountId ?? '';
    message.nickname = object.nickname ?? '';
    message.class = object.class ?? '';
    message.profile = object.profile ?? '';
    message.amount = object.amount ?? '';
    message.isOnline = object.isOnline ?? false;
    message.lastLoginAt = object.lastLoginAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.friendShipId = object.friendShipId ?? '';
    return message;
  },
};

function createBaseBlock(): Block {
  return { blockId: '', friend: undefined };
}

export const Block = {
  encode(
    message: Block,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.blockId !== '') {
      writer.uint32(10).string(message.blockId);
    }
    if (message.friend !== undefined) {
      Friend.encode(message.friend, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Block {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.friend = Friend.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      blockId: isSet(object.blockId) ? globalThis.String(object.blockId) : '',
      friend: isSet(object.friend) ? Friend.fromJSON(object.friend) : undefined,
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.blockId !== '') {
      obj.blockId = message.blockId;
    }
    if (message.friend !== undefined) {
      obj.friend = Friend.toJSON(message.friend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Block>, I>>(base?: I): Block {
    return Block.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Block>, I>>(object: I): Block {
    const message = createBaseBlock();
    message.blockId = object.blockId ?? '';
    message.friend =
      object.friend !== undefined && object.friend !== null
        ? Friend.fromPartial(object.friend)
        : undefined;
    return message;
  },
};

function createBaseParticipant(): Participant {
  return {
    participantId: '',
    conversationId: '',
    accountId: '',
    lastReadAt: '',
    lastMessageId: '',
    exitAt: '',
    ordered: 0,
    isBlocked: false,
    isActive: false,
    createdAt: '',
    updatedAt: '',
    profile: undefined,
    lastMessage: undefined,
    messages: [],
  };
}

export const Participant = {
  encode(
    message: Participant,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.participantId !== '') {
      writer.uint32(10).string(message.participantId);
    }
    if (message.conversationId !== '') {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.accountId !== '') {
      writer.uint32(26).string(message.accountId);
    }
    if (message.lastReadAt !== '') {
      writer.uint32(34).string(message.lastReadAt);
    }
    if (message.lastMessageId !== '') {
      writer.uint32(42).string(message.lastMessageId);
    }
    if (message.exitAt !== '') {
      writer.uint32(50).string(message.exitAt);
    }
    if (message.ordered !== 0) {
      writer.uint32(56).int32(message.ordered);
    }
    if (message.isBlocked !== false) {
      writer.uint32(64).bool(message.isBlocked);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(90).string(message.updatedAt);
    }
    if (message.profile !== undefined) {
      Friend.encode(message.profile, writer.uint32(98).fork()).join();
    }
    if (message.lastMessage !== undefined) {
      Message.encode(message.lastMessage, writer.uint32(106).fork()).join();
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Participant {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participantId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastReadAt = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastMessageId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.exitAt = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ordered = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isBlocked = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.profile = Friend.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.lastMessage = Message.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Participant {
    return {
      participantId: isSet(object.participantId)
        ? globalThis.String(object.participantId)
        : '',
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      lastReadAt: isSet(object.lastReadAt)
        ? globalThis.String(object.lastReadAt)
        : '',
      lastMessageId: isSet(object.lastMessageId)
        ? globalThis.String(object.lastMessageId)
        : '',
      exitAt: isSet(object.exitAt) ? globalThis.String(object.exitAt) : '',
      ordered: isSet(object.ordered) ? globalThis.Number(object.ordered) : 0,
      isBlocked: isSet(object.isBlocked)
        ? globalThis.Boolean(object.isBlocked)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      profile: isSet(object.profile)
        ? Friend.fromJSON(object.profile)
        : undefined,
      lastMessage: isSet(object.lastMessage)
        ? Message.fromJSON(object.lastMessage)
        : undefined,
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => Message.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Participant): unknown {
    const obj: any = {};
    if (message.participantId !== '') {
      obj.participantId = message.participantId;
    }
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.lastReadAt !== '') {
      obj.lastReadAt = message.lastReadAt;
    }
    if (message.lastMessageId !== '') {
      obj.lastMessageId = message.lastMessageId;
    }
    if (message.exitAt !== '') {
      obj.exitAt = message.exitAt;
    }
    if (message.ordered !== 0) {
      obj.ordered = Math.round(message.ordered);
    }
    if (message.isBlocked !== false) {
      obj.isBlocked = message.isBlocked;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.profile !== undefined) {
      obj.profile = Friend.toJSON(message.profile);
    }
    if (message.lastMessage !== undefined) {
      obj.lastMessage = Message.toJSON(message.lastMessage);
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map(e => Message.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Participant>, I>>(base?: I): Participant {
    return Participant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Participant>, I>>(
    object: I,
  ): Participant {
    const message = createBaseParticipant();
    message.participantId = object.participantId ?? '';
    message.conversationId = object.conversationId ?? '';
    message.accountId = object.accountId ?? '';
    message.lastReadAt = object.lastReadAt ?? '';
    message.lastMessageId = object.lastMessageId ?? '';
    message.exitAt = object.exitAt ?? '';
    message.ordered = object.ordered ?? 0;
    message.isBlocked = object.isBlocked ?? false;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.profile =
      object.profile !== undefined && object.profile !== null
        ? Friend.fromPartial(object.profile)
        : undefined;
    message.lastMessage =
      object.lastMessage !== undefined && object.lastMessage !== null
        ? Message.fromPartial(object.lastMessage)
        : undefined;
    message.messages = object.messages?.map(e => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    messageId: '',
    conversationId: '',
    accountId: '',
    message: '',
    emotion: '',
    createdAt: '',
    updatedAt: '',
  };
}

export const Message = {
  encode(
    message: Message,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.messageId !== '') {
      writer.uint32(10).string(message.messageId);
    }
    if (message.conversationId !== '') {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.accountId !== '') {
      writer.uint32(26).string(message.accountId);
    }
    if (message.message !== '') {
      writer.uint32(34).string(message.message);
    }
    if (message.emotion !== '') {
      writer.uint32(42).string(message.emotion);
    }
    if (message.createdAt !== '') {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.emotion = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : '',
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      emotion: isSet(object.emotion) ? globalThis.String(object.emotion) : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.messageId !== '') {
      obj.messageId = message.messageId;
    }
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.emotion !== '') {
      obj.emotion = message.emotion;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.messageId = object.messageId ?? '';
    message.conversationId = object.conversationId ?? '';
    message.accountId = object.accountId ?? '';
    message.message = object.message ?? '';
    message.emotion = object.emotion ?? '';
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    return message;
  },
};

function createBaseConversation(): Conversation {
  return {
    conversationId: '',
    account1: '',
    account2: '',
    isFriend: false,
    isGuild: false,
    isActive: false,
    createdAt: '',
    updatedAt: '',
    participants: [],
    messages: [],
  };
}

export const Conversation = {
  encode(
    message: Conversation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.account1 !== '') {
      writer.uint32(18).string(message.account1);
    }
    if (message.account2 !== '') {
      writer.uint32(26).string(message.account2);
    }
    if (message.isFriend !== false) {
      writer.uint32(32).bool(message.isFriend);
    }
    if (message.isGuild !== false) {
      writer.uint32(40).bool(message.isGuild);
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    if (message.createdAt !== '') {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== '') {
      writer.uint32(66).string(message.updatedAt);
    }
    for (const v of message.participants) {
      Participant.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account1 = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.account2 = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isFriend = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isGuild = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.participants.push(
            Participant.decode(reader, reader.uint32()),
          );
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      account1: isSet(object.account1)
        ? globalThis.String(object.account1)
        : '',
      account2: isSet(object.account2)
        ? globalThis.String(object.account2)
        : '',
      isFriend: isSet(object.isFriend)
        ? globalThis.Boolean(object.isFriend)
        : false,
      isGuild: isSet(object.isGuild)
        ? globalThis.Boolean(object.isGuild)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : '',
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => Participant.fromJSON(e))
        : [],
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => Message.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.account1 !== '') {
      obj.account1 = message.account1;
    }
    if (message.account2 !== '') {
      obj.account2 = message.account2;
    }
    if (message.isFriend !== false) {
      obj.isFriend = message.isFriend;
    }
    if (message.isGuild !== false) {
      obj.isGuild = message.isGuild;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== '') {
      obj.updatedAt = message.updatedAt;
    }
    if (message.participants?.length) {
      obj.participants = message.participants.map(e => Participant.toJSON(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map(e => Message.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversation>, I>>(
    base?: I,
  ): Conversation {
    return Conversation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversation>, I>>(
    object: I,
  ): Conversation {
    const message = createBaseConversation();
    message.conversationId = object.conversationId ?? '';
    message.account1 = object.account1 ?? '';
    message.account2 = object.account2 ?? '';
    message.isFriend = object.isFriend ?? false;
    message.isGuild = object.isGuild ?? false;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? '';
    message.updatedAt = object.updatedAt ?? '';
    message.participants =
      object.participants?.map(e => Participant.fromPartial(e)) || [];
    message.messages = object.messages?.map(e => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDefaultResponse(): DefaultResponse {
  return { success: false, errorMessage: '' };
}

export const DefaultResponse = {
  encode(
    message: DefaultResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
    };
  },

  toJSON(message: DefaultResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    base?: I,
  ): DefaultResponse {
    return DefaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultResponse>, I>>(
    object: I,
  ): DefaultResponse {
    const message = createBaseDefaultResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
