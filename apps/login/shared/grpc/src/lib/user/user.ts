// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.29.3
// source: user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { Account, DefaultResponse, User, UserLogs } from './user-common';

export const protobufPackage = 'user';

export interface TokenRequest {
  token: string;
  userId: string;
}

export interface TokenResponse {
  success: boolean;
  errorMessage: string;
  token: string;
}

export interface UserIdParam {
  userId: string;
}

export interface IsExistUserRequest {
  userId: string;
  name: string;
  telCode: number;
  tel: number;
}

export interface IsExistUserResponse {
  success: boolean;
  errorMessage: string;
  isExist: boolean;
  userId: string;
  isActive: boolean;
  isPublic: boolean;
  isDormant: boolean;
  isDisable: boolean;
  isWithdrawal: boolean;
  isPause: boolean;
  isGamePause: boolean;
}

export interface GetUserRequest {
  userId: string;
  accountId: string;
}

export interface GetUserResponse {
  success: boolean;
  errorMessage: string;
  user?: User | undefined;
  accountCount: number;
}

export interface UserInfoRequest {
  /** 본인인증 후 서버에서 발급한 커스텀 토큰 */
  token: string;
  userId: string;
  /** 본명 - 본인인증 */
  name: string;
  /** 국가번호 */
  telCode: number;
  /** 전화번호, 국가번호 제외, 01012345678 -> 1012345678 */
  tel: number;
}

export interface GetAllAccontResponse {
  success: boolean;
  errorMessage: string;
  account: Account[];
}

export interface VerifyUserRequest {
  /**
   * @param auth
   * 인증사에 따라 추가 정보 첨부
   * {
   *   comType: 'dreamsecurity', 'inicis' | 'nice' | 'danal' | 'kcb' | 'portone' | ... ,
   *   if(dreamsecurity) data : <auth request data>
   *   if(inicis)  data: { url: 'https://...', txId: '...', token: '...' } // 이니시스
   *   if(portone) data: { identityVerificationId: ' ... ' } // 포트원
   * }
   */
  auth: string;
}

export interface VerifyUserResponse {
  success: boolean;
  errorMessage: string;
  data: string;
}

/**
 * @param data
 * 인증사에 따라 추가 정보
 * if(dreamsecurity) { serviceId: string; encClientTxId: string; }
 */
export interface IdentityRequestParamResponse {
  success: boolean;
  errorMessage: string;
  /** 인증사에 따라 추가 정보 */
  data: string;
}

export interface CreateUserResponse {
  success: boolean;
  errorMessage: string;
  userId: string;
  /** new, exist */
  type: string;
  /** 서버에서 발급한 토큰 */
  token: string;
  /** 본인인증 이름 */
  name: string;
  /** 본인인증 전화번호 | 시작 0 제외, 01012345678 -> 1012345678 */
  tel: string;
}

export interface SetLossLimitRequest {
  userId: string;
  /** 손실한도 설정 bigint */
  lossLimit: string;
}

export interface UserStateRequest {
  userId: string;
  datetime: string;
  /** true: 탈퇴, 휴면 | false: 탈퇴 취소, 휴면 해제 */
  state: boolean;
  reasonType: number;
  reasonText: string;
}

export interface GetUserLogsResponse {
  success: boolean;
  errorMessage: string;
  userLogs: UserLogs[];
}

export interface GetUserLossLimitByAccountIdsRequest {
  /** 계정 ID 목록 */
  accountIds: string[];
}

export interface UserLossLimit {
  /** 계정 ID */
  accountId: string;
  /** 유저 ID */
  userId: string;
  /** 손실한도 설정 bigint */
  lossLimit: string;
}

export interface GetUserLossLimitByAccountIdsResponse {
  success: boolean;
  errorMessage: string;
  /** 계정별 손실한도 정보 */
  userLossLimits: UserLossLimit[];
}

export interface AdminGetAllUserRequest {
  page: number;
  countPerPage: number;
}

export interface AdminGetAllUserResponse {
  success: boolean;
  errorMessage: string;
  users: User[];
}

export interface TransferAccountRequest {
  accountId: string;
  targetUserId: string;
  currentUserId: string;
}

function createBaseTokenRequest(): TokenRequest {
  return { token: '', userId: '' };
}

export const TokenRequest = {
  encode(
    message: TokenRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.token !== '') {
      writer.uint32(10).string(message.token);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: TokenRequest): unknown {
    const obj: any = {};
    if (message.token !== '') {
      obj.token = message.token;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRequest>, I>>(
    base?: I,
  ): TokenRequest {
    return TokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRequest>, I>>(
    object: I,
  ): TokenRequest {
    const message = createBaseTokenRequest();
    message.token = object.token ?? '';
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseTokenResponse(): TokenResponse {
  return { success: false, errorMessage: '', token: '' };
}

export const TokenResponse = {
  encode(
    message: TokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.token !== '') {
      writer.uint32(26).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
    };
  },

  toJSON(message: TokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenResponse>, I>>(
    base?: I,
  ): TokenResponse {
    return TokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenResponse>, I>>(
    object: I,
  ): TokenResponse {
    const message = createBaseTokenResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.token = object.token ?? '';
    return message;
  },
};

function createBaseUserIdParam(): UserIdParam {
  return { userId: '' };
}

export const UserIdParam = {
  encode(
    message: UserIdParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserIdParam {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserIdParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserIdParam {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: UserIdParam): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserIdParam>, I>>(base?: I): UserIdParam {
    return UserIdParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserIdParam>, I>>(
    object: I,
  ): UserIdParam {
    const message = createBaseUserIdParam();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseIsExistUserRequest(): IsExistUserRequest {
  return { userId: '', name: '', telCode: 0, tel: 0 };
}

export const IsExistUserRequest = {
  encode(
    message: IsExistUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.telCode !== 0) {
      writer.uint32(24).int32(message.telCode);
    }
    if (message.tel !== 0) {
      writer.uint32(32).int64(message.tel);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IsExistUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsExistUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.telCode = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.tel = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsExistUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      telCode: isSet(object.telCode) ? globalThis.Number(object.telCode) : 0,
      tel: isSet(object.tel) ? globalThis.Number(object.tel) : 0,
    };
  },

  toJSON(message: IsExistUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.telCode !== 0) {
      obj.telCode = Math.round(message.telCode);
    }
    if (message.tel !== 0) {
      obj.tel = Math.round(message.tel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsExistUserRequest>, I>>(
    base?: I,
  ): IsExistUserRequest {
    return IsExistUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsExistUserRequest>, I>>(
    object: I,
  ): IsExistUserRequest {
    const message = createBaseIsExistUserRequest();
    message.userId = object.userId ?? '';
    message.name = object.name ?? '';
    message.telCode = object.telCode ?? 0;
    message.tel = object.tel ?? 0;
    return message;
  },
};

function createBaseIsExistUserResponse(): IsExistUserResponse {
  return {
    success: false,
    errorMessage: '',
    isExist: false,
    userId: '',
    isActive: false,
    isPublic: false,
    isDormant: false,
    isDisable: false,
    isWithdrawal: false,
    isPause: false,
    isGamePause: false,
  };
}

export const IsExistUserResponse = {
  encode(
    message: IsExistUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.isExist !== false) {
      writer.uint32(24).bool(message.isExist);
    }
    if (message.userId !== '') {
      writer.uint32(34).string(message.userId);
    }
    if (message.isActive !== false) {
      writer.uint32(40).bool(message.isActive);
    }
    if (message.isPublic !== false) {
      writer.uint32(48).bool(message.isPublic);
    }
    if (message.isDormant !== false) {
      writer.uint32(56).bool(message.isDormant);
    }
    if (message.isDisable !== false) {
      writer.uint32(64).bool(message.isDisable);
    }
    if (message.isWithdrawal !== false) {
      writer.uint32(72).bool(message.isWithdrawal);
    }
    if (message.isPause !== false) {
      writer.uint32(80).bool(message.isPause);
    }
    if (message.isGamePause !== false) {
      writer.uint32(88).bool(message.isGamePause);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IsExistUserResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsExistUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isExist = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isDormant = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isDisable = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isWithdrawal = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isPause = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isGamePause = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsExistUserResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      isExist: isSet(object.isExist)
        ? globalThis.Boolean(object.isExist)
        : false,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      isPublic: isSet(object.isPublic)
        ? globalThis.Boolean(object.isPublic)
        : false,
      isDormant: isSet(object.isDormant)
        ? globalThis.Boolean(object.isDormant)
        : false,
      isDisable: isSet(object.isDisable)
        ? globalThis.Boolean(object.isDisable)
        : false,
      isWithdrawal: isSet(object.isWithdrawal)
        ? globalThis.Boolean(object.isWithdrawal)
        : false,
      isPause: isSet(object.isPause)
        ? globalThis.Boolean(object.isPause)
        : false,
      isGamePause: isSet(object.isGamePause)
        ? globalThis.Boolean(object.isGamePause)
        : false,
    };
  },

  toJSON(message: IsExistUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.isExist !== false) {
      obj.isExist = message.isExist;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isPublic !== false) {
      obj.isPublic = message.isPublic;
    }
    if (message.isDormant !== false) {
      obj.isDormant = message.isDormant;
    }
    if (message.isDisable !== false) {
      obj.isDisable = message.isDisable;
    }
    if (message.isWithdrawal !== false) {
      obj.isWithdrawal = message.isWithdrawal;
    }
    if (message.isPause !== false) {
      obj.isPause = message.isPause;
    }
    if (message.isGamePause !== false) {
      obj.isGamePause = message.isGamePause;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsExistUserResponse>, I>>(
    base?: I,
  ): IsExistUserResponse {
    return IsExistUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsExistUserResponse>, I>>(
    object: I,
  ): IsExistUserResponse {
    const message = createBaseIsExistUserResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.isExist = object.isExist ?? false;
    message.userId = object.userId ?? '';
    message.isActive = object.isActive ?? false;
    message.isPublic = object.isPublic ?? false;
    message.isDormant = object.isDormant ?? false;
    message.isDisable = object.isDisable ?? false;
    message.isWithdrawal = object.isWithdrawal ?? false;
    message.isPause = object.isPause ?? false;
    message.isGamePause = object.isGamePause ?? false;
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { userId: '', accountId: '' };
}

export const GetUserRequest = {
  encode(
    message: GetUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.accountId !== '') {
      writer.uint32(18).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
    };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(
    base?: I,
  ): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(
    object: I,
  ): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.userId = object.userId ?? '';
    message.accountId = object.accountId ?? '';
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { success: false, errorMessage: '', user: undefined, accountCount: 0 };
}

export const GetUserResponse = {
  encode(
    message: GetUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    if (message.accountCount !== 0) {
      writer.uint32(32).int32(message.accountCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.accountCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      accountCount: isSet(object.accountCount)
        ? globalThis.Number(object.accountCount)
        : 0,
    };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.accountCount !== 0) {
      obj.accountCount = Math.round(message.accountCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(
    base?: I,
  ): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(
    object: I,
  ): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.user =
      object.user !== undefined && object.user !== null
        ? User.fromPartial(object.user)
        : undefined;
    message.accountCount = object.accountCount ?? 0;
    return message;
  },
};

function createBaseUserInfoRequest(): UserInfoRequest {
  return { token: '', userId: '', name: '', telCode: 0, tel: 0 };
}

export const UserInfoRequest = {
  encode(
    message: UserInfoRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.token !== '') {
      writer.uint32(10).string(message.token);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.name !== '') {
      writer.uint32(26).string(message.name);
    }
    if (message.telCode !== 0) {
      writer.uint32(32).int32(message.telCode);
    }
    if (message.tel !== 0) {
      writer.uint32(40).int64(message.tel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfoRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.telCode = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tel = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfoRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      telCode: isSet(object.telCode) ? globalThis.Number(object.telCode) : 0,
      tel: isSet(object.tel) ? globalThis.Number(object.tel) : 0,
    };
  },

  toJSON(message: UserInfoRequest): unknown {
    const obj: any = {};
    if (message.token !== '') {
      obj.token = message.token;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.telCode !== 0) {
      obj.telCode = Math.round(message.telCode);
    }
    if (message.tel !== 0) {
      obj.tel = Math.round(message.tel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfoRequest>, I>>(
    base?: I,
  ): UserInfoRequest {
    return UserInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfoRequest>, I>>(
    object: I,
  ): UserInfoRequest {
    const message = createBaseUserInfoRequest();
    message.token = object.token ?? '';
    message.userId = object.userId ?? '';
    message.name = object.name ?? '';
    message.telCode = object.telCode ?? 0;
    message.tel = object.tel ?? 0;
    return message;
  },
};

function createBaseGetAllAccontResponse(): GetAllAccontResponse {
  return { success: false, errorMessage: '', account: [] };
}

export const GetAllAccontResponse = {
  encode(
    message: GetAllAccontResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.account) {
      Account.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAllAccontResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllAccontResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.account.push(Account.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllAccontResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      account: globalThis.Array.isArray(object?.account)
        ? object.account.map((e: any) => Account.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllAccontResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.account?.length) {
      obj.account = message.account.map(e => Account.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllAccontResponse>, I>>(
    base?: I,
  ): GetAllAccontResponse {
    return GetAllAccontResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllAccontResponse>, I>>(
    object: I,
  ): GetAllAccontResponse {
    const message = createBaseGetAllAccontResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.account = object.account?.map(e => Account.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVerifyUserRequest(): VerifyUserRequest {
  return { auth: '' };
}

export const VerifyUserRequest = {
  encode(
    message: VerifyUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.auth !== '') {
      writer.uint32(10).string(message.auth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.auth = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserRequest {
    return { auth: isSet(object.auth) ? globalThis.String(object.auth) : '' };
  },

  toJSON(message: VerifyUserRequest): unknown {
    const obj: any = {};
    if (message.auth !== '') {
      obj.auth = message.auth;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(
    base?: I,
  ): VerifyUserRequest {
    return VerifyUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(
    object: I,
  ): VerifyUserRequest {
    const message = createBaseVerifyUserRequest();
    message.auth = object.auth ?? '';
    return message;
  },
};

function createBaseVerifyUserResponse(): VerifyUserResponse {
  return { success: false, errorMessage: '', data: '' };
}

export const VerifyUserResponse = {
  encode(
    message: VerifyUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.data !== '') {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): VerifyUserResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      data: isSet(object.data) ? globalThis.String(object.data) : '',
    };
  },

  toJSON(message: VerifyUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.data !== '') {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(
    base?: I,
  ): VerifyUserResponse {
    return VerifyUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(
    object: I,
  ): VerifyUserResponse {
    const message = createBaseVerifyUserResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.data = object.data ?? '';
    return message;
  },
};

function createBaseIdentityRequestParamResponse(): IdentityRequestParamResponse {
  return { success: false, errorMessage: '', data: '' };
}

export const IdentityRequestParamResponse = {
  encode(
    message: IdentityRequestParamResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.data !== '') {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IdentityRequestParamResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityRequestParamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityRequestParamResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      data: isSet(object.data) ? globalThis.String(object.data) : '',
    };
  },

  toJSON(message: IdentityRequestParamResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.data !== '') {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdentityRequestParamResponse>, I>>(
    base?: I,
  ): IdentityRequestParamResponse {
    return IdentityRequestParamResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdentityRequestParamResponse>, I>>(
    object: I,
  ): IdentityRequestParamResponse {
    const message = createBaseIdentityRequestParamResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.data = object.data ?? '';
    return message;
  },
};

function createBaseCreateUserResponse(): CreateUserResponse {
  return {
    success: false,
    errorMessage: '',
    userId: '',
    type: '',
    token: '',
    name: '',
    tel: '',
  };
}

export const CreateUserResponse = {
  encode(
    message: CreateUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.userId !== '') {
      writer.uint32(26).string(message.userId);
    }
    if (message.type !== '') {
      writer.uint32(34).string(message.type);
    }
    if (message.token !== '') {
      writer.uint32(42).string(message.token);
    }
    if (message.name !== '') {
      writer.uint32(50).string(message.name);
    }
    if (message.tel !== '') {
      writer.uint32(58).string(message.tel);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateUserResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.token = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      token: isSet(object.token) ? globalThis.String(object.token) : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      tel: isSet(object.tel) ? globalThis.String(object.tel) : '',
    };
  },

  toJSON(message: CreateUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.tel !== '') {
      obj.tel = message.tel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserResponse>, I>>(
    base?: I,
  ): CreateUserResponse {
    return CreateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserResponse>, I>>(
    object: I,
  ): CreateUserResponse {
    const message = createBaseCreateUserResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.userId = object.userId ?? '';
    message.type = object.type ?? '';
    message.token = object.token ?? '';
    message.name = object.name ?? '';
    message.tel = object.tel ?? '';
    return message;
  },
};

function createBaseSetLossLimitRequest(): SetLossLimitRequest {
  return { userId: '', lossLimit: '' };
}

export const SetLossLimitRequest = {
  encode(
    message: SetLossLimitRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.lossLimit !== '') {
      writer.uint32(18).string(message.lossLimit);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SetLossLimitRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLossLimitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lossLimit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLossLimitRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      lossLimit: isSet(object.lossLimit)
        ? globalThis.String(object.lossLimit)
        : '',
    };
  },

  toJSON(message: SetLossLimitRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.lossLimit !== '') {
      obj.lossLimit = message.lossLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetLossLimitRequest>, I>>(
    base?: I,
  ): SetLossLimitRequest {
    return SetLossLimitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetLossLimitRequest>, I>>(
    object: I,
  ): SetLossLimitRequest {
    const message = createBaseSetLossLimitRequest();
    message.userId = object.userId ?? '';
    message.lossLimit = object.lossLimit ?? '';
    return message;
  },
};

function createBaseUserStateRequest(): UserStateRequest {
  return {
    userId: '',
    datetime: '',
    state: false,
    reasonType: 0,
    reasonText: '',
  };
}

export const UserStateRequest = {
  encode(
    message: UserStateRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.datetime !== '') {
      writer.uint32(18).string(message.datetime);
    }
    if (message.state !== false) {
      writer.uint32(24).bool(message.state);
    }
    if (message.reasonType !== 0) {
      writer.uint32(32).int32(message.reasonType);
    }
    if (message.reasonText !== '') {
      writer.uint32(42).string(message.reasonText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStateRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datetime = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reasonType = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reasonText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStateRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      datetime: isSet(object.datetime)
        ? globalThis.String(object.datetime)
        : '',
      state: isSet(object.state) ? globalThis.Boolean(object.state) : false,
      reasonType: isSet(object.reasonType)
        ? globalThis.Number(object.reasonType)
        : 0,
      reasonText: isSet(object.reasonText)
        ? globalThis.String(object.reasonText)
        : '',
    };
  },

  toJSON(message: UserStateRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.datetime !== '') {
      obj.datetime = message.datetime;
    }
    if (message.state !== false) {
      obj.state = message.state;
    }
    if (message.reasonType !== 0) {
      obj.reasonType = Math.round(message.reasonType);
    }
    if (message.reasonText !== '') {
      obj.reasonText = message.reasonText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStateRequest>, I>>(
    base?: I,
  ): UserStateRequest {
    return UserStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStateRequest>, I>>(
    object: I,
  ): UserStateRequest {
    const message = createBaseUserStateRequest();
    message.userId = object.userId ?? '';
    message.datetime = object.datetime ?? '';
    message.state = object.state ?? false;
    message.reasonType = object.reasonType ?? 0;
    message.reasonText = object.reasonText ?? '';
    return message;
  },
};

function createBaseGetUserLogsResponse(): GetUserLogsResponse {
  return { success: false, errorMessage: '', userLogs: [] };
}

export const GetUserLogsResponse = {
  encode(
    message: GetUserLogsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.userLogs) {
      UserLogs.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetUserLogsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userLogs.push(UserLogs.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserLogsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      userLogs: globalThis.Array.isArray(object?.userLogs)
        ? object.userLogs.map((e: any) => UserLogs.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetUserLogsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.userLogs?.length) {
      obj.userLogs = message.userLogs.map(e => UserLogs.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserLogsResponse>, I>>(
    base?: I,
  ): GetUserLogsResponse {
    return GetUserLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserLogsResponse>, I>>(
    object: I,
  ): GetUserLogsResponse {
    const message = createBaseGetUserLogsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.userLogs = object.userLogs?.map(e => UserLogs.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetUserLossLimitByAccountIdsRequest(): GetUserLossLimitByAccountIdsRequest {
  return { accountIds: [] };
}

export const GetUserLossLimitByAccountIdsRequest = {
  encode(
    message: GetUserLossLimitByAccountIdsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.accountIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetUserLossLimitByAccountIdsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserLossLimitByAccountIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserLossLimitByAccountIdsRequest {
    return {
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetUserLossLimitByAccountIdsRequest): unknown {
    const obj: any = {};
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserLossLimitByAccountIdsRequest>, I>>(
    base?: I,
  ): GetUserLossLimitByAccountIdsRequest {
    return GetUserLossLimitByAccountIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<GetUserLossLimitByAccountIdsRequest>, I>,
  >(object: I): GetUserLossLimitByAccountIdsRequest {
    const message = createBaseGetUserLossLimitByAccountIdsRequest();
    message.accountIds = object.accountIds?.map(e => e) || [];
    return message;
  },
};

function createBaseUserLossLimit(): UserLossLimit {
  return { accountId: '', userId: '', lossLimit: '' };
}

export const UserLossLimit = {
  encode(
    message: UserLossLimit,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.lossLimit !== '') {
      writer.uint32(26).string(message.lossLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserLossLimit {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserLossLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lossLimit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserLossLimit {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      lossLimit: isSet(object.lossLimit)
        ? globalThis.String(object.lossLimit)
        : '',
    };
  },

  toJSON(message: UserLossLimit): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.lossLimit !== '') {
      obj.lossLimit = message.lossLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserLossLimit>, I>>(
    base?: I,
  ): UserLossLimit {
    return UserLossLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserLossLimit>, I>>(
    object: I,
  ): UserLossLimit {
    const message = createBaseUserLossLimit();
    message.accountId = object.accountId ?? '';
    message.userId = object.userId ?? '';
    message.lossLimit = object.lossLimit ?? '';
    return message;
  },
};

function createBaseGetUserLossLimitByAccountIdsResponse(): GetUserLossLimitByAccountIdsResponse {
  return { success: false, errorMessage: '', userLossLimits: [] };
}

export const GetUserLossLimitByAccountIdsResponse = {
  encode(
    message: GetUserLossLimitByAccountIdsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.userLossLimits) {
      UserLossLimit.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetUserLossLimitByAccountIdsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserLossLimitByAccountIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userLossLimits.push(
            UserLossLimit.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserLossLimitByAccountIdsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      userLossLimits: globalThis.Array.isArray(object?.userLossLimits)
        ? object.userLossLimits.map((e: any) => UserLossLimit.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetUserLossLimitByAccountIdsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.userLossLimits?.length) {
      obj.userLossLimits = message.userLossLimits.map(e =>
        UserLossLimit.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserLossLimitByAccountIdsResponse>, I>>(
    base?: I,
  ): GetUserLossLimitByAccountIdsResponse {
    return GetUserLossLimitByAccountIdsResponse.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<DeepPartial<GetUserLossLimitByAccountIdsResponse>, I>,
  >(object: I): GetUserLossLimitByAccountIdsResponse {
    const message = createBaseGetUserLossLimitByAccountIdsResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.userLossLimits =
      object.userLossLimits?.map(e => UserLossLimit.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdminGetAllUserRequest(): AdminGetAllUserRequest {
  return { page: 0, countPerPage: 0 };
}

export const AdminGetAllUserRequest = {
  encode(
    message: AdminGetAllUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.countPerPage !== 0) {
      writer.uint32(16).int32(message.countPerPage);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AdminGetAllUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminGetAllUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.countPerPage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminGetAllUserRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      countPerPage: isSet(object.countPerPage)
        ? globalThis.Number(object.countPerPage)
        : 0,
    };
  },

  toJSON(message: AdminGetAllUserRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.countPerPage !== 0) {
      obj.countPerPage = Math.round(message.countPerPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminGetAllUserRequest>, I>>(
    base?: I,
  ): AdminGetAllUserRequest {
    return AdminGetAllUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminGetAllUserRequest>, I>>(
    object: I,
  ): AdminGetAllUserRequest {
    const message = createBaseAdminGetAllUserRequest();
    message.page = object.page ?? 0;
    message.countPerPage = object.countPerPage ?? 0;
    return message;
  },
};

function createBaseAdminGetAllUserResponse(): AdminGetAllUserResponse {
  return { success: false, errorMessage: '', users: [] };
}

export const AdminGetAllUserResponse = {
  encode(
    message: AdminGetAllUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.users) {
      User.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AdminGetAllUserResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminGetAllUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminGetAllUserResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : '',
      users: globalThis.Array.isArray(object?.users)
        ? object.users.map((e: any) => User.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AdminGetAllUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== '') {
      obj.errorMessage = message.errorMessage;
    }
    if (message.users?.length) {
      obj.users = message.users.map(e => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminGetAllUserResponse>, I>>(
    base?: I,
  ): AdminGetAllUserResponse {
    return AdminGetAllUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminGetAllUserResponse>, I>>(
    object: I,
  ): AdminGetAllUserResponse {
    const message = createBaseAdminGetAllUserResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? '';
    message.users = object.users?.map(e => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransferAccountRequest(): TransferAccountRequest {
  return { accountId: '', targetUserId: '', currentUserId: '' };
}

export const TransferAccountRequest = {
  encode(
    message: TransferAccountRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== '') {
      writer.uint32(10).string(message.accountId);
    }
    if (message.targetUserId !== '') {
      writer.uint32(18).string(message.targetUserId);
    }
    if (message.currentUserId !== '') {
      writer.uint32(26).string(message.currentUserId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TransferAccountRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currentUserId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferAccountRequest {
    return {
      accountId: isSet(object.accountId)
        ? globalThis.String(object.accountId)
        : '',
      targetUserId: isSet(object.targetUserId)
        ? globalThis.String(object.targetUserId)
        : '',
      currentUserId: isSet(object.currentUserId)
        ? globalThis.String(object.currentUserId)
        : '',
    };
  },

  toJSON(message: TransferAccountRequest): unknown {
    const obj: any = {};
    if (message.accountId !== '') {
      obj.accountId = message.accountId;
    }
    if (message.targetUserId !== '') {
      obj.targetUserId = message.targetUserId;
    }
    if (message.currentUserId !== '') {
      obj.currentUserId = message.currentUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferAccountRequest>, I>>(
    base?: I,
  ): TransferAccountRequest {
    return TransferAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferAccountRequest>, I>>(
    object: I,
  ): TransferAccountRequest {
    const message = createBaseTransferAccountRequest();
    message.accountId = object.accountId ?? '';
    message.targetUserId = object.targetUserId ?? '';
    message.currentUserId = object.currentUserId ?? '';
    return message;
  },
};

export type UserServiceService = typeof UserServiceService;
export const UserServiceService = {
  /** for Personal Identity Verification */
  getIdentityRequestParam: {
    path: '/user.UserService/GetIdentityRequestParam',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyUserRequest) =>
      Buffer.from(VerifyUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyUserRequest.decode(value),
    responseSerialize: (value: IdentityRequestParamResponse) =>
      Buffer.from(IdentityRequestParamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      IdentityRequestParamResponse.decode(value),
  },
  checkIdentityToken: {
    path: '/user.UserService/CheckIdentityToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyUserRequest) =>
      Buffer.from(VerifyUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyUserRequest.decode(value),
    responseSerialize: (value: VerifyUserResponse) =>
      Buffer.from(VerifyUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyUserResponse.decode(value),
  },
  /** basic CRUD */
  isExistUser: {
    path: '/user.UserService/IsExistUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IsExistUserRequest) =>
      Buffer.from(IsExistUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IsExistUserRequest.decode(value),
    responseSerialize: (value: IsExistUserResponse) =>
      Buffer.from(IsExistUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IsExistUserResponse.decode(value),
  },
  getUser: {
    path: '/user.UserService/GetUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserRequest) =>
      Buffer.from(GetUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserRequest.decode(value),
    responseSerialize: (value: GetUserResponse) =>
      Buffer.from(GetUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserResponse.decode(value),
  },
  /** need Personal Identity Verification */
  createUser: {
    path: '/user.UserService/CreateUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyUserRequest) =>
      Buffer.from(VerifyUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyUserRequest.decode(value),
    responseSerialize: (value: CreateUserResponse) =>
      Buffer.from(CreateUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateUserResponse.decode(value),
  },
  /** 본인인증 갱신 | 다른 본인인증이 필요한 경우 사용하여 토큰 발급 */
  refreshVerification: {
    path: '/user.UserService/RefreshVerification',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyUserRequest) =>
      Buffer.from(VerifyUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyUserRequest.decode(value),
    responseSerialize: (value: TokenResponse) =>
      Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TokenResponse.decode(value),
  },
  updateUser: {
    path: '/user.UserService/UpdateUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserInfoRequest) =>
      Buffer.from(UserInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserInfoRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 모든 계정 정보 조회 */
  getAllAccount: {
    path: '/user.UserService/GetAllAccount',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenRequest) =>
      Buffer.from(TokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenRequest.decode(value),
    responseSerialize: (value: GetAllAccontResponse) =>
      Buffer.from(GetAllAccontResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllAccontResponse.decode(value),
  },
  /** user management */
  withdrawal: {
    path: '/user.UserService/Withdrawal',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserStateRequest) =>
      Buffer.from(UserStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserStateRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 휴면계정 */
  dormant: {
    path: '/user.UserService/Dormant',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserStateRequest) =>
      Buffer.from(UserStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserStateRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 계정비활성화 */
  disable: {
    path: '/user.UserService/Disable',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserStateRequest) =>
      Buffer.from(UserStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserStateRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 게임 일시정지 */
  gamePause: {
    path: '/user.UserService/GamePause',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserStateRequest) =>
      Buffer.from(UserStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserStateRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 손실한도 설정 */
  setLossLimit: {
    path: '/user.UserService/SetLossLimit',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetLossLimitRequest) =>
      Buffer.from(SetLossLimitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SetLossLimitRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
  /** 유저 로그 조회 */
  getUserLogs: {
    path: '/user.UserService/GetUserLogs',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserIdParam) =>
      Buffer.from(UserIdParam.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserIdParam.decode(value),
    responseSerialize: (value: GetUserLogsResponse) =>
      Buffer.from(GetUserLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserLogsResponse.decode(value),
  },
  /** 계정별 손실한도 조회 */
  getUserLossLimitByAccountIds: {
    path: '/user.UserService/GetUserLossLimitByAccountIds',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserLossLimitByAccountIdsRequest) =>
      Buffer.from(GetUserLossLimitByAccountIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GetUserLossLimitByAccountIdsRequest.decode(value),
    responseSerialize: (value: GetUserLossLimitByAccountIdsResponse) =>
      Buffer.from(GetUserLossLimitByAccountIdsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetUserLossLimitByAccountIdsResponse.decode(value),
  },
  /** admin */
  adminGetAllUser: {
    path: '/user.UserService/AdminGetAllUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminGetAllUserRequest) =>
      Buffer.from(AdminGetAllUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdminGetAllUserRequest.decode(value),
    responseSerialize: (value: AdminGetAllUserResponse) =>
      Buffer.from(AdminGetAllUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      AdminGetAllUserResponse.decode(value),
  },
  /** not ready to release */
  transferAccount: {
    path: '/user.UserService/TransferAccount',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferAccountRequest) =>
      Buffer.from(TransferAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferAccountRequest.decode(value),
    responseSerialize: (value: DefaultResponse) =>
      Buffer.from(DefaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DefaultResponse.decode(value),
  },
} as const;

export interface UserServiceServer extends UntypedServiceImplementation {
  /** for Personal Identity Verification */
  getIdentityRequestParam: handleUnaryCall<
    VerifyUserRequest,
    IdentityRequestParamResponse
  >;
  checkIdentityToken: handleUnaryCall<VerifyUserRequest, VerifyUserResponse>;
  /** basic CRUD */
  isExistUser: handleUnaryCall<IsExistUserRequest, IsExistUserResponse>;
  getUser: handleUnaryCall<GetUserRequest, GetUserResponse>;
  /** need Personal Identity Verification */
  createUser: handleUnaryCall<VerifyUserRequest, CreateUserResponse>;
  /** 본인인증 갱신 | 다른 본인인증이 필요한 경우 사용하여 토큰 발급 */
  refreshVerification: handleUnaryCall<VerifyUserRequest, TokenResponse>;
  updateUser: handleUnaryCall<UserInfoRequest, DefaultResponse>;
  /** 모든 계정 정보 조회 */
  getAllAccount: handleUnaryCall<TokenRequest, GetAllAccontResponse>;
  /** user management */
  withdrawal: handleUnaryCall<UserStateRequest, DefaultResponse>;
  /** 휴면계정 */
  dormant: handleUnaryCall<UserStateRequest, DefaultResponse>;
  /** 계정비활성화 */
  disable: handleUnaryCall<UserStateRequest, DefaultResponse>;
  /** 게임 일시정지 */
  gamePause: handleUnaryCall<UserStateRequest, DefaultResponse>;
  /** 손실한도 설정 */
  setLossLimit: handleUnaryCall<SetLossLimitRequest, DefaultResponse>;
  /** 유저 로그 조회 */
  getUserLogs: handleUnaryCall<UserIdParam, GetUserLogsResponse>;
  /** 계정별 손실한도 조회 */
  getUserLossLimitByAccountIds: handleUnaryCall<
    GetUserLossLimitByAccountIdsRequest,
    GetUserLossLimitByAccountIdsResponse
  >;
  /** admin */
  adminGetAllUser: handleUnaryCall<
    AdminGetAllUserRequest,
    AdminGetAllUserResponse
  >;
  /** not ready to release */
  transferAccount: handleUnaryCall<TransferAccountRequest, DefaultResponse>;
}

export interface UserServiceClient extends Client {
  /** for Personal Identity Verification */
  getIdentityRequestParam(
    request: VerifyUserRequest,
    callback: (
      error: ServiceError | null,
      response: IdentityRequestParamResponse,
    ) => void,
  ): ClientUnaryCall;
  getIdentityRequestParam(
    request: VerifyUserRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: IdentityRequestParamResponse,
    ) => void,
  ): ClientUnaryCall;
  getIdentityRequestParam(
    request: VerifyUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: IdentityRequestParamResponse,
    ) => void,
  ): ClientUnaryCall;
  checkIdentityToken(
    request: VerifyUserRequest,
    callback: (
      error: ServiceError | null,
      response: VerifyUserResponse,
    ) => void,
  ): ClientUnaryCall;
  checkIdentityToken(
    request: VerifyUserRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: VerifyUserResponse,
    ) => void,
  ): ClientUnaryCall;
  checkIdentityToken(
    request: VerifyUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: VerifyUserResponse,
    ) => void,
  ): ClientUnaryCall;
  /** basic CRUD */
  isExistUser(
    request: IsExistUserRequest,
    callback: (
      error: ServiceError | null,
      response: IsExistUserResponse,
    ) => void,
  ): ClientUnaryCall;
  isExistUser(
    request: IsExistUserRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: IsExistUserResponse,
    ) => void,
  ): ClientUnaryCall;
  isExistUser(
    request: IsExistUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: IsExistUserResponse,
    ) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  /** need Personal Identity Verification */
  createUser(
    request: VerifyUserRequest,
    callback: (
      error: ServiceError | null,
      response: CreateUserResponse,
    ) => void,
  ): ClientUnaryCall;
  createUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CreateUserResponse,
    ) => void,
  ): ClientUnaryCall;
  createUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CreateUserResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 본인인증 갱신 | 다른 본인인증이 필요한 경우 사용하여 토큰 발급 */
  refreshVerification(
    request: VerifyUserRequest,
    callback: (error: ServiceError | null, response: TokenResponse) => void,
  ): ClientUnaryCall;
  refreshVerification(
    request: VerifyUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TokenResponse) => void,
  ): ClientUnaryCall;
  refreshVerification(
    request: VerifyUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TokenResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UserInfoRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UserInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UserInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 모든 계정 정보 조회 */
  getAllAccount(
    request: TokenRequest,
    callback: (
      error: ServiceError | null,
      response: GetAllAccontResponse,
    ) => void,
  ): ClientUnaryCall;
  getAllAccount(
    request: TokenRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetAllAccontResponse,
    ) => void,
  ): ClientUnaryCall;
  getAllAccount(
    request: TokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetAllAccontResponse,
    ) => void,
  ): ClientUnaryCall;
  /** user management */
  withdrawal(
    request: UserStateRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  withdrawal(
    request: UserStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  withdrawal(
    request: UserStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 휴면계정 */
  dormant(
    request: UserStateRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  dormant(
    request: UserStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  dormant(
    request: UserStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 계정비활성화 */
  disable(
    request: UserStateRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  disable(
    request: UserStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  disable(
    request: UserStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 게임 일시정지 */
  gamePause(
    request: UserStateRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  gamePause(
    request: UserStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  gamePause(
    request: UserStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 손실한도 설정 */
  setLossLimit(
    request: SetLossLimitRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  setLossLimit(
    request: SetLossLimitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  setLossLimit(
    request: SetLossLimitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  /** 유저 로그 조회 */
  getUserLogs(
    request: UserIdParam,
    callback: (
      error: ServiceError | null,
      response: GetUserLogsResponse,
    ) => void,
  ): ClientUnaryCall;
  getUserLogs(
    request: UserIdParam,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetUserLogsResponse,
    ) => void,
  ): ClientUnaryCall;
  getUserLogs(
    request: UserIdParam,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetUserLogsResponse,
    ) => void,
  ): ClientUnaryCall;
  /** 계정별 손실한도 조회 */
  getUserLossLimitByAccountIds(
    request: GetUserLossLimitByAccountIdsRequest,
    callback: (
      error: ServiceError | null,
      response: GetUserLossLimitByAccountIdsResponse,
    ) => void,
  ): ClientUnaryCall;
  getUserLossLimitByAccountIds(
    request: GetUserLossLimitByAccountIdsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetUserLossLimitByAccountIdsResponse,
    ) => void,
  ): ClientUnaryCall;
  getUserLossLimitByAccountIds(
    request: GetUserLossLimitByAccountIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetUserLossLimitByAccountIdsResponse,
    ) => void,
  ): ClientUnaryCall;
  /** admin */
  adminGetAllUser(
    request: AdminGetAllUserRequest,
    callback: (
      error: ServiceError | null,
      response: AdminGetAllUserResponse,
    ) => void,
  ): ClientUnaryCall;
  adminGetAllUser(
    request: AdminGetAllUserRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: AdminGetAllUserResponse,
    ) => void,
  ): ClientUnaryCall;
  adminGetAllUser(
    request: AdminGetAllUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: AdminGetAllUserResponse,
    ) => void,
  ): ClientUnaryCall;
  /** not ready to release */
  transferAccount(
    request: TransferAccountRequest,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  transferAccount(
    request: TransferAccountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
  transferAccount(
    request: TransferAccountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DefaultResponse) => void,
  ): ClientUnaryCall;
}

export const UserServiceClient = makeGenericClientConstructor(
  UserServiceService,
  'user.UserService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): UserServiceClient;
  service: typeof UserServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
